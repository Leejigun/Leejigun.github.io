<!-- footer도 여기에 있음 -->


<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- iOS-tip 이라고 태그를 만들었으면 post에서는 iOS tip 이라고 태그를 줘야한다. -->
<!-- dynamically fixing the title for tag/author pages -->



    <title>[Tayga 개발기] (3) - RxSwift를 통한 Moya 비동기 처리</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />
    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="RxSwift를 사용해 비동기 데이터 처리." />
    <link rel="shortcut icon" href="https://leejigun.github.io//assets/images/blog-icon.png" type="image/png" />
    <link rel="canonical" href="https://leejigun.github.io//Tayga-Moya,RxSwift" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="iOS 삽질 블로그" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="[Tayga 개발기] (3) - RxSwift를 통한 Moya 비동기 처리" />
    <meta property="og:description" content="저번 포스트에 이어서 Moya 타겟에 실제로 RxSwift를 통해 데이터를 읽어오겠습니다. 저번 포스트에서 만든 Endpoint로 이루어진 타겟 enum은 실제로는 아무 동작도 하지 않습니다. 그저 타겟 타입들을 정해주는 역할을 수행할 뿐 실제 동작을 위해서는 Provider가 필요합니다. MoyaProvider 시작하기 앞서 GameListViewModel을 만들어줍니다. (이 ViewModel은 GameListViewController의 뷰 모델로 게임 리스트를 뿌려줄 로직을 정의하기 위해서" />
    <meta property="og:url" content="https://leejigun.github.io//Tayga-Moya,RxSwift" />
    <meta property="og:image" content="https://leejigun.github.io//assets/images/tayga/ReactiveX_logo.png" />
    <meta property="article:publisher" content="https://www.facebook.com/" />
    <meta property="article:author" content="https://www.facebook.com/" />
    <meta property="article:published_time" content="2018-06-07T09:00:00+09:00" />
    <meta property="article:modified_time" content="2018-06-07T09:00:00+09:00" />
    <meta property="article:tag" content="Project" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="[Tayga 개발기] (3) - RxSwift를 통한 Moya 비동기 처리" />
    <meta name="twitter:description" content="저번 포스트에 이어서 Moya 타겟에 실제로 RxSwift를 통해 데이터를 읽어오겠습니다. 저번 포스트에서 만든 Endpoint로 이루어진 타겟 enum은 실제로는 아무 동작도 하지 않습니다. 그저 타겟 타입들을 정해주는 역할을 수행할 뿐 실제 동작을 위해서는 Provider가 필요합니다. MoyaProvider 시작하기 앞서 GameListViewModel을 만들어줍니다. (이 ViewModel은 GameListViewController의 뷰 모델로 게임 리스트를 뿌려줄 로직을 정의하기 위해서" />
    <meta name="twitter:url" content="https://leejigun.github.io//" />
    <meta name="twitter:image" content="https://leejigun.github.io//assets/images/tayga/ReactiveX_logo.png" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="iOS 삽질 블로그" />
    <meta name="twitter:label2" content="Filed under" />
    <meta name="twitter:data2" content="Project" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta property="og:image:width" content="1400" />
    <meta property="og:image:height" content="933" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "iOS 삽질 블로그",
        "logo": "https://leejigun.github.io//assets/images/blog-icon.png"
    },
    "url": "https://leejigun.github.io//Tayga-Moya,RxSwift",
    "image": {
        "@type": "ImageObject",
        "url": "https://leejigun.github.io//assets/images/tayga/ReactiveX_logo.png",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://leejigun.github.io//Tayga-Moya,RxSwift"
    },
    "description": "저번 포스트에 이어서 Moya 타겟에 실제로 RxSwift를 통해 데이터를 읽어오겠습니다. 저번 포스트에서 만든 Endpoint로 이루어진 타겟 enum은 실제로는 아무 동작도 하지 않습니다. 그저 타겟 타입들을 정해주는 역할을 수행할 뿐 실제 동작을 위해서는 Provider가 필요합니다. MoyaProvider 시작하기 앞서 GameListViewModel을 만들어줍니다. (이 ViewModel은 GameListViewController의 뷰 모델로 게임 리스트를 뿌려줄 로직을 정의하기 위해서"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="[Tayga 개발기] (3) - RxSwift를 통한 Moya 비동기 처리" href="/feed.xml" />


</head>
<body class="post-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->

        <!-- HTML elements for search -->

        <!-- default -->

<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<header class="site-header outer">
    <div class="inner">
        <!-- 네비게이션 바 -->
<nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="https://leejigun.github.io//"><img src="/assets/images/blog-icon.png" alt="iOS 삽질 블로그" /></a>
            
        
        
            <!-- 여기서 navigation 에 표시할 이이템 추가 -->
<ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <li class="nav-about" role="menuitem"><a href="/about/">About</a></li>
    <li class="nav-getting-started" role="menuitem"><a href="/tag/ios-tip/">iOS tip</a></li>
    <li class="nav-getting-started" role="menuitem"><a href="/tag/watchos/">watchOS</a></li>
    <li class="nav-getting-started" role="menuitem"><a href="/tag/rxswift/">RxSwift</a></li>
    <li class="nav-getting-started" role="menuitem"><a href="/tag/swiftui/">swiftui</a></li>
    <li class="nav-getting-started" role="menuitem"><a href="/tag/project/">project</a></li>
    <li class="nav-getting-started" role="menuitem"><a href="/tag/ml/">ML</a></li>
    <li class="nav-try-ghost" role="menuitem"><a href="https://github.com/Leejigun">github</a></li>
    <li class="nav-try-ghost" role="menuitem"><a href="/search.html">Search</a></li>
</ul>

        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full post tag-getting-started ">

            <header class="post-full-header">
                <section class="post-full-meta">
                    <time class="post-full-meta-date" datetime=" 7 June 2018"> 7 June 2018</time>
                    
                        <span class="date-divider">/</span>
                        
                            
                               <a href='/tag/project/'>PROJECT</a>
                            
                        
                    
                </section>
                <h1 class="post-full-title">[Tayga 개발기] (3) - RxSwift를 통한 Moya 비동기 처리</h1>
            </header>

            
            <figure class="post-full-image" style="background-image: url(/assets/images/tayga/ReactiveX_logo.png)">
            </figure>
            

            <section class="post-full-content">
                <div class="kg-card-markdown">
                    <p>저번 포스트에 이어서 Moya 타겟에 실제로 RxSwift를 통해 데이터를 읽어오겠습니다.</p>

<p>저번 포스트에서 만든 Endpoint로 이루어진 타겟 enum은 실제로는 아무 동작도 하지 않습니다. 그저 타겟 타입들을 정해주는 역할을 수행할 뿐 실제 동작을 위해서는 Provider가 필요합니다.</p>

<h2 id="moyaprovider">MoyaProvider</h2>

<p>시작하기 앞서 GameListViewModel을 만들어줍니다.</p>

<p>(이 ViewModel은 GameListViewController의 뷰 모델로 게임 리스트를 뿌려줄 로직을 정의하기 위해서 분리되었습니다. API를 통한 데이터 불러오기, 가공 등의 작업을 수행하고 controller에서 화면서 그리는 작업을 수행하도록 하겠습니다.)</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">GameListViewModel</span> <span class="p">{</span>
	<span class="k">let</span> <span class="nv">provider</span><span class="p">:</span> <span class="kt">MoyaProvider</span><span class="o">&lt;</span><span class="kt">TwitchAPI</span><span class="o">&gt;</span>
	<span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">provider</span> <span class="o">=</span> <span class="kt">MoyaProvider</span><span class="o">&lt;</span><span class="kt">TwitchAPI</span><span class="o">&gt;</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Provider를 통해서 네트워크 통신을 수행합니다. 하지만 RxSwift를 사용하기 전에 Moya github에 나와있는 Rx를 사용하지 않는 Provider의 사용법을 먼저 확인해 봅시다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">provider</span> <span class="o">=</span> <span class="kt">MoyaProvider</span><span class="o">&lt;</span><span class="kt">GitHub</span><span class="o">&gt;</span><span class="p">()</span>
<span class="n">provider</span><span class="o">.</span><span class="nf">request</span><span class="p">(</span><span class="o">.</span><span class="n">zen</span><span class="p">)</span> <span class="p">{</span> <span class="n">result</span> <span class="k">in</span>
    <span class="k">switch</span> <span class="n">result</span> <span class="p">{</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="nf">success</span><span class="p">(</span><span class="n">moyaResponse</span><span class="p">):</span>
        <span class="k">let</span> <span class="nv">data</span> <span class="o">=</span> <span class="n">moyaResponse</span><span class="o">.</span><span class="n">data</span>
        <span class="k">let</span> <span class="nv">statusCode</span> <span class="o">=</span> <span class="n">moyaResponse</span><span class="o">.</span><span class="n">statusCode</span>
        <span class="c1">// do something with the response data or statusCode</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="nf">failure</span><span class="p">(</span><span class="n">error</span><span class="p">):</span>
        <span class="c1">// this means there was a network failure - either the request</span>
        <span class="c1">// wasn't sent (connectivity), or no response was received (server</span>
        <span class="c1">// timed out).  If the server responds with a 4xx or 5xx error, that</span>
        <span class="c1">// will be sent as a ".success"-ful response.</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>내용을 살펴보면 우리가 정의한 TwitchAPI enum 타겟과 마찬가지로 Moya의 예제에서는 GitHub라는 타겟을 사전에 정의해 놓고 비동기 컴플리트 클로져를 통해서 완료시 행동을 정의하고 있습니다.</p>

<p>이것을 RxSwift를 쓰면 어떻게 될까요?</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">provider</span> <span class="o">=</span> <span class="kt">MoyaProvider</span><span class="o">&lt;</span><span class="kt">GitHub</span><span class="o">&gt;</span><span class="p">()</span>
<span class="n">provider</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="nf">request</span><span class="p">(</span><span class="o">.</span><span class="nf">userProfile</span><span class="p">(</span><span class="s">"ashfurrow"</span><span class="p">))</span><span class="o">.</span><span class="n">subscribe</span> <span class="p">{</span> <span class="n">event</span> <span class="k">in</span>
    <span class="k">switch</span> <span class="n">event</span> <span class="p">{</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="nf">success</span><span class="p">(</span><span class="n">response</span><span class="p">):</span>
        <span class="n">image</span> <span class="o">=</span> <span class="kt">UIImage</span><span class="p">(</span><span class="nv">data</span><span class="p">:</span> <span class="n">response</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="nf">error</span><span class="p">(</span><span class="n">error</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위와 별반 다를바 없어보이지만, 그것 호출하자 마자 바로 Subscribe를 바로 수행했기 때문입니다. 여기서 주목해야 할 것은 어떻게 subscribe를 바로 진행 할 수 있었냐는 것 입니다.</p>

<p>Provider가 수행하는 request 메소드가 앞서 Rx를 사용하지 않을 땐 returen값이 없었지만, Rx를 사용하게되면 Obserable의 return 값이 반환됩니다. 이 값을 비동기적으로 사용이 가능합니다.</p>

<h2 id="rxswift-연산자">RxSwift 연산자</h2>

<p>이제 제가 만든 게임 리스트 메소드를 봅시다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// get Games Struct from Server</span>
<span class="c1">///</span>
<span class="c1">/// - Parameters:</span>
<span class="c1">///   - limit: count of games</span>
<span class="c1">///   - offset: first item position of game list</span>
<span class="c1">/// - Returns: GamesStruct</span>
<span class="kd">internal</span> <span class="kd">func</span> <span class="nf">getGameList</span><span class="p">(</span><span class="nv">limit</span><span class="p">:</span><span class="kt">Int</span><span class="p">?,</span><span class="nv">offset</span><span class="p">:</span> <span class="kt">Int</span><span class="p">?)</span> <span class="o">-&gt;</span> <span class="kt">Observable</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">GameViewModel</span><span class="p">]</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">param</span> <span class="o">=</span> <span class="p">[</span><span class="s">"limit"</span><span class="p">:</span> <span class="s">"</span><span class="se">\(</span><span class="n">limit</span> <span class="p">??</span> <span class="k">self</span><span class="o">.</span><span class="n">limit</span><span class="se">)</span><span class="s">"</span><span class="p">,</span>
            <span class="s">"offset"</span><span class="p">:</span> <span class="s">"</span><span class="se">\(</span><span class="n">offset</span> <span class="p">??</span> <span class="mi">0</span><span class="se">)</span><span class="s">"</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">provider</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="nf">request</span><span class="p">(</span><span class="o">.</span><span class="nf">getTopGame</span><span class="p">(</span><span class="n">param</span><span class="p">))</span>
        	<span class="o">.</span><span class="nf">retry</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        	<span class="o">.</span><span class="nf">asObservable</span><span class="p">()</span>
            <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="k">try</span> <span class="kt">JSONDecoder</span><span class="p">()</span><span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="kt">GamesStruct</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">from</span><span class="p">:</span> <span class="nv">$0</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="p">}</span>
            <span class="o">.</span><span class="nf">catchErrorJustReturn</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
            <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="p">?</span><span class="o">.</span><span class="n">top</span> <span class="p">??</span> <span class="p">[]</span> <span class="p">}</span>
            <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="nf">enumerated</span><span class="p">()</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="kt">GameViewModel</span><span class="p">(</span><span class="nv">game</span><span class="p">:</span> <span class="nv">$1</span><span class="p">,</span> <span class="nv">offset</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">offset</span><span class="p">)</span> <span class="p">}</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>살펴보기 앞서 GameStruct라는 구조체가 있고, 그 안에 [TopGame] 배열을 가지고 있는 형태입니다. 이 형태는 Twitch에서 내려주는 API 때문이고, JSON 형태에 따라서 바뀔 수 있는 것이기 때문에 중요하지 않습니다.</p>

<p>하나 하나 뜯어봅시다. provider의 request 메소드는 <code class="highlighter-rouge">PrimitiveSequence&lt;SingleTrait, Response&gt;</code> 를 반환합니다. 이 반환값을 그냥 구독해서 사용할 수도 있지만, Obserable에 있는 다양한 오퍼레이터를 사용해 사전 가공할 수 있습니다. 오퍼레이터에 대해서는 RxSwift 깃에 자세히 나와있고 여기서는 실제 제가 짠 코드를 뜯어봅시다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">.</span><span class="nf">retry</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</code></pre></div></div>

<p>Retry의 경우 에러가 발생하면 다시 시도하는 횟수를 지정할 수 있습니다. 여기서는 3회 반복하도록 했습니다.</p>

<p>Rx의 장점인 선언형 프로그래밍을 따라서 윗줄부터 한줄 한줄 뜯어보면 제일 <code class="highlighter-rouge">asObserable()</code> 은 앞서 리턴값인 시퀀스를 <code class="highlighter-rouge">Observable&lt;&gt;</code> 형태로 묶어주는 것입니다. 이 부분을 지나면 반환값은 <code class="highlighter-rouge">Observable&lt;Response&gt;</code>  형태가 됩니다.</p>

<p>이 JSON Data를 GameStruct구조체에 담는 동작이 두번째 줄에서 벌어지는 동작입니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="k">try</span> <span class="kt">JSONDecoder</span><span class="p">()</span><span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="kt">GamesStruct</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">from</span><span class="p">:</span> <span class="nv">$0</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></div>

<p>JSONDecoder를 사용해 디코딩 하는 방법은 Codable을 이용해 인코딩, 디코딩을 수행하는 방법입니다. 이에 대한 포스트는 ios tip 섹션에 설명해 놓겠습니다.</p>

<p>try 를 보면 알겠지만, 이 메소드는 실패시 Error를 발생시킵니다. 이 메소드를 사용할 때에는 try {} catch {} 문과 함께 사용해야 하는데요. 여기서보면 그저 .map {} 오퍼레이터만을 사용하고 있습니다.</p>

<p>(<a href="http://rxmarbles.com/#map">map</a>은 이벤트를 다른 이벤트로 변환하는 역할을 수행합니다. <code class="highlighter-rouge">Obserable&lt;Response&gt;</code> 이벤트가 <code class="highlighter-rouge">Obserable&lt;GamesStruct&gt;</code> 이벤트로 바뀌는 용도로 사용했습니다.)</p>

<p>만약, 여기서 실패해서 error를 만들게 된다면, <code class="highlighter-rouge">Obserable&lt;Error&gt;</code>가 반환됩니다.</p>

<p>다음줄을 살펴봅시다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">.</span><span class="nf">catchErrorJustReturn</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
</code></pre></div></div>

<p>오퍼레이터 이름을 보면 알겠지만, 단순하게 에러가 발생하면 특정 값을 리턴하도록 하는 오퍼레이터입니다. 만약, 데이터 형태가 잘못되었거나, 서버에서 거부되는 등 에러가 발생하였을 때, 그에 따라 다른 처리도 가능하지만, 여기서는 그냥 return nil을 하도록 했습니다. 만약, 기본값이 있다면 기본 형태의 데이터를 반환하면 됩니다.</p>

<p>이 오퍼레이터를 추가했기 때문에 이제 반환값은 nil일 수도 있는 <code class="highlighter-rouge">Observable&lt;GameStruct?&gt;</code> 입니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="p">?</span><span class="o">.</span><span class="n">top</span> <span class="p">??</span> <span class="p">[]</span> <span class="p">}</span>
</code></pre></div></div>

<p>다음줄은 이 GmaeStruct안에 있는 <code class="highlighter-rouge">let top: [TopGame]</code> 을 꺼내는 동작입니다. 앞서 말했듯이 이 map으로 들어오는 값은 <code class="highlighter-rouge">Observable&lt;GameStruct?&gt;</code> 형태로 옵셔널 값이기 때문에 만약 nil이면 빈 배열을 반환하게 됩니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="nf">enumerated</span><span class="p">()</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="kt">GameViewModel</span><span class="p">(</span><span class="nv">game</span><span class="p">:</span> <span class="nv">$1</span><span class="p">,</span> <span class="nv">offset</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">offset</span><span class="p">)</span> <span class="p">}</span> <span class="p">}</span>
</code></pre></div></div>

<p>이제<code class="highlighter-rouge"> [TopGame]</code> 배열의 요소를 하나 하나 꺼내서 <code class="highlighter-rouge">[GameViewModel]</code> 배열로 만드는 작업입니다. 이 부분을 다 수행하면 반환되는 값은 <code class="highlighter-rouge">Observable&lt;[GameViewModel]&gt;</code> 형태가 됩니다.</p>

<p>(만약, 앞서 디코딩 부분에서 에러가 발생했다면 빈 배열이 내려왔을 것이고 여기서도 map을 통해 연산했지만 빈 배열이 리턴될 것입니다.)</p>

<p>이제 이 값을 구독하면 데이터를 확인 할 수 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">loadData</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">getGameList</span><span class="p">(</span><span class="nv">limit</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span><span class="nv">offset</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
    	<span class="o">.</span><span class="nf">subscribe</span><span class="p">(</span><span class="nv">onNext</span><span class="p">:</span> <span class="p">{</span>
            <span class="nf">print</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span>
        <span class="p">})</span><span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="multithreading">Multithreading</h2>

<p>여기까지 크게 복잡한 로직은 아니지만, Moya와 RxSwift를 사용해 비동기 통신과 데이터 가공 로직을 살펴봤습니다. 여기서 로직을 확인해 보면, 네트워킹 이후 데이터를 파싱하고 가공하는 반복되는 동작을 수행합니다. 만약, 데이터 양이 많고 로직이 복잡하다면 충분히 많은 시간을 소요할 것으로 보입니다.</p>

<p>따라서, 여기에 멀티 스레딩을 적용해서 데이터를 가져와 파싱하는 동작을 워커 스레드에서 수행하도록 해봅시다. Rx에서 멀티 스레딩을 할 때 알아야 할 오퍼레이터는 <code class="highlighter-rouge">observeOn()</code> 과<code class="highlighter-rouge"> subscribeOn()</code> 입니다.</p>

<p><code class="highlighter-rouge"> subscribeOn()</code> 은 최초 Observable이 동작하는 스케줄러를 지정합니다. 만약, 모든 동작이 백그라운드 스레드에서만 동작하면 충분할 경우 <code class="highlighter-rouge">subscribeOn()</code>  만 사용해 구현 가능합니다. <code class="highlighter-rouge">observeOn()</code> 은 중간에 흐름을 바꿀 때 사용합니다. <code class="highlighter-rouge">observeOn</code> 을 반복해서 사용해서 메인 스레드와 백그라운드 스레드를 왔다갔다 할 수 있습니다.</p>

<p>RxSwift 문서를 살펴보면 4가지 스케줄러가 나와있습니다.</p>

<h2 id="mainscheduler-serial-scheduler">MainScheduler (Serial scheduler)</h2>

<p>Abstracts work that needs to be performed on <code class="highlighter-rouge">MainThread</code>. In case <code class="highlighter-rouge">schedule</code> methods are called from main thread, it will perform the action immediately without scheduling.</p>

<p>This scheduler is usually used to perform UI work.</p>

<h2 id="serialdispatchqueuescheduler-serial-scheduler">SerialDispatchQueueScheduler (Serial scheduler)</h2>

<p>Abstracts the work that needs to be performed on a specific <code class="highlighter-rouge">dispatch_queue_t</code>. It will make sure that even if a concurrent dispatch queue is passed, it’s transformed into a serial one.</p>

<p>Serial schedulers enable certain optimizations for <code class="highlighter-rouge">observeOn</code>.</p>

<p>The main scheduler is an instance of <code class="highlighter-rouge">SerialDispatchQueueScheduler</code>.</p>

<h2 id="concurrentdispatchqueuescheduler-concurrent-scheduler">ConcurrentDispatchQueueScheduler (Concurrent scheduler)</h2>

<p>Abstracts the work that needs to be performed on a specific <code class="highlighter-rouge">dispatch_queue_t</code>. You can also pass a serial dispatch queue, it shouldn’t cause any problems.</p>

<p>This scheduler is suitable when some work needs to be performed in the background.</p>

<h2 id="operationqueuescheduler-concurrent-scheduler">OperationQueueScheduler (Concurrent scheduler)</h2>

<p>Abstracts the work that needs to be performed on a specific <code class="highlighter-rouge">NSOperationQueue</code>.</p>

<p>This scheduler is suitable for cases when there is some bigger chunk of work that needs to be performed in the background and you want to fine tune concurrent processing using <code class="highlighter-rouge">maxConcurrentOperationCount</code>.</p>

<p>스케줄러의 이름들을 보면 시리얼과 컨커런트로 나눌 수 있습니다. 시리얼은 직렬 큐 작업 큐를 만들어 동작을 수행하고, 컨커런트는 병렬로 작업 큐를 만들어 동시 수행합니다. 이해하기 쉽게 하기 위해서 간단하게 설명된 <a href="https://stackoverflow.com/questions/19179358/concurrent-vs-serial-queues-in-gcd">예문</a>을 가져왔습니다.</p>

<ul>
  <li>async - concurrent: 코드는 백그라운드에서 동작합니다. 제어는 즉각적으로 메인 스레드로 돌아오며 UI를 업데이트 할 수 있습니다. 이 때 실행중인 코드 블럭은 현재 이 큐에서 실행중인 유일한 블록임을 장담할 수 없습니다. 작업은 큐 순서대로 수행되지만, 다른 워커 스레드가 생긴다면 아직 다른 작업이 수행중이더라도 큐의 다음 블럭을 수행하도록 넘겨 줄 수 있습니다.</li>
  <li>async - serial: 코드는 백그라운드에서 동작합니다. 제어는 즉각적으로 메인 스레드로 돌아오며 UI를 업데이트 할 수 있습니다. 이 때 다른 스레드가 있더라고 이 큐의 코드는 한번에 하나의 블럭에서만 수행됩니다. 앞의 블럭이 끝나야 다음 블럭이 수행될 수 있습니다.</li>
  <li>sync - concurrent: 코드는 백그라운드에서 수행되지만, 메인 스레드는 작업이 완료될 때 까지 기다립니다. UI를 업데이트 할 수 없습니다. 작업은 큐 순서대로 수행되지만, 다른 워커 스레드가 생긴다면 아직 다른 작업이 수행중이더라도 큐의 다음 블럭을 수행하도록 넘겨 줄 수 있습니다.</li>
  <li>sync - serial: 코드는 백그라운드에서 수행되지만, 메인 스레드는 작업이 완료될 때 까지 기다립니다. UI를 업데이트 할 수 없습니다. 이 때 다른 스레드가 있더라고 이 큐의 코드는 한번에 하나의 블럭에서만 수행됩니다. 앞의 블럭이 끝나야 다음 블럭이 수행될 수 있습니다.</li>
</ul>

<p>Serial은 싱글 스레드, concurrent는 멀티 스레드 방식으로 큐의 작업들을 수행합니다. GCD에 대한 설명 링크들을 추가합니다.</p>

<ul>
  <li>https://m.blog.naver.com/PostView.nhn?blogId=itperson&amp;logNo=220915666962&amp;proxyReferer=https%3A%2F%2Fwww.google.co.kr%2F</li>
  <li>https://brunch.co.kr/@tilltue/29</li>
</ul>

<p>다시 RxSwift로 돌아와 문서 내용을 읽어보면 친절하게 <code class="highlighter-rouge">MainScheduler</code> 는 UI 작업에 적합하고 <code class="highlighter-rouge">Concurrent Dispatch QueueScheduler</code> 는 백그라운드 작업을 수행할 때 사용하라고 달려있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">return</span> <span class="n">provider</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="nf">request</span><span class="p">(</span><span class="o">.</span><span class="nf">getTopGame</span><span class="p">(</span><span class="n">param</span><span class="p">))</span>
        	<span class="o">.</span><span class="nf">retry</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        	<span class="o">.</span><span class="nf">asObservable</span><span class="p">()</span>
            <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="k">try</span> <span class="kt">JSONDecoder</span><span class="p">()</span><span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="kt">GamesStruct</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">from</span><span class="p">:</span> <span class="nv">$0</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="p">}</span>
            <span class="o">.</span><span class="nf">catchErrorJustReturn</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
            <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="p">?</span><span class="o">.</span><span class="n">top</span> <span class="p">??</span> <span class="p">[]</span> <span class="p">}</span>
            <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="nf">enumerated</span><span class="p">()</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="kt">GameViewModel</span><span class="p">(</span><span class="nv">game</span><span class="p">:</span> <span class="nv">$1</span><span class="p">,</span> <span class="nv">offset</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">offset</span><span class="p">)</span> <span class="p">}</span> <span class="p">}</span>
</code></pre></div></div>

<p>기존에 사용했던 메소드입니다.</p>

<p><code class="highlighter-rouge"> SubscribeOn</code> 은 어디서 <code class="highlighter-rouge">Observable</code> 시작할 것인지, <code class="highlighter-rouge">ObserveOn()</code> 은 중간에 흐름을 바꿀 때 사용합니다. 그렇다면 여기서 모든 동작을 백그라운드에서 수행하도록 하겠습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">return</span> <span class="n">provider</span><span class="o">.</span><span class="n">rx</span><span class="o">.</span><span class="nf">request</span><span class="p">(</span><span class="o">.</span><span class="nf">getTopGame</span><span class="p">(</span><span class="n">param</span><span class="p">))</span>
        	<span class="o">.</span><span class="nf">retry</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        	<span class="o">.</span><span class="nf">observeOn</span><span class="p">(</span><span class="kt">ConcurrentDispatchQueueScheduler</span><span class="p">(</span><span class="nv">qos</span><span class="p">:</span> <span class="o">.</span><span class="n">background</span><span class="p">))</span>
        	<span class="o">.</span><span class="nf">asObservable</span><span class="p">()</span>
            <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="k">try</span> <span class="kt">JSONDecoder</span><span class="p">()</span><span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="kt">GamesStruct</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">from</span><span class="p">:</span> <span class="nv">$0</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="p">}</span>
            <span class="o">.</span><span class="nf">catchErrorJustReturn</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
            <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="p">?</span><span class="o">.</span><span class="n">top</span> <span class="p">??</span> <span class="p">[]</span> <span class="p">}</span>
            <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="nf">enumerated</span><span class="p">()</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="kt">GameViewModel</span><span class="p">(</span><span class="nv">game</span><span class="p">:</span> <span class="nv">$1</span><span class="p">,</span> <span class="nv">offset</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">offset</span><span class="p">)</span> <span class="p">}</span> <span class="p">}</span>
</code></pre></div></div>

<p>간단하게 한줄 추가하는 것으로 백그라운드 작업을 가능하게 했습니다. 만약, 데이터를 가져오고 그 후 UI 작업을 수행하게 된다면, 흐름을 바꿔줘야 합니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">loadData</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">getGameList</span><span class="p">(</span><span class="nv">limit</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span><span class="nv">offset</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
    	<span class="o">.</span><span class="nf">observeOn</span><span class="p">(</span><span class="kt">MainScheduler</span><span class="o">.</span><span class="n">instance</span><span class="p">)</span>
    	<span class="o">.</span><span class="nf">subscribe</span><span class="p">(</span><span class="nv">onNext</span><span class="p">:</span> <span class="p">{</span>
            <span class="c1">/// UI 작업</span>
        <span class="p">})</span><span class="o">.</span><span class="nf">disposed</span><span class="p">(</span><span class="nv">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>앞서 RxSwift 문서에 나와있듯이 UI 작업을 하기 위해서 <code class="highlighter-rouge">MainScheduler</code> 를 사용했습니다. 만약, 굳이 UI 작업이 없다면 전부 백그라운드에서 수행해도 문제 없습니다.</p>

                </div>
            </section>

            <!-- Email subscribe form at the bottom of the page -->
            

            <footer class="post-full-footer">
                <!-- Everything inside the #author tags pulls data from the author -->
                <!-- #author-->
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                <!-- /author  -->
            </footer>

            <!-- If you use Disqus comments, just uncomment this block.
            The only thing you need to change is "test-apkdzgmqhj" - which
            should be replaced with your own Disqus site-id. -->
            
                <section class="post-full-comments">
                    <div id="disqus_thread"></div>
                    <script>
                        var disqus_config = function () {
                            this.page.url = 'https://leejigun.github.io//';
                            this.page.identifier = 'iOS 삽질 블로그';
                        };
                        (function() {
                            var d = document, s = d.createElement('script');
                            s.src = 'https://jglee.disqus.com/embed.js';
                            s.setAttribute('data-timestamp', +new Date());
                            (d.head || d.body).appendChild(s);
                        })();
                    </script>
                </section>
            

        </article>

    </div>
</main>

<!-- Links to Previous/Next posts -->
<aside class="read-next outer">
    <div class="inner">
        <div class="read-next-feed">
            
                
                
                
                
                    <article class="read-next-card"
                        
                            style="background-image: url(/assets/images/blog-cover.jpg)"
                        
                    >
                        <header class="read-next-card-header">
                            <small class="read-next-card-header-sitetitle">&mdash; iOS 삽질 블로그 &mdash;</small>
                            
                                <h3 class="read-next-card-header-title"><a href="/tag/project/">Project</a></h3>
                            
                        </header>
                        <div class="read-next-divider"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 14.5s2 3 5 3 5.5-2.463 5.5-5.5S21 6.5 18 6.5c-5 0-7 11-12 11C2.962 17.5.5 15.037.5 12S3 6.5 6 6.5s4.5 3.5 4.5 3.5"/></svg>
</div>
                        <div class="read-next-card-content">
                            <ul>
                                
                                
                                  
                                
                                  
                                
                                  
                                    
                                        
                                        
                                            <li><a href="/SwiftUI_page_based_navigation">SwiftUI에서 page based navigation 사용하기</a></li>
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                            <li><a href="/Circle_Timer_4_MVVM_Combine">Circle Timer 만들기_4_MVVM_Combine</a></li>
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                            <li><a href="/Circle_Timer_3_User_Interation">Circle Timer 만들기_3_User_Interation(SwiftUI, gesture, DragGesture)</a></li>
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                            </ul>
                        </div>
                        <footer class="read-next-card-footer">
                            <a href="/tag/project/">
                                
                                    See all 7 posts  →
                                
                            </a>
                        </footer>
                    </article>
                
            

            <!-- If there's a next post, display it using the same markup included from - partials/post-card.hbs -->
            
                
    <article class="post-card post-template">
        
            <a class="post-card-image-link" href="/JSON_parsing_using_Codable">
                <div class="post-card-image" style="background-image: url(/assets/images/Swift-JSON-Encoding.jpg)"></div>
            </a>
        
        <div class="post-card-content">
            <a class="post-card-content-link" href="/JSON_parsing_using_Codable">
                <header class="post-card-header">
                    
                        
                            
                                <span class="post-card-tags">Ios tip</span>
                            
                        
                    

                    <h2 class="post-card-title">Codable을 사용한 JSON 데이터 파싱</h2>
                </header>
                <section class="post-card-excerpt">
                    <p>이번 포스트에서는 Swift4에서 추가된 **Codable** 프로토콜을 사용해 JSON 데이터를 처리하는 방법을 알아보겠습니다. 과거 제가 처음으로 iOS를 공부할 때에는 `JSONSerialization` 을 사용한 방법이 책에 나와있었고 저도 한동안 그 방법으로 JSON 데이터를 처리했었습니다. (깊이 있는</p>
                </section>
            </a>
            <footer class="post-card-meta">
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </footer>
        </div>
    </article>

            

            <!-- If there's a previous post, display it using the same markup included from - partials/post-card.hbs -->
            
                
    <article class="post-card post-template">
        
            <a class="post-card-image-link" href="/Tayga-TwitchAPI-Moya">
                <div class="post-card-image" style="background-image: url(/assets/images/tayga/moya_logo_github.png)"></div>
            </a>
        
        <div class="post-card-content">
            <a class="post-card-content-link" href="/Tayga-TwitchAPI-Moya">
                <header class="post-card-header">
                    
                        
                            
                                <span class="post-card-tags">Project</span>
                            
                        
                    

                    <h2 class="post-card-title">[Tayga 개발기] (2) - Moya, TwitchAPI를 통해 데이터 불러오기.</h2>
                </header>
                <section class="post-card-excerpt">
                    <p>네트워크 라이브러리의 경우, 개발 과정에서 거의 필수로 사용하고 있다. 안드로이드 개발을 진행할 땐 주로 Retrofit과 Gson을 사용해 네트워크 이벤트를 처리했었다. 사실 네트워크 라이브러리를 사용하지 않더라도 개발을 진행할 수 있지만, 많은 개발자들의 회고들을 보면,</p>
                </section>
            </a>
            <footer class="post-card-meta">
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </footer>
        </div>
    </article>

            

        </div>
    </div>
</aside>

<!-- Floating header which appears on-scroll, included from includes/floating-header.hbs -->
<div class="floating-header">
    <div class="floating-header-logo">
        <a href="https://leejigun.github.io//">
            
                <img src="/assets/images/blog-icon.png" alt="iOS 삽질 블로그 icon" />
            
            <span>iOS 삽질 블로그</span>
        </a>
    </div>
    <span class="floating-header-divider">&mdash;</span>
    <div class="floating-header-title">[Tayga 개발기] (3) - RxSwift를 통한 Moya 비동기 처리</div>
    <div class="floating-header-share">
        <div class="floating-header-share-label">Share this <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
    <path d="M7.5 15.5V4a1.5 1.5 0 1 1 3 0v4.5h2a1 1 0 0 1 1 1h2a1 1 0 0 1 1 1H18a1.5 1.5 0 0 1 1.5 1.5v3.099c0 .929-.13 1.854-.385 2.748L17.5 23.5h-9c-1.5-2-5.417-8.673-5.417-8.673a1.2 1.2 0 0 1 1.76-1.605L7.5 15.5zm6-6v2m-3-3.5v3.5m6-1v2"/>
</svg>
</div>
        <a class="floating-header-share-tw" href="https://twitter.com/share?text=%5BTayga+%EA%B0%9C%EB%B0%9C%EA%B8%B0%5D+%283%29+-+RxSwift%EB%A5%BC+%ED%86%B5%ED%95%9C+Moya+%EB%B9%84%EB%8F%99%EA%B8%B0+%EC%B2%98%EB%A6%AC&amp;url=https://leejigun.github.io/Tayga-Moya,RxSwift"
            onclick="window.open(this.href, 'share-twitter', 'width=550,height=235');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M30.063 7.313c-.813 1.125-1.75 2.125-2.875 2.938v.75c0 1.563-.188 3.125-.688 4.625a15.088 15.088 0 0 1-2.063 4.438c-.875 1.438-2 2.688-3.25 3.813a15.015 15.015 0 0 1-4.625 2.563c-1.813.688-3.75 1-5.75 1-3.25 0-6.188-.875-8.875-2.625.438.063.875.125 1.375.125 2.688 0 5.063-.875 7.188-2.5-1.25 0-2.375-.375-3.375-1.125s-1.688-1.688-2.063-2.875c.438.063.813.125 1.125.125.5 0 1-.063 1.5-.25-1.313-.25-2.438-.938-3.313-1.938a5.673 5.673 0 0 1-1.313-3.688v-.063c.813.438 1.688.688 2.625.688a5.228 5.228 0 0 1-1.875-2c-.5-.875-.688-1.813-.688-2.75 0-1.063.25-2.063.75-2.938 1.438 1.75 3.188 3.188 5.25 4.25s4.313 1.688 6.688 1.813a5.579 5.579 0 0 1 1.5-5.438c1.125-1.125 2.5-1.688 4.125-1.688s3.063.625 4.188 1.813a11.48 11.48 0 0 0 3.688-1.375c-.438 1.375-1.313 2.438-2.563 3.188 1.125-.125 2.188-.438 3.313-.875z"/></svg>

        </a>
        <a class="floating-header-share-fb" href="https://www.facebook.com/sharer/sharer.php?u=https://leejigun.github.io/Tayga-Moya,RxSwift"
            onclick="window.open(this.href, 'share-facebook','width=580,height=296');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M19 6h5V0h-5c-3.86 0-7 3.14-7 7v3H8v6h4v16h6V16h5l1-6h-6V7c0-.542.458-1 1-1z"/></svg>

        </a>
    </div>
    <progress class="progress" value="0">
        <div class="progress-container">
            <span class="progress-bar"></span>
        </div>
    </progress>
</div>


<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->


        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://leejigun.github.io//">iOS 삽질 블로그</a> &copy; 2022</section>
                <section class="poweredby">Github page blog of <a href="https://github.com/Leejigun">Leejigun</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyller/jasper2" target="_blank" rel="noopener">Jasper2</a></section>
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    
                    
                    <!-- <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a> -->
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    

    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-154736789-1', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>

// NOTE: Scroll performance is poor in Safari
// - this appears to be due to the events firing much more slowly in Safari.
//   Dropping the scroll event and using only a raf loop results in smoother
//   scrolling but continuous processing even when not scrolling
$(document).ready(function () {
    // Start fitVids
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
    // End fitVids

    var progressBar = document.querySelector('progress');
    var header = document.querySelector('.floating-header');
    var title = document.querySelector('.post-full-title');

    var lastScrollY = window.scrollY;
    var lastWindowHeight = window.innerHeight;
    var lastDocumentHeight = $(document).height();
    var ticking = false;

    function onScroll() {
        lastScrollY = window.scrollY;
        requestTick();
    }

    function onResize() {
        lastWindowHeight = window.innerHeight;
        lastDocumentHeight = $(document).height();
        requestTick();
    }

    function requestTick() {
        if (!ticking) {
            requestAnimationFrame(update);
        }
        ticking = true;
    }

    function update() {
        var trigger = title.getBoundingClientRect().top + window.scrollY;
        var triggerOffset = title.offsetHeight + 35;
        var progressMax = lastDocumentHeight - lastWindowHeight;

        // show/hide floating header
        if (lastScrollY >= trigger + triggerOffset) {
            header.classList.add('floating-active');
        } else {
            header.classList.remove('floating-active');
        }

        progressBar.setAttribute('max', progressMax);
        progressBar.setAttribute('value', lastScrollY);

        ticking = false;
    }

    window.addEventListener('scroll', onScroll, {passive: true});
    window.addEventListener('resize', onResize, false);

    update();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
