<!-- footer도 여기에 있음 -->


<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- iOS-tip 이라고 태그를 만들었으면 post에서는 iOS tip 이라고 태그를 줘야한다. -->
<!-- dynamically fixing the title for tag/author pages -->



    <title>Thinking in SwiftUI - 3장 Layout</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />
    <!-- highlight.js -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="iOS developer." />
    <link rel="shortcut icon" href="http://localhost:4001/assets/images/blog-icon.png" type="image/png" />
    <link rel="canonical" href="http://localhost:4001/Thinking-in-SwiftUI-3%EC%9E%A5-Layout" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="iOS 삽질 블로그" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Thinking in SwiftUI - 3장 Layout" />
    <meta property="og:description" content="Text 기본적으로 Text 뷰는 제안된 크기에 맞게 조정됩니다. 텍스트는 이 작업을 수행하기 위해 다음 순서로 여러 전략을 사용합니다: 텍스트를 여러 줄로 나누기(단어 줄 바꿈), 단어를 나누기(줄 바꿈), 자르기, 마지막으로 텍스트를 조정하기. 텍스트는 항상 콘텐츠를 렌더링하는데 필요한 정확한 크기를 반환합니다. 이 크기는 제안된 너비보다 작거나 같고 최소한 한 줄의 높이입니다(0 제안" />
    <meta property="og:url" content="http://localhost:4001/Thinking-in-SwiftUI-3%EC%9E%A5-Layout" />
    <meta property="og:image" content="http://localhost:4001/assets/images/blog-cover.jpg" />
    <meta property="article:publisher" content="https://www.facebook.com/" />
    <meta property="article:author" content="https://www.facebook.com/" />
    <meta property="article:published_time" content="2025-06-05T03:16:50+09:00" />
    <meta property="article:modified_time" content="2025-06-05T03:16:50+09:00" />
    <meta property="article:tag" content="Uncategorized" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Thinking in SwiftUI - 3장 Layout" />
    <meta name="twitter:description" content="Text 기본적으로 Text 뷰는 제안된 크기에 맞게 조정됩니다. 텍스트는 이 작업을 수행하기 위해 다음 순서로 여러 전략을 사용합니다: 텍스트를 여러 줄로 나누기(단어 줄 바꿈), 단어를 나누기(줄 바꿈), 자르기, 마지막으로 텍스트를 조정하기. 텍스트는 항상 콘텐츠를 렌더링하는데 필요한 정확한 크기를 반환합니다. 이 크기는 제안된 너비보다 작거나 같고 최소한 한 줄의 높이입니다(0 제안" />
    <meta name="twitter:url" content="http://localhost:4001/" />
    <meta name="twitter:image" content="http://localhost:4001/assets/images/blog-cover.jpg" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="iOS 삽질 블로그" />
    <meta name="twitter:label2" content="Filed under" />
    <meta name="twitter:data2" content="Uncategorized" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta property="og:image:width" content="1400" />
    <meta property="og:image:height" content="933" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "iOS 삽질 블로그",
        "logo": "http://localhost:4001/assets/images/blog-icon.png"
    },
    "url": "http://localhost:4001/Thinking-in-SwiftUI-3%EC%9E%A5-Layout",
    "image": {
        "@type": "ImageObject",
        "url": "http://localhost:4001/assets/images/blog-cover.jpg",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "http://localhost:4001/Thinking-in-SwiftUI-3%EC%9E%A5-Layout"
    },
    "description": "Text 기본적으로 Text 뷰는 제안된 크기에 맞게 조정됩니다. 텍스트는 이 작업을 수행하기 위해 다음 순서로 여러 전략을 사용합니다: 텍스트를 여러 줄로 나누기(단어 줄 바꿈), 단어를 나누기(줄 바꿈), 자르기, 마지막으로 텍스트를 조정하기. 텍스트는 항상 콘텐츠를 렌더링하는데 필요한 정확한 크기를 반환합니다. 이 크기는 제안된 너비보다 작거나 같고 최소한 한 줄의 높이입니다(0 제안"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="Thinking in SwiftUI - 3장 Layout" href="/feed.xml" />


</head>
<body class="post-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->

        <!-- HTML elements for search -->

        <!-- default -->

<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<header class="site-header outer">
    <div class="inner">
        <!-- 네비게이션 바 -->
<nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="http://localhost:4001/"><img src="/assets/images/blog-icon.png" alt="iOS 삽질 블로그" /></a>
            
        
        
            <!-- 여기서 navigation 에 표시할 이이템 추가 -->
<ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <li class="nav-about" role="menuitem"><a href="/about/">About</a></li>
    <li class="nav-getting-started" role="menuitem"><a href="/tag/ios/">iOS</a></li>
    <li class="nav-getting-started" role="menuitem"><a href="/tag/watchos/">watchOS</a></li>
    <li class="nav-getting-started" role="menuitem"><a href="/tag/rxswift/">RxSwift</a></li>
    <li class="nav-getting-started" role="menuitem"><a href="/tag/swiftui/">swiftui</a></li>
    <li class="nav-getting-started" role="menuitem"><a href="/tag/project/">project</a></li>
    <li class="nav-getting-started" role="menuitem"><a href="/tag/ml/">ML</a></li>
    <li class="nav-getting-started" role="menuitem"><a href="/tag/cs/">CS</a></li>
    <li class="nav-getting-started" role="menuitem"><a href="/tag/flutter/">flutter</a></li>
    <li class="nav-try-ghost" role="menuitem"><a href="https://github.com/Leejigun">github</a></li>
    <li class="nav-try-ghost" role="menuitem"><a href="https://leejigun.notion.site/d96873c479d049cbb3f2476aa7990347?v=84936e8007664a6daaa211463819028d">notion</a></li>
    <li class="nav-try-ghost" role="menuitem"><a href="/search.html">Search</a></li>
</ul>

        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full post tag-getting-started no-image">

            <header class="post-full-header">
                <section class="post-full-meta">
                    <time class="post-full-meta-date" datetime=" 5 June 2025"> 5 June 2025</time>
                    
                        <span class="date-divider">/</span>
                        
                            
                               <a href='/tag/uncategorized/'>UNCATEGORIZED</a>
                            
                        
                    
                </section>
                <h1 class="post-full-title">Thinking in SwiftUI - 3장 Layout</h1>
            </header>

            

            <section class="post-full-content">
                <div class="kg-card-markdown">
                    <h3 id="text">Text</h3>

<p>기본적으로 Text 뷰는 제안된 크기에 맞게 조정됩니다. 텍스트는 이 작업을 수행하기 위해 다음 순서로 여러 전략을 사용합니다: 텍스트를 여러 줄로 나누기(단어 줄 바꿈), 단어를 나누기(줄 바꿈), 자르기, 마지막으로 텍스트를 조정하기.</p>

<p>텍스트는 항상 콘텐츠를 렌더링하는데 필요한 정확한 크기를 반환합니다. 이 크기는 제안된 너비보다 작거나 같고 최소한 한 줄의 높이입니다(0 제안 제외). 즉, 텍스트는 0부터 콘텐츠 전체를 렌더링하는데 필요한 크기까지 임의의 너비를 가질 수 있습니다.</p>

<p>다음은 Text(“Hello, World!”)가 제안된 크기에 따라 어떻게 렌더링되는지에 대한 몇 가지 예입니다. 점선 사각형은 제안된 크기를 나타내고, 실선 사각형은 반환된 크기를 나타냅니다.</p>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 2.png" alt="Untitled" /></p>

<p>→ <code class="language-plaintext highlighter-rouge">.lineLimit(_ number:)</code>를 사용하면 제안된 수직 공간에 관계없이 렌더링할 최대 라인 수를 지정할 수 있습니다. nil을 지정하면 줄 제한이 없음을 의미합니다.</p>

<p>→ <code class="language-plaintext highlighter-rouge">.lineLimit(_limit:reservesSpace:)</code>를 사용하면 렌더링할 최대 줄 수를 지정하고, 비어 있는지 여부에 관계없이 보고된 크기에 이러한 줄의 공간을 항상 포함하는 옵션을 제공합니다.</p>

<p>→ <code class="language-plaintext highlighter-rouge">.truncationMode(_ mode:)</code>를 사용하면 잘림을 적용할 위치를 지정할 수 있습니다.</p>

<p>→ <code class="language-plaintext highlighter-rouge">.minimumScaleFactor(_ Factor:)</code>를 사용하면 제안된 크기에 맞도록 글꼴 크기를 축소할 수 있는 텍스트의 양을 지정할 수 있습니다.</p>

<p>만약, fixedSize()를 Text에 적용시키면, 제안과 다른 결과를 보여준다.</p>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 3.png" alt="Untitled" /></p>

<h3 id="shapes"><strong>Shapes</strong></h3>

<p>대부분의 기본 제공 모양(<strong>Rectangle</strong>, <strong>RoundedRectangle</strong>, <strong>Capsule</strong> 및 <strong>Ellipse</strong>)은 0부터 무한대까지 제안된 크기를 수용하고 사용 가능한 공간을 채웁 니다. <strong>원은 예외입니다.</strong> 제안된 크기에 맞춰지고 원의 실제 크기를 다시 보고합니다. 모양에 nil을 제안하는 경우(즉, .fixedSize로 래핑하는 경우) 기본 크기는 10 10입니다.</p>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 4.png" alt="Untitled" /></p>

<h2 id="colors"><strong>Colors</strong></h2>

<p><code class="language-plaintext highlighter-rouge">Color.red</code>와 같이 색상을 뷰로 직접 사용하는 경우, 레이아웃 관점에서는 <code class="language-plaintext highlighter-rouge">Rectangle().fill(⋯)</code>처럼 동작합니다.</p>

<p>그러나 특별한 경우가 있습니다. ignoresSafeAreaEdges에 색상을 넣으면, 해당 색상이 마법처럼 ignoresSafeAreaEdges으로 확장됩니다. 이 동작은 레이아웃에 영향을 주지 않지만, 우리 모두가 어느 시점에서 이 문제를 겪게 될 것이므로, 이를 언급하고자 했습니다. 이를 방지하기 위해서는, .background에서 ignoresSafeAreaEdges 매개변수를 사용하거나, Color 대신 Rectangle().fill(⋯)을 사용할 수 있습니다.</p>

<h3 id="image"><strong>Image</strong></h3>

<p>기본적으로 이미지 보기는 정적 값, 즉 기본 이미지의 크기를 보고합니다. 이미지에 대해 <code class="language-plaintext highlighter-rouge">.resizeable()</code>을 호출하면 보기가 완전히 유연해집니다. 그런 다음 이미지는 제안된 크기를 수락하고 이를 다시 보고하며 이미지를 해당 크기로 압축합니다. 실제로 크기 조 정이 가능한 거의 모든 이미지는 다음과 결합됩니다.</p>

<p>이미지가 왜곡되는 것을 방지하기 위한 <code class="language-plaintext highlighter-rouge">.aspectRatio(contentMode:)</code> 또는 <code class="language-plaintext highlighter-rouge">.scaleToFit()</code> modifier를 사용합니다.</p>

<h3 id="divider"><strong>Divider</strong></h3>

<p>구분선이 수평 스택 외부에서 사용되는 경우 제안된 너비를 수락하고 구분선의 높이를 보고합니다. 수평 스택 내에서 구분 선은 제안된 높이를 승인하고 구분선의 너비를 보고합니다. <strong>nil을 제안하면 상황에 따라 가변 축의 기본 크기가 10이 됩 니다.</strong></p>

<h3 id="spacer"><strong>Spacer</strong></h3>

<p>수평 또는 수직 스택 외부에서 Spacer는 <strong>최소 길이부터 무한대까지 제안된 크기를 허용</strong>합니다.</p>

<p>수직 스택 내에서 Spacer는 최소 길이에서 무한대까지의 높이를 허용하지만 <strong>너비 는 0으로 보고됩니다.</strong></p>

<p>스페이서의 최소 길이는 minLength를 사용하여 길이를 지정하지 않는 한 기본 패딩의 길이입니다.</p>

<h2 id="modifier-view">Modifier View</h2>

<hr />

<p>ViewModifier는 항상 다른 레이어 내부에 기존 뷰를 래핑합니다. <strong>수정자는 적용된 뷰의 상위가 됩니다.</strong> SwiftUI에는 ViewModifier 프로토콜을 준수하는 값을 적용하기 위한 .modifier API가 있지만 SwiftUI의 내장 수정자는 모두 View의 확장으로 노출됩니다(이는 자체 뷰 수정자에도 좋은 방법입니다). 이 섹션에서는 레이아웃에 영향을 미치는 뷰 수정자를 설명합니다.</p>

<h3 id="frame">Frame</h3>

<ul>
  <li>고정값 지정</li>
  <li>유연하게 지정
    <ul>
      <li>유연하게 frame 값을 설정한 경우 2번 범위를 정하게 됩니다.</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 5.png" alt="Untitled" /></p>

<p>만약 다음과 같이 설정한 경우 320 480 화면에서 렌더링될 때</p>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 6.png" alt="Untitled" /></p>

<ol>
  <li>
    <p>시스템은 패딩을 320, 480으로 제안합니다.</p>
  </li>
  <li>
    <p>패딩은 배경에 300 460을 제안합니다.</p>
  </li>
  <li>
    <p>배경은 기본 하위 뷰에 동일한 300 460을 제안합니다. (frame).</p>
  </li>
</ol>

<ul>
  <li>일단 가능한 최대값을 제안</li>
</ul>

<ol>
  <li>
    <p>프레임은 하위 뷰(텍스트)에 동일한 300 460을 제안합니다.</p>
  </li>
  <li>
    <p>텍스트에서는 크기가 76 17이라고 보고합니다.</p>
  </li>
  <li>
    <p>프레임의 너비는 max(0, min( .infinity, 300)) = 300이 됩니다.</p>
  </li>
</ol>

<ul>
  <li>0 및 .infinity 값은 유연한 프레임에 대해 지정된 인수입니다.</li>
</ul>

<ol>
  <li>
    <p>배경은 유연한 프레임의 크기(300 17)를 제안합니다.</p>
  </li>
  <li>
    <p>색상은 제안된 크기를 수락하고 보고합니다. (300 17)</p>
  </li>
  <li>
    <p>배경은 기본 하위 뷰의 크기(300 17)를 보고합니다.</p>
  </li>
  <li>
    <p>패딩은 각 측면에 10포인트를 추가하고 크기를 320 37로 보고합니다.</p>
  </li>
</ol>

<h2 id="aspectratio">AspectRatio</h2>

<p>AspectRatio 유연한 frame 사이즈로 작업할 때 유용하게 사용할 수 있습니다. 예를 들어 아래 코드는 4:3 인 직사각형을 그릴 수 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Color</span><span class="o">.</span><span class="n">secondary</span>
	<span class="o">.</span><span class="nf">aspectRatio</span><span class="p">(</span><span class="mi">4</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="nv">contentMode</span><span class="p">:</span> <span class="o">.</span><span class="n">fit</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 7.png" alt="Untitled" /></p>

<p>aspectRatio의 일반적으로 이미지에 사용합니다. 이미지에 .resizable() 을 붙이면 사이즈에 맞게 이미지가 늘어나거나 줄어드는데, 이미지가 깨지지 않도록 aspectRatio 를 사용해 화면 사이즈에 맞춰 이미지 사이즈를 조절할 수 있습니다.</p>

<p><strong>만약, 비율을 적용하지 않은 경우 어떻게 될까?</strong></p>

<p>aspectRatio modifier는 하위 뷰의 이상적인 크기를 제안을 통해 조사하고, 비율을 적용합니다.</p>

<p>만약, 이미지를 사용했을 때 이미지의 사이즈가 100:30 이라고 가정하고, 전체 사이즈가 200:200 이면, 아래와 같은 절차를 따라 사이즈를 설정합니다.</p>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 8.png" alt="Untitled" /></p>

<ol>
  <li>
    <p>AspectRatio의 크기는 200x200으로 제안을 내려보냅니다.</p>
  </li>
  <li>
    <p>AspectRatio는 이미지에 nil x nil로 제안합니다.(사이즈 제한 없이)</p>
  </li>
  <li>
    <p>이미지의 이상적인 크기는 100x30으로 제안을 올려보냅니다.</p>
  </li>
  <li>
    <p>가로 세로 비율이 100/30인 직사각형을 200 200에 맞춥니다.</p>
  </li>
</ol>

<ul>
  <li>200 60이며 이 크기를 이미지에 제안합니다.</li>
</ul>

<ol>
  <li>이미지의 크기는 200 60으로 보고됩니다.</li>
  <li>AspectRatio는 하위 뷰의 크기인 200 60을 자체 크기로 보고합니다.</li>
</ol>

<blockquote>
  <p>AspectRatio를 적용한다고 반드시 비율에 맞게 조정되는건 아닙니다. 하위뷰가 유연하지 않을 경우 적용되지 않을 수 있습니다.</p>

</blockquote>

<h3 id="overlay-and-background"><strong>Overlay and Background</strong></h3>

<p>Overlay와 Background는 SwiftUI에서 가장 유용한 수정자 중 하나입니다. 레이아웃 측면에서는 정확히 동일한 방식으로 작동합니다. 유일한 차이점은 Overlay는 기본 View 위에 보조 View를 그리는 반면, Background는 기본 View 뒤에 보조 View를 그리는 것입니다. 예를 들어, 일부 텍스트 뒤에 배경을 그리려면 다음과 같이 할 수 있습니다.</p>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 9.png" alt="Untitled" /></p>

<p>Background와 overlay는 기본 하위 View의 레이아웃에 영향을 미치지 않습니다. 보고된 overlay 또는 background의 크기는 항상 기본 하위 View의 보고된 크기입니다.</p>

<h2 id="container-view">Container View</h2>

<hr />

<p>HStack과 VStack은 단순해보이지만, 결과를 파악하는데 복잡할 수 있다.</p>

<p>만약 아래와 같이 사이즈를 지정하지 않은 경우 제안된 크기에 따라서 다른 결과가 나온다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">HStack</span><span class="p">(</span><span class="nv">spacing</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> 
	<span class="kt">Color</span><span class="o">.</span><span class="n">cyan</span> 
	<span class="kt">Text</span><span class="p">(</span><span class="s">"Hello, World!"</span><span class="p">)</span> 
	<span class="kt">Color</span><span class="o">.</span><span class="n">teal</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 10.png" alt="Untitled" /></p>

<ol>
  <li>큰 크기를 제공한 케이스 (150x50)
    <ol>
      <li>모두 충분한 크기를 제공받았지만, Text의 경우에는 텍스트가 들어간 경우의 사이즈가 이상적인 상한선 크기로 잡을 수 있다.</li>
      <li>그에 비해서 Color는 유연하기 때문에 채울 수 있는 만큼 Text를 채우고 남은 공간을 Color가 나눠 가지게 된다.</li>
    </ol>
  </li>
  <li>작은 크기를 제공한 케이스 (100x50)
    <ol>
      <li>3개 모두 표현하기에 충분하지 않은 사이즈가 나온 경우 3등분하게 된다. 필요에 따라서 텍스트가 줄바꿈되거나 잘리게 된다.</li>
    </ol>
  </li>
  <li>만약 극단적으로 작은 사이즈를 준다면 (40x40)
    <ol>
      <li>이 경우 사이즈를 설정할 수 없기 때문에, Text가 Container의 제안을 무시하고 이상적인 사이즈로 표시해버립니다.</li>
      <li>
        <p>대안은 .layoutPriority modifier를 적용해 내부 View 사이에 우선순위를 제공하는 것 입니다.</p>

        <p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 11.png" alt="Untitled" /></p>
      </li>
    </ol>
  </li>
</ol>

<h3 id="zstack">ZStack</h3>

<p>ZStack은 얼핏보면 overlay나 background와 동일한 역할을 할 것 같지만, overlay와 background는 ViewModifier기 때문에 하위뷰의 사이즈에 영향을 받는다. 그에 비해서 ZStack은 컨테이너기 때문에 내부의 View의 크기와 상관없이 Size를 잡게된다.</p>

<p>만약, 아래 코드를 root 에서 실행하게되면, 화면 전체를 다 가리게 된다.</p>

<h3 id="scrollview">ScrollView</h3>

<p>제안된 화면을 가득 채우게 되고, 내부 View는 contents의 사이즈에 맞춰진다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">ScrollView</span> <span class="p">{</span> 
	<span class="kt">Image</span><span class="p">(</span><span class="s">"logo"</span><span class="p">)</span>
		<span class="o">.</span><span class="nf">resizable</span><span class="p">()</span>
		<span class="o">.</span><span class="nf">aspectRatio</span><span class="p">(</span><span class="o">.</span><span class="n">fit</span><span class="p">)</span> 
	<span class="kt">Text</span><span class="p">(</span><span class="s">"This is a longer text"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>scrollView에 Shape 의 서브 뷰를 넣으면 10x10으로 표시되는 것을 볼 수 있다. 이는 Shape의 ProposedView의 기본값이 10, 10 이기 때문이다.</p>

</blockquote>

<h3 id="geometryreader"><strong>GeometryReader</strong></h3>

<p>제안받은 크기에 접근하는데 사용합니다. GeometryProxy 를 통해 제안받은 크기에 접근 할 수 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">GeometryReader</span> <span class="p">{</span> <span class="n">proxy</span> <span class="k">in</span> 
	<span class="kt">Text</span><span class="p">(</span><span class="nv">verbatim</span><span class="p">:</span> <span class="s">"</span><span class="se">\(</span><span class="n">proxy</span><span class="o">.</span><span class="n">size</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>그러나 스택 오버플로우나 다른 사이트를 볼 때 GeometryReader에서 이슈가 생겨 고통받는 경우가 많습니다. 예를 들어서 GeometryReader 를 주위에 배치하고, Text의 사이즈를 측정하려고 하는 경우 Text 주변의 레이아웃이 잘못 나오는 경우가 많이 보고됩니다.</p>

<p>GeometryReader는 꼭 필요한 경우에만 써야 하고, 다음과 같은 경우에 유용하게 사용할 수 있습니다.</p>

<ul>
  <li>GeometryReader 내부에 유연한 View를 넣는 경우 레이아웃 사이즈를 체크할 수 있습니다.
    <ul>
      <li>예를 들어서 ScrollView 안에 GeometryReader를 넣는 경우 ScrollView의 내부 View 사이즈를 알 수 있습니다.</li>
    </ul>
  </li>
  <li>background나 overlay 안에 GeometryReader를 넣으면 기본 View 크기에는 영향을 미치지 않지만 관련된 다양한 값을 읽을 수 있습니다. (고급 레이아웃 장에서 더 자세한 예를 살펴보겠습니다.)</li>
</ul>

<h3 id="list">List</h3>

<hr />

<p>List는 UIkit에서 UITableView와 동일합니다. List 자체는 제안받은 크기를 가지며, ScrollView와 유사하게 View 자체는 너비와 높이를 제안하지 않습니다.</p>

<p>행의 높이가 고정되지 않은 UITableView와 비슷하고 내부에 배치된 항목을 기준으로 내부 View의 높이를 추정합니다.</p>

<h3 id="lazyhstack-lazyvstack">LazyHStack, LazyVStack</h3>

<p>List와 동일하게 View가 보여질 때 업데이트 한다.</p>

<h3 id="lazyvgrid-lazyhgrid">LazyVGrid, LazyHGrid</h3>

<p>LazyVGrid와 LazyHGrid는 모두 동일한 기본 알고리즘을 사용하여 열이나 행의 크기를 계산하므로 이 섹션 에서는 LazyVGrid에 중점을 둘 것입니다.</p>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 12.png" alt="Untitled" /></p>

<p>그리드는 iOS 16에서 추가되었고, 17 이상에서도 아직 버그가 많기 때문에 짧게 다루고 넘어간다.</p>

<p>(가급적 쓰지 말것)</p>

<h3 id="viewthatfits"><strong>ViewThatFits</strong></h3>

<p>제안된 크기에 따라 다른 보기를 표시하려면 ViewThatFits를 사용하면 됩니다. 여러 개의 하위 뷰가 필요한 경우, 제안된 크기에 맞는 첫 번째 하위 뷰를 표시합니다. 이는 각 하위 뷰의 이상적인 크기를 파악하기 위해 nil을 제안하고, 이상적인 크기가 제안된 크기 내에 맞는 첫 번째 하위 뷰(코드에 하위 뷰가 나타나는 순서대로)를 표시합니다. 적합한 하위 뷰가 없으면 마지막 하위 뷰를 선택합니다.</p>

<h3 id="rendering-modiers"><strong>Rendering Modi!ers</strong></h3>

<p>SwiftUI에는 offset, RotationEffect, scaleEffect 등과 같이 뷰의 렌더링 방식에는 영향을 주지만 레이아웃 자체에는 영향을 미치지 않는 여러 뷰 수정자가 있습니다. 이러한 수정자는 CGContext.translate와 같은 작업을 수행한다고 생각할 수 있습니다. 이는 뷰가 그려지는 위치를 변경하지만, 레이아웃 시스템에서 보면 뷰는 여전히 원래 위치에 있습니다.</p>

<h2 id="alignment"><strong>Alignment</strong></h2>

<p>기본적으로 거의 모든 뷰는 하위 뷰의 중앙에 배치됩니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Text</span><span class="p">(</span><span class="s">"Hello"</span><span class="p">)</span>
	<span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">width</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="nv">height</span><span class="p">:</span> <span class="mi">100</span><span class="p">)</span> <span class="c1">// 기본값이 .center</span>
</code></pre></div></div>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 13.png" alt="Untitled" /></p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Text</span><span class="p">(</span><span class="s">"Hello"</span><span class="p">)</span>
	<span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">width</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="nv">height</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="nv">alignment</span><span class="p">:</span> <span class="o">.</span><span class="n">bottomTrailing</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 14.png" alt="Untitled" /></p>

<p>정렬 가이드</p>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 15.png" alt="Untitled" /></p>

<p>ZStack 역시 기본값은 .center라 아래의 경우 가운데에 쌓이게 된다.</p>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 16.png" alt="Untitled" /></p>

<h3 id="정렬-가이드-수정">정렬 가이드 수정</h3>

<p>center, bottom같은 기본 정렬 가이드라인을 수정할 수 있다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">image</span> <span class="o">=</span> <span class="kt">Image</span><span class="p">(</span><span class="nv">systemName</span><span class="p">:</span> <span class="s">"pencil.circle.!ll"</span><span class="p">)</span> 
	<span class="o">.</span><span class="nf">alignmentGuide</span><span class="p">(</span><span class="o">.</span><span class="n">firstTextBaseline</span><span class="p">,</span> <span class="nv">computeValue</span><span class="p">:</span> <span class="p">{</span> <span class="n">dimension</span> <span class="k">in</span>
		<span class="n">dimension</span><span class="o">.</span><span class="n">height</span><span class="o">/</span><span class="mi">2</span> 
	<span class="p">}</span>
<span class="p">)</span>
</code></pre></div></div>

<p>image의 .firstTextBaseline을 줄여서 Image 가 firstTextBaseline으로 정렬했더니 아래로 밀리게 된다.</p>

<p>이렇게 수정한 이미지를 적용하면 다음과 같이 가이드라인이 변경된다.</p>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 17.png" alt="Untitled" /></p>

<p>하지만 firstTextBaseline 을 수정했기 때문에 center로 설정하면 바뀌는게 없다.</p>

<p>이를 사용해 다음과 같이 범용적으로 적용 가능한 뱃지 아이콘을 만들수도 있다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="n">badge</span><span class="o">&lt;</span><span class="kt">B</span><span class="p">:</span> <span class="kt">View</span><span class="o">&gt;</span><span class="p">(</span><span class="kd">@ViewBuilder</span> <span class="n">_</span> <span class="nv">badge</span><span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">B</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="nf">overlay</span><span class="p">(</span><span class="nv">alignment</span><span class="p">:</span> <span class="o">.</span><span class="n">topTrailing</span><span class="p">)</span> <span class="p">{</span> <span class="nf">badge</span><span class="p">()</span>
                <span class="o">.</span><span class="nf">alignmentGuide</span><span class="p">(</span><span class="o">.</span><span class="n">top</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">height</span><span class="o">/</span><span class="mi">2</span> <span class="p">}</span>
		            <span class="o">.</span><span class="nf">alignmentGuide</span><span class="p">(</span><span class="o">.</span><span class="n">trailing</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span> <span class="p">}</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 18.png" alt="Untitled" /></p>

                </div>
            </section>

            <!-- Email subscribe form at the bottom of the page -->
            

            <footer class="post-full-footer">
                <!-- Everything inside the #author tags pulls data from the author -->
                <!-- #author-->
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                <!-- /author  -->
            </footer>

            <!-- If you use Disqus comments, just uncomment this block.
            The only thing you need to change is "test-apkdzgmqhj" - which
            should be replaced with your own Disqus site-id. -->
            
                <section class="post-full-comments">
                    <div id="disqus_thread"></div>
                    <script>
                        var disqus_config = function () {
                            this.page.url = 'http://localhost:4001/';
                            this.page.identifier = 'iOS 삽질 블로그';
                        };
                        (function() {
                            var d = document, s = d.createElement('script');
                            s.src = 'https://jglee.disqus.com/embed.js';
                            s.setAttribute('data-timestamp', +new Date());
                            (d.head || d.body).appendChild(s);
                        })();
                    </script>
                </section>
            

        </article>

    </div>
</main>

<!-- Links to Previous/Next posts -->
<aside class="read-next outer">
    <div class="inner">
        <div class="read-next-feed">
            
                
                
                
                
            

            <!-- If there's a next post, display it using the same markup included from - partials/post-card.hbs -->
            
                
    <article class="post-card post-template">
        
            <a class="post-card-image-link" href="/WWDC25-Swift-62-%EB%8F%99%EC%8B%9C%EC%84%B1-%EA%B0%9C%EC%84%A0">
                <div class="post-card-image" style="background-image: url(/assets/images/ios/2025-06-14-WWDC25-Swift-62-동시성-개선/image.png)"></div>
            </a>
        
        <div class="post-card-content">
            <a class="post-card-content-link" href="/WWDC25-Swift-62-%EB%8F%99%EC%8B%9C%EC%84%B1-%EA%B0%9C%EC%84%A0">
                <header class="post-card-header">
                    
                        
                            
                                <span class="post-card-tags">Ios</span>
                            
                        
                    

                    <h2 class="post-card-title">[WWDC25] Swift 6.2 동시성 개선</h2>
                </header>
                <section class="post-card-excerpt">
                    <p>### 왜 동시성이 어려웠을까요? 이전 Swift 6에서는 언어가 특정 작업을 개발자의 명시적 지시 없이 **백그라운드 스레드나 다른 액터로 암시적으로 전환(오프로드)**하는 경향이 있었습니다. 이 때문에 개발자가 의도하지 않더라도 **데이터 경쟁(data race)**에 취약한 코드가 컴파일러</p>
                </section>
            </a>
            <footer class="post-card-meta">
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </footer>
        </div>
    </article>

            

            <!-- If there's a previous post, display it using the same markup included from - partials/post-card.hbs -->
            
                
    <article class="post-card post-template no-image">
        
        <div class="post-card-content">
            <a class="post-card-content-link" href="/Thinking-in-SwiftUI-2%EC%9E%A5-State-and-Binding">
                <header class="post-card-header">
                    
                        
                            
                               <span class="post-card-tags">Swiftui</span>
                            
                        
                            
                                <span class="post-card-tags">Ios</span>
                            
                        
                    

                    <h2 class="post-card-title">Thinking in SwiftUI - 2장 State and Binding</h2>
                </header>
                <section class="post-card-excerpt">
                    <p>https://wlaxhrl.tistory.com/91 (Data Flow Through SwiftUI) (여기서 중요한건 SSOT !!) @State 뷰의 상태를 관리하기 위한 프로퍼티 래퍼. Value Type 뷰의 로컬 데이터 (내부 프로퍼티) 뷰에서 소유되고 관리되어야 하는 데이터 (ex. 텍스트필드, 토글버튼 등) Counter</p>
                </section>
            </a>
            <footer class="post-card-meta">
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </footer>
        </div>
    </article>

            

        </div>
    </div>
</aside>

<!-- Floating header which appears on-scroll, included from includes/floating-header.hbs -->
<div class="floating-header">
    <div class="floating-header-logo">
        <a href="http://localhost:4001/">
            
                <img src="/assets/images/blog-icon.png" alt="iOS 삽질 블로그 icon" />
            
            <span>iOS 삽질 블로그</span>
        </a>
    </div>
    <span class="floating-header-divider">&mdash;</span>
    <div class="floating-header-title">Thinking in SwiftUI - 3장 Layout</div>
    <div class="floating-header-share">
        <div class="floating-header-share-label">Share this <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
    <path d="M7.5 15.5V4a1.5 1.5 0 1 1 3 0v4.5h2a1 1 0 0 1 1 1h2a1 1 0 0 1 1 1H18a1.5 1.5 0 0 1 1.5 1.5v3.099c0 .929-.13 1.854-.385 2.748L17.5 23.5h-9c-1.5-2-5.417-8.673-5.417-8.673a1.2 1.2 0 0 1 1.76-1.605L7.5 15.5zm6-6v2m-3-3.5v3.5m6-1v2"/>
</svg>
</div>
        <a class="floating-header-share-tw" href="https://twitter.com/share?text=Thinking+in+SwiftUI+-+3%EC%9E%A5+Layout&amp;url=https://leejigun.github.io/Thinking-in-SwiftUI-3%EC%9E%A5-Layout"
            onclick="window.open(this.href, 'share-twitter', 'width=550,height=235');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M30.063 7.313c-.813 1.125-1.75 2.125-2.875 2.938v.75c0 1.563-.188 3.125-.688 4.625a15.088 15.088 0 0 1-2.063 4.438c-.875 1.438-2 2.688-3.25 3.813a15.015 15.015 0 0 1-4.625 2.563c-1.813.688-3.75 1-5.75 1-3.25 0-6.188-.875-8.875-2.625.438.063.875.125 1.375.125 2.688 0 5.063-.875 7.188-2.5-1.25 0-2.375-.375-3.375-1.125s-1.688-1.688-2.063-2.875c.438.063.813.125 1.125.125.5 0 1-.063 1.5-.25-1.313-.25-2.438-.938-3.313-1.938a5.673 5.673 0 0 1-1.313-3.688v-.063c.813.438 1.688.688 2.625.688a5.228 5.228 0 0 1-1.875-2c-.5-.875-.688-1.813-.688-2.75 0-1.063.25-2.063.75-2.938 1.438 1.75 3.188 3.188 5.25 4.25s4.313 1.688 6.688 1.813a5.579 5.579 0 0 1 1.5-5.438c1.125-1.125 2.5-1.688 4.125-1.688s3.063.625 4.188 1.813a11.48 11.48 0 0 0 3.688-1.375c-.438 1.375-1.313 2.438-2.563 3.188 1.125-.125 2.188-.438 3.313-.875z"/></svg>

        </a>
        <a class="floating-header-share-fb" href="https://www.facebook.com/sharer/sharer.php?u=https://leejigun.github.io/Thinking-in-SwiftUI-3%EC%9E%A5-Layout"
            onclick="window.open(this.href, 'share-facebook','width=580,height=296');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M19 6h5V0h-5c-3.86 0-7 3.14-7 7v3H8v6h4v16h6V16h5l1-6h-6V7c0-.542.458-1 1-1z"/></svg>

        </a>
    </div>
    <progress class="progress" value="0">
        <div class="progress-container">
            <span class="progress-bar"></span>
        </div>
    </progress>
</div>


<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->


        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="http://localhost:4001/">iOS 삽질 블로그</a> &copy; 2025</section>
                <section class="poweredby">Github page blog of <a href="https://github.com/Leejigun">Leejigun</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyller/jasper2" target="_blank" rel="noopener">Jasper2</a></section>
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    
                    
                    <!-- <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a> -->
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    

    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-154736789-1', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>

// NOTE: Scroll performance is poor in Safari
// - this appears to be due to the events firing much more slowly in Safari.
//   Dropping the scroll event and using only a raf loop results in smoother
//   scrolling but continuous processing even when not scrolling
$(document).ready(function () {
    // Start fitVids
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
    // End fitVids

    var progressBar = document.querySelector('progress');
    var header = document.querySelector('.floating-header');
    var title = document.querySelector('.post-full-title');

    var lastScrollY = window.scrollY;
    var lastWindowHeight = window.innerHeight;
    var lastDocumentHeight = $(document).height();
    var ticking = false;

    function onScroll() {
        lastScrollY = window.scrollY;
        requestTick();
    }

    function onResize() {
        lastWindowHeight = window.innerHeight;
        lastDocumentHeight = $(document).height();
        requestTick();
    }

    function requestTick() {
        if (!ticking) {
            requestAnimationFrame(update);
        }
        ticking = true;
    }

    function update() {
        var trigger = title.getBoundingClientRect().top + window.scrollY;
        var triggerOffset = title.offsetHeight + 35;
        var progressMax = lastDocumentHeight - lastWindowHeight;

        // show/hide floating header
        if (lastScrollY >= trigger + triggerOffset) {
            header.classList.add('floating-active');
        } else {
            header.classList.remove('floating-active');
        }

        progressBar.setAttribute('max', progressMax);
        progressBar.setAttribute('value', lastScrollY);

        ticking = false;
    }

    window.addEventListener('scroll', onScroll, {passive: true});
    window.addEventListener('resize', onResize, false);

    update();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
