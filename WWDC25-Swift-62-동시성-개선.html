<!-- footer도 여기에 있음 -->


<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- iOS-tip 이라고 태그를 만들었으면 post에서는 iOS tip 이라고 태그를 줘야한다. -->
<!-- dynamically fixing the title for tag/author pages -->



    <title>[WWDC25] Swift 6.2 동시성 개선</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />
    <!-- highlight.js -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="iOS developer." />
    <link rel="shortcut icon" href="http://localhost:4001/assets/images/blog-icon.png" type="image/png" />
    <link rel="canonical" href="http://localhost:4001/WWDC25-Swift-62-%EB%8F%99%EC%8B%9C%EC%84%B1-%EA%B0%9C%EC%84%A0" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="iOS 삽질 블로그" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="[WWDC25] Swift 6.2 동시성 개선" />
    <meta property="og:description" content="왜 동시성이 어려웠을까요? 이전 Swift 6에서는 언어가 특정 작업을 개발자의 명시적 지시 없이 백그라운드 스레드나 다른 액터로 암시적으로 전환(오프로드)하는 경향이 있었습니다. 이 때문에 개발자가 의도하지 않더라도 데이터 경쟁(data race)에 취약한 코드가 컴파일러 오류를 유발할 수 있었죠. 동시성 프로그래밍은 여러 작업이 메모리를 공유하기 때문에 실수에 취약하며, 예상치 못한 결과로 이어질 수" />
    <meta property="og:url" content="http://localhost:4001/WWDC25-Swift-62-%EB%8F%99%EC%8B%9C%EC%84%B1-%EA%B0%9C%EC%84%A0" />
    <meta property="og:image" content="http://localhost:4001/assets/images/ios/2025-06-14-WWDC25-Swift-62-동시성-개선/image.png" />
    <meta property="article:publisher" content="https://www.facebook.com/" />
    <meta property="article:author" content="https://www.facebook.com/" />
    <meta property="article:published_time" content="2025-06-14T09:00:00+09:00" />
    <meta property="article:modified_time" content="2025-06-14T09:00:00+09:00" />
    <meta property="article:tag" content="Ios" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="[WWDC25] Swift 6.2 동시성 개선" />
    <meta name="twitter:description" content="왜 동시성이 어려웠을까요? 이전 Swift 6에서는 언어가 특정 작업을 개발자의 명시적 지시 없이 백그라운드 스레드나 다른 액터로 암시적으로 전환(오프로드)하는 경향이 있었습니다. 이 때문에 개발자가 의도하지 않더라도 데이터 경쟁(data race)에 취약한 코드가 컴파일러 오류를 유발할 수 있었죠. 동시성 프로그래밍은 여러 작업이 메모리를 공유하기 때문에 실수에 취약하며, 예상치 못한 결과로 이어질 수" />
    <meta name="twitter:url" content="http://localhost:4001/" />
    <meta name="twitter:image" content="http://localhost:4001/assets/images/ios/2025-06-14-WWDC25-Swift-62-동시성-개선/image.png" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="iOS 삽질 블로그" />
    <meta name="twitter:label2" content="Filed under" />
    <meta name="twitter:data2" content="Ios" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta property="og:image:width" content="1400" />
    <meta property="og:image:height" content="933" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "iOS 삽질 블로그",
        "logo": "http://localhost:4001/assets/images/blog-icon.png"
    },
    "url": "http://localhost:4001/WWDC25-Swift-62-%EB%8F%99%EC%8B%9C%EC%84%B1-%EA%B0%9C%EC%84%A0",
    "image": {
        "@type": "ImageObject",
        "url": "http://localhost:4001/assets/images/ios/2025-06-14-WWDC25-Swift-62-동시성-개선/image.png",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "http://localhost:4001/WWDC25-Swift-62-%EB%8F%99%EC%8B%9C%EC%84%B1-%EA%B0%9C%EC%84%A0"
    },
    "description": "왜 동시성이 어려웠을까요? 이전 Swift 6에서는 언어가 특정 작업을 개발자의 명시적 지시 없이 백그라운드 스레드나 다른 액터로 암시적으로 전환(오프로드)하는 경향이 있었습니다. 이 때문에 개발자가 의도하지 않더라도 데이터 경쟁(data race)에 취약한 코드가 컴파일러 오류를 유발할 수 있었죠. 동시성 프로그래밍은 여러 작업이 메모리를 공유하기 때문에 실수에 취약하며, 예상치 못한 결과로 이어질 수"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="[WWDC25] Swift 6.2 동시성 개선" href="/feed.xml" />


</head>
<body class="post-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->

        <!-- HTML elements for search -->

        <!-- default -->

<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<header class="site-header outer">
    <div class="inner">
        <!-- 네비게이션 바 -->
<nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="http://localhost:4001/"><img src="/assets/images/blog-icon.png" alt="iOS 삽질 블로그" /></a>
            
        
        
            <!-- 여기서 navigation 에 표시할 이이템 추가 -->
<ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <li class="nav-about" role="menuitem"><a href="/about/">About</a></li>
    <li class="nav-getting-started" role="menuitem"><a href="/tag/ios/">iOS</a></li>
    <li class="nav-getting-started" role="menuitem"><a href="/tag/watchos/">watchOS</a></li>
    <li class="nav-getting-started" role="menuitem"><a href="/tag/rxswift/">RxSwift</a></li>
    <li class="nav-getting-started" role="menuitem"><a href="/tag/swiftui/">swiftui</a></li>
    <li class="nav-getting-started" role="menuitem"><a href="/tag/project/">project</a></li>
    <li class="nav-getting-started" role="menuitem"><a href="/tag/ml/">ML</a></li>
    <li class="nav-getting-started" role="menuitem"><a href="/tag/cs/">CS</a></li>
    <li class="nav-getting-started" role="menuitem"><a href="/tag/flutter/">flutter</a></li>
    <li class="nav-try-ghost" role="menuitem"><a href="https://github.com/Leejigun">github</a></li>
    <li class="nav-try-ghost" role="menuitem"><a href="https://leejigun.notion.site/d96873c479d049cbb3f2476aa7990347?v=84936e8007664a6daaa211463819028d">notion</a></li>
    <li class="nav-try-ghost" role="menuitem"><a href="/search.html">Search</a></li>
</ul>

        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full post tag-getting-started ">

            <header class="post-full-header">
                <section class="post-full-meta">
                    <time class="post-full-meta-date" datetime="14 June 2025">14 June 2025</time>
                    
                        <span class="date-divider">/</span>
                        
                            
                               <a href='/tag/ios/'>IOS</a>
                            
                        
                    
                </section>
                <h1 class="post-full-title">[WWDC25] Swift 6.2 동시성 개선</h1>
            </header>

            
            <figure class="post-full-image" style="background-image: url(/assets/images/ios/2025-06-14-WWDC25-Swift-62-동시성-개선/image.png)">
            </figure>
            

            <section class="post-full-content">
                <div class="kg-card-markdown">
                    <h3 id="왜-동시성이-어려웠을까요">왜 동시성이 어려웠을까요?</h3>

<p>이전 Swift 6에서는 언어가 특정 작업을 개발자의 명시적 지시 없이 <strong>백그라운드 스레드나 다른 액터로 암시적으로 전환(오프로드)</strong>하는 경향이 있었습니다. 이 때문에 개발자가 의도하지 않더라도 <strong>데이터 경쟁(data race)</strong>에 취약한 코드가 컴파일러 오류를 유발할 수 있었죠. 동시성 프로그래밍은 여러 작업이 메모리를 공유하기 때문에 실수에 취약하며, 예상치 못한 결과로 이어질 수 있어 본질적으로 어렵습니다.
<em>**</em></p>

<blockquote>
  <p><strong>이전 Swift 6은 암시적인 백그라운드 오프로드로 인해 의도치 않은 데이터 경쟁이 발생하기 쉬워 동시성 코딩이 복잡했습니다.</strong></p>

</blockquote>

<hr />

<h3 id="swift-62의-새로운-동시성-접근-방식">Swift 6.2의 새로운 동시성 접근 방식</h3>

<p>Swift 6.2는 이러한 문제를 해결하기 위해 동시성에 대한 근본적인 접근 방식을 변경했습니다. 이제 개발자가 명시적으로 동시성을 도입하기로 결정할 때까지 코드가 기본적으로 <strong>단일 스레드 상태</strong>를 유지합니다. 이는 개발자가 가장 자연스럽게 작성하는 코드가 기본적으로 데이터 경쟁으로부터 자유롭도록 하여, 프로젝트에 동시성을 도입하는 더 쉬운 경로를 제공합니다. 즉, 코드를 병렬로 실행하고자 <strong>동시성을 선택적으로 도입</strong>할 경우에만 데이터 경쟁 안전이 보호됩니다.</p>

<blockquote>
  <p><strong>Swift 6.2는 명시적인 동시성 도입 전까지 코드를 기본적으로 단일 스레드 상태로 유지하여 데이터 경쟁을 사전에 방지합니다.</strong></p>

</blockquote>

<p><img src="/assets/images/ios/2025-06-14-WWDC25-Swift-62-동시성-개선/image.png" alt="image.png" /></p>

<hr />

<h3 id="핵심-동시성-개선-사항">핵심 동시성 개선 사항</h3>

<p><img src="/assets/images/ios/2025-06-14-WWDC25-Swift-62-동시성-개선/image 1.png" alt="image.png" /></p>

<h3 id="1-호출자의-액터에서-비동기-함수-실행-async-functions-run-on-the-callers-actor">1. 호출자의 액터에서 비동기 함수 실행 (Async Functions Run on the Caller’s Actor)</h3>

<p>이전 Swift 6에서는 특정 비동기 함수가 언어에 의해 암시적으로 백그라운드로 오프로드되는 경우가 많았습니다. 이로 인해 개발자가 의도하지 않았음에도 데이터 경쟁에 취약한 코드가 컴파일러 오류를 유발할 수 있었습니다.</p>

<blockquote>
  <p><strong>이전 Swift 6에서는 비동기 함수가 암시적으로 백그라운드에서 실행되어 데이터 경쟁을 유발할 수 있었습니다.</strong></p>

</blockquote>

<p>문제 상황 (Swift 6 이전):</p>

<p>예를 들어, PhotoProcessor 클래스에 extractSticker라는 비동기 메서드가 있고, 이 메서드가 MainActor에 격리된 StickerModel 클래스 내에서 호출될 때 문제가 발생할 수 있었습니다. extractSticker가 내부적으로 MainActor가 아닌 다른 스레드에서 실행되도록 암시적으로 오프로드될 경우, MainActor의 UI 코드와 공유 상태에 접근하려 할 때 데이터 경쟁 위험이 발생하여 컴파일러 오류가 발생할 수 있었습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Swift 6 (이전)</span>
<span class="c1">// 비동기 함수 호출 시 암시적 오프로드로 인한 잠재적 데이터 경쟁 오류</span>
<span class="kd">class</span> <span class="kt">PhotoProcessor</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">extractSticker</span><span class="p">(</span><span class="nv">data</span><span class="p">:</span> <span class="kt">Data</span><span class="p">,</span> <span class="n">with</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">String</span><span class="p">?)</span> <span class="k">async</span> <span class="o">-&gt;</span> <span class="kt">Sticker</span><span class="p">?</span> <span class="p">{</span>
        <span class="c1">// 이미지 처리 로직 (시간이 오래 걸릴 수 있음)</span>
        <span class="c1">// 이 함수가 MainActor에 격리되지 않아 백그라운드로 암시적 오프로드될 가능성</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">@MainActor</span> <span class="kd">final</span> <span class="kd">class</span> <span class="kt">StickerModel</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">photoProcessor</span> <span class="o">=</span> <span class="kt">PhotoProcessor</span><span class="p">()</span>

    <span class="kd">func</span> <span class="nf">extractSticker</span><span class="p">(</span><span class="n">_</span> <span class="nv">item</span><span class="p">:</span> <span class="kt">PhotosPickerItem</span><span class="p">)</span> <span class="k">async</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Sticker</span><span class="p">?</span> <span class="p">{</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">data</span> <span class="o">=</span> <span class="k">try</span> <span class="k">await</span> <span class="n">item</span><span class="o">.</span><span class="nf">loadTransferable</span><span class="p">(</span><span class="nv">type</span><span class="p">:</span> <span class="kt">Data</span><span class="o">.</span><span class="k">self</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="c1">// 여기서 photoProcessor.extractSticker 호출 시 데이터 경쟁 위험이 감지될 수 있음</span>
        <span class="k">return</span> <span class="k">await</span> <span class="n">photoProcessor</span><span class="o">.</span><span class="nf">extractSticker</span><span class="p">(</span><span class="nv">data</span><span class="p">:</span> <span class="n">data</span><span class="p">,</span> <span class="nv">with</span><span class="p">:</span> <span class="n">item</span><span class="o">.</span><span class="n">itemIdentifier</span><span class="p">)</span>
        <span class="c1">// 에러 메시지 예시: "Reference to property 'photoProcessor' in non-isolated actor-relative context cannot be used to satisfy an @MainActor requirement"</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>StickerModel.extractSticker: StickerModel 클래스가 @MainActor 로 정의하고 있기 때문에 MainActor에서 실행</li>
  <li>PhotoProcessor.extractSticker: MainActor에 격리되지 않아 백그라운드로 실행될 가능성 높음</li>
</ul>

<p>Swift 6.2의 개선:</p>

<p>Swift 6.2에서는 특정 액터에 연결되지 않은 비동기 함수(actor-isolated가 아닌 async 함수)는 이제 해당 함수가 호출된 액터에서 계속 실행됩니다. 즉, PhotoProcessor의 extractSticker와 같이 액터가 지정되지 않은 비동기 함수를 MainActor 내에서 호출하면, 해당 함수는 MainActor 컨텍스트 내에서 실행됩니다. 이는 비동기 함수에 전달된 값이 액터 외부로 전송되지 않도록 하여 데이터 경쟁을 방지합니다. 개발자는 비동기 함수가 내부적으로 작업을 오프로드하더라도 가변 상태에 대해 걱정할 필요가 없어집니다. 예를 들어, UI 업데이트 로직에서 MainActor를 잘못 타서 발생할 수 있었던 데이터 경쟁 문제를 예방할 수 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Swift 6.2</span>
<span class="c1">// 호출자의 액터에서 비동기 함수 실행</span>
<span class="kd">class</span> <span class="kt">PhotoProcessor</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">extractSticker</span><span class="p">(</span><span class="nv">data</span><span class="p">:</span> <span class="kt">Data</span><span class="p">,</span> <span class="n">with</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">String</span><span class="p">?)</span> <span class="k">async</span> <span class="o">-&gt;</span> <span class="kt">Sticker</span><span class="p">?</span> <span class="p">{</span>
        <span class="c1">// 이 함수는 여전히 MainActor에 있지 않지만,</span>
        <span class="c1">// MainActor에서 호출되면 MainActor 컨텍스트 내에서 실행됩니다.</span>
        <span class="c1">// 내부적으로 필요한 경우에만 명시적으로 다른 액터로 작업을 오프로드할 수 있습니다.</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">@MainActor</span> <span class="kd">final</span> <span class="kd">class</span> <span class="kt">StickerModel</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">photoProcessor</span> <span class="o">=</span> <span class="kt">PhotoProcessor</span><span class="p">()</span>

    <span class="kd">func</span> <span class="nf">extractSticker</span><span class="p">(</span><span class="n">_</span> <span class="nv">item</span><span class="p">:</span> <span class="kt">PhotosPickerItem</span><span class="p">)</span> <span class="k">async</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Sticker</span><span class="p">?</span> <span class="p">{</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">data</span> <span class="o">=</span> <span class="k">try</span> <span class="k">await</span> <span class="n">item</span><span class="o">.</span><span class="nf">loadTransferable</span><span class="p">(</span><span class="nv">type</span><span class="p">:</span> <span class="kt">Data</span><span class="o">.</span><span class="k">self</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="c1">// 이제 이 호출은 MainActor 컨텍스트 내에서 안전하게 이루어집니다.</span>
        <span class="k">return</span> <span class="k">await</span> <span class="n">photoProcessor</span><span class="o">.</span><span class="nf">extractSticker</span><span class="p">(</span><span class="nv">data</span><span class="p">:</span> <span class="n">data</span><span class="p">,</span> <span class="nv">with</span><span class="p">:</span> <span class="n">item</span><span class="o">.</span><span class="n">itemIdentifier</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p><strong>Swift 6.2에서는 비동기 함수가 호출된 액터에서 계속 실행되도록 변경되어, <code class="language-plaintext highlighter-rouge">MainActor</code> 내에서의 데이터 경쟁 위험을 줄였습니다.</strong></p>

</blockquote>

<h3 id="2-격리된-적합성-isolated-conformances">2. 격리된 적합성 (Isolated Conformances)</h3>

<p>Swift 6.2는 <code class="language-plaintext highlighter-rouge">MainActor</code>와 같은 액터에 격리된 유형(actor-isolated types)이 프로토콜을 준수하는 것을 더 쉽게 만들었습니다.</p>

<blockquote>
  <p><strong>Swift 6.2는 액터에 격리된 타입이 프로토콜을 더 쉽게 준수하도록 개선했습니다.</strong></p>

</blockquote>

<p>문제 상황 (Swift 6 이전):</p>

<p>MainActor에 격리된 StickerModel 클래스가 Exportable이라는 프로토콜을 준수해야 한다고 가정해 봅시다. Exportable 프로토콜은 액터 격리를 요구하지 않습니다. Swift 6에서는 컴파일러가 StickerModel의 export() 메서드가 MainActor 외부에서도 호출될 수 있다고 가정하여, MainActor 상태를 사용하는 것을 막았습니다. 이는 잠재적인 데이터 경쟁 때문입니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Swift 6 (이전)</span>
<span class="kd">protocol</span> <span class="kt">Exportable</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">export</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">StickerModel</span><span class="p">:</span> <span class="kt">Exportable</span> <span class="p">{</span>
    <span class="c1">// error: Conformance of 'StickerModel' to protocol 'Exportable' crosses into main actor-isolated code and can cause data races</span>
    <span class="c1">// StickerModel이 @MainActor로 격리되어 있기 때문에,</span>
    <span class="c1">// export() 메서드가 MainActor 외부에서 호출될 경우 데이터 경쟁이 발생할 수 있다고 컴파일러가 판단합니다.</span>
    <span class="kd">func</span> <span class="nf">export</span><span class="p">()</span> <span class="p">{</span> <span class="n">photoProcessor</span><span class="o">.</span><span class="nf">exportAsPNG</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Swift 6.2의 개선:</p>

<p>MainActor 상태를 필요로 하는 적합성은 이제 @MainActor 속성을 사용하여 <strong>‘격리된 적합성(Isolated Conformance)’</strong>으로 명시할 수 있습니다. 컴파일러는 MainActor 적합성이 MainActor 내에서만 사용되도록 보장하여 안전성을 유지합니다. 개발자는 코드가 동시적으로 적합성을 사용할 때만 데이터 경쟁 안전 문제를 해결하면 됩니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Swift 6.2</span>
<span class="kd">protocol</span> <span class="kt">Exportable</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">export</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// @MainActor 속성을 사용하여 StickerModel의 Exportable 적합성이 MainActor에 격리됨을 명시</span>
<span class="kd">extension</span> <span class="kt">StickerModel</span><span class="p">:</span> <span class="kd">@MainActor</span> <span class="kt">Exportable</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">export</span><span class="p">()</span> <span class="p">{</span> <span class="n">photoProcessor</span><span class="o">.</span><span class="nf">exportAsPNG</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// MainActor 격리된 ImageExporter 구조체 내에서 StickerModel을 사용하는 것은 안전합니다.</span>
<span class="kd">@MainActor</span> <span class="kd">struct</span> <span class="kt">ImageExporter</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">items</span><span class="p">:</span> <span class="p">[</span><span class="n">any</span> <span class="kt">Exportable</span><span class="p">]</span>

    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">add</span><span class="p">(</span><span class="n">_</span> <span class="nv">item</span><span class="p">:</span> <span class="kt">StickerModel</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">items</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">exportAll</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">item</span> <span class="k">in</span> <span class="n">items</span> <span class="p">{</span>
            <span class="n">item</span><span class="o">.</span><span class="nf">export</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 하지만 만약 ImageExporter가 nonisolated로 선언된다면, MainActor에 격리된 StickerModel의 적합성을</span>
<span class="c1">// nonisolated 컨텍스트에서 사용하려 할 때 컴파일러 오류가 발생합니다.</span>
<span class="c1">// 이는 컴파일러가 MainActor의 상태가 안전하게 유지되도록 강제하는 것입니다.</span>
<span class="kd">nonisolated</span> <span class="kd">struct</span> <span class="kt">ImageExporter</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">items</span><span class="p">:</span> <span class="p">[</span><span class="n">any</span> <span class="kt">Exportable</span><span class="p">]</span>

    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">add</span><span class="p">(</span><span class="n">_</span> <span class="nv">item</span><span class="p">:</span> <span class="kt">StickerModel</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">items</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="c1">// error: Main actor-isolated conformance of 'StickerModel' to 'Exportable' cannot be used in nonisolated context</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">exportAll</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">item</span> <span class="k">in</span> <span class="n">items</span> <span class="p">{</span>
            <span class="n">item</span><span class="o">.</span><span class="nf">export</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p><strong>이제 <code class="language-plaintext highlighter-rouge">@MainActor</code> 속성으로 프로토콜 적합성을 명시하여, <code class="language-plaintext highlighter-rouge">MainActor</code> 내에서 프로토콜을 안전하게 사용할 수 있습니다.</strong></p>

</blockquote>

<h3 id="3-기본-추론-모드-opt-in-mode-to-infer-mainactor-by-default">3. 기본 추론 모드 (Opt-in Mode to Infer MainActor by Default)</h3>

<p>이 모드는 프로젝트의 모든 가변 상태를 기본적으로 <code class="language-plaintext highlighter-rouge">MainActor</code>로 보호하여, 안전하지 않은 전역 및 정적 변수 호출과 같은 데이터 경쟁 안전 오류를 제거하는 <strong>선택적(opt-in) 기능</strong>입니다. 이는 대부분 단일 스레드인 코드에서 동시성 관련 주석을 줄이는 데 도움이 되며, 앱, 스크립트 및 기타 실행 대상에 권장됩니다.</p>

<blockquote>
  <p><strong>‘기본 추론 모드’는 프로젝트의 모든 가변 상태를 <code class="language-plaintext highlighter-rouge">MainActor</code>로 자동 보호하여 동시성 관련 주석을 줄여줍니다.</strong></p>

</blockquote>

<p>문제 상황 (Swift 6 이전):</p>

<p>전역 및 정적 변수는 어디서든 접근할 수 있는 가변 상태를 가질 수 있어 데이터 경쟁에 취약합니다. StickerLibrary.shared와 같은 정적 변수는 Sendable 타입이 아닌 경우 동시성 안전하지 않다는 경고 또는 오류를 발생시킬 수 있었습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Swift 6 (이전)</span>
<span class="c1">// 안전하지 않은 정적 변수 사용</span>
<span class="kd">final</span> <span class="kd">class</span> <span class="kt">StickerLibrary</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="k">let</span> <span class="nv">shared</span><span class="p">:</span> <span class="kt">StickerLibrary</span> <span class="o">=</span> <span class="o">.</span><span class="nf">init</span><span class="p">()</span> <span class="c1">// error: Static property 'shared' is not concurrency-safe because non-'Sendable' type 'StickerLibrary' may have shared mutable state</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Swift 6.2의 개선:</p>

<p>이 모드를 활성화하면, 기본적으로 모든 가변 상태가 MainActor로 추론되어 보호됩니다. 따라서 개발자가 PhotoProcessor와 같은 특정 유형이나 파일 내에 캡슐화된 동시성 코드를 제외하고 대부분의 코드를 단일 스레드처럼 작성하더라도, MainActor 주석을 명시적으로 추가할 필요 없이 안전한 코드를 작성할 수 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Swift 6.2 (기본 MainActor 추론 모드 활성화 시)</span>
<span class="c1">// 명시적인 @MainActor 주석 없이도 안전한 코드</span>
<span class="c1">// (프로젝트 설정에서 'Infer Main Actor by Default' 활성화 가정)</span>

<span class="kd">final</span> <span class="kd">class</span> <span class="kt">StickerLibrary</span> <span class="p">{</span>
    <span class="c1">// 이제 이 정적 변수는 자동으로 MainActor에 격리된 것으로 추론됩니다.</span>
    <span class="kd">static</span> <span class="k">let</span> <span class="nv">shared</span><span class="p">:</span> <span class="kt">StickerLibrary</span> <span class="o">=</span> <span class="o">.</span><span class="nf">init</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">final</span> <span class="kd">class</span> <span class="kt">StickerModel</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">photoProcessor</span><span class="p">:</span> <span class="kt">PhotoProcessor</span>
    <span class="k">var</span> <span class="nv">selection</span><span class="p">:</span> <span class="p">[</span><span class="kt">PhotosPickerItem</span><span class="p">]</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">StickerModel</span><span class="p">:</span> <span class="kt">Exportable</span> <span class="p">{</span>
    <span class="c1">// 이 적합성도 MainActor에 격리된 것으로 자동으로 추론됩니다.</span>
    <span class="kd">func</span> <span class="nf">export</span><span class="p">()</span> <span class="p">{</span> <span class="n">photoProcessor</span><span class="o">.</span><span class="nf">exportAsPNG</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>이 모드를 활성화하면 명시적인 <code class="language-plaintext highlighter-rouge">MainActor</code> 주석 없이도 대부분의 코드가 <code class="language-plaintext highlighter-rouge">MainActor</code>로 안전하게 보호됩니다.</strong></p>

<h3 id="4concurrent속성-the-attribute">4. <code class="language-plaintext highlighter-rouge">@concurrent</code> 속성 (The Attribute)</h3>

<p>CPU 집약적인 작업을 백그라운드로 오프로드할 때 앱의 반응성을 유지하기 위해 <strong><code class="language-plaintext highlighter-rouge">@concurrent</code> 속성</strong>이 도입되었습니다.</p>

<p><strong><code class="language-plaintext highlighter-rouge">@concurrent</code> 속성은 CPU 집약적인 작업을 백그라운드 스레드에서 실행하여 앱의 반응성을 유지하는 데 사용됩니다.</strong></p>

<p>사용 목적:</p>

<p>이 속성을 사용하면 함수가 항상 <strong>동시 스레드 풀(concurrent thread pool)</strong>에서 실행되도록 하여, 현재 액터(예: MainActor)가 다른 작업을 동시에 수행할 수 있도록 합니다. 이는 UI 스레드를 차단하지 않고 무거운 작업을 처리할 때 특히 유용합니다.</p>

<p>샘플 코드:</p>

<p>PhotoProcessor 클래스에서 이미지를 분석하여 스티커를 추출하는 extractSubject 메서드가 CPU 집약적인 작업이라고 가정해 봅시다. 이 작업을 @concurrent로 표시하면, 이 함수가 호출될 때 MainActor와 같은 호출 액터를 차단하지 않고 별도의 동시 스레드 풀에서 실행될 것임을 보장합니다. 실제 CPU 집약적인 작업에는 Core ML 모델 실행, 복잡한 이미지 필터링, 대용량 데이터 처리 등이 포함될 수 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Swift 6.2</span>
<span class="kd">class</span> <span class="kt">PhotoProcessor</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">cachedStickers</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">:</span> <span class="kt">Sticker</span><span class="p">]</span> <span class="o">=</span> <span class="p">[:]</span>

    <span class="kd">func</span> <span class="nf">extractSticker</span><span class="p">(</span><span class="nv">data</span><span class="p">:</span> <span class="kt">Data</span><span class="p">,</span> <span class="n">with</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">async</span> <span class="o">-&gt;</span> <span class="kt">Sticker</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nv">sticker</span> <span class="o">=</span> <span class="n">cachedStickers</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">sticker</span> <span class="c1">// 캐시된 스티커가 있다면 즉시 반환</span>
        <span class="p">}</span>

        <span class="c1">// extractSubject 메서드는 CPU 집약적이므로 @concurrent 속성을 사용하여 백그라운드 스레드에서 실행</span>
        <span class="k">let</span> <span class="nv">sticker</span> <span class="o">=</span> <span class="k">await</span> <span class="k">Self</span><span class="o">.</span><span class="nf">extractSubject</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="n">data</span><span class="p">)</span>
        <span class="n">cachedStickers</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">sticker</span>
        <span class="k">return</span> <span class="n">sticker</span>
    <span class="p">}</span>

    <span class="c1">// @concurrent 속성: 이 함수는 항상 동시 스레드 풀에서 실행됩니다.</span>
    <span class="kd">@concurrent</span> <span class="kd">static</span> <span class="kd">func</span> <span class="nf">extractSubject</span><span class="p">(</span><span class="n">from</span> <span class="nv">data</span><span class="p">:</span> <span class="kt">Data</span><span class="p">)</span> <span class="k">async</span> <span class="o">-&gt;</span> <span class="kt">Sticker</span> <span class="p">{</span>
        <span class="c1">// 실제 CPU 집약적인 이미지 처리 및 피사체 추출 로직</span>
        <span class="c1">// 예: Core ML 모델 실행, 복잡한 이미지 필터링 등</span>
        <span class="c1">// 이 작업은 MainActor를 차단하지 않습니다.</span>
        <span class="k">return</span> <span class="kt">Sticker</span><span class="p">()</span> <span class="c1">// 예시 반환</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p><strong><code class="language-plaintext highlighter-rouge">@concurrent</code>는 <code class="language-plaintext highlighter-rouge">MainActor</code>를 차단하지 않고 무거운 작업을 병렬 스레드에서 효율적으로 처리하도록 보장합니다.</strong></p>

</blockquote>

<hr />

<h3 id="더-쉬워진-동시성-더-강력해진-swift">더 쉬워진 동시성, 더 강력해진 Swift</h3>

<p><img src="/assets/images/ios/2025-06-14-WWDC25-Swift-62-동시성-개선/image 2.png" alt="image.png" /></p>

<p>이러한 언어 변경 사항들은 함께 작동하여 동시성을 더 쉽게 다룰 수 있도록 돕습니다. 개발자는 먼저 데이터 경쟁 위험이 없는 <strong><code class="language-plaintext highlighter-rouge">MainActor</code>에서 기본적으로 실행되는 코드를 작성</strong>하고, 필요할 때 병렬 실행을 위해 특정 코드를 안전하게 오프로드할 수 있습니다. 또한, Swift 6.2는 비동기 코드의 디버깅 경험을 크게 개선하여 LLDB가 스레드 간 전환 시에도 비동기 함수 실행을 추적하고, 작업 이름 지정 및 가시성을 제공합니다.</p>

<p>이러한 개선은 Swift 커뮤니티의 피드백을 통해 이루어졌으며, Swift가 초보자와 전문가 모두에게 더 쉽게 사용될 수 있도록 언어를 발전시키는 데 기여합니다.</p>

<blockquote>
  <p><strong>Swift 6.2의 개선 사항들은 동시성 코딩을 단순화하고 디버깅 경험을 향상시켜 Swift를 더욱 강력하게 만듭니다.</strong></p>

</blockquote>

<hr />

<h3 id="어떻게-적용할-수-있나요">어떻게 적용할 수 있나요?</h3>

<p>이러한 동시성 관련 언어 변경 사항들은 선택 사항으로 구성되었으며, Xcode 빌드 설정의 <strong>Swift 컴파일러 - 동시성 섹션</strong>에서 활성화할 수 있습니다. SwiftSettings API를 사용하여 Swift 패키지 매니페스트 파일에서도 이 기능을 활성화할 수 있습니다.</p>

<p>Xcode 빌드 설정에서 활성화:</p>

<p>Swift Compiler - Concurrency 섹션에서 “Strict Concurrency Checking”을 Complete로 설정하고 “Infer Main Actor by Default”를 활성화할 수 있습니다.</p>

<p>또한, Swift 6.2에는 필요한 코드 변경 사항을 자동으로 적용할 수 있는 <strong>마이그레이션 도구</strong>가 포함되어 있습니다. 이 도구는 주로 액터 격리 관련 경고 및 오류를 수정하고, <code class="language-plaintext highlighter-rouge">Sendable</code> 준수와 관련된 변경 사항을 제안하여 기존 코드를 새 동시성 모델에 맞게 업데이트하는 데 도움을 줍니다.</p>

<p>Swift 6.2의 동시성 개선은 개발자들이 더욱 안전하고 효율적인 애플리케이션을 만들 수 있도록 돕는 중요한 진전입니다. 지금 바로 Xcode를 업데이트하고 새로운 동시성 기능을 경험해 보세요!</p>

<blockquote>
  <p><strong>Swift 6.2 동시성 기능은 Xcode 빌드 설정이나 Swift Package Manager를 통해 활성화할 수 있으며, 기존 코드 마이그레이션 도구도 제공됩니다.</strong></p>

</blockquote>

<p><strong>참고:</strong> 이 글은 WWDC25 비디오 (“Improve memory usage and performance with Swift”, “What’s new in Swift”) 및 관련 Swift 6.2 발표 자료를 바탕으로 작성되었습니다.</p>

<hr />

                </div>
            </section>

            <!-- Email subscribe form at the bottom of the page -->
            

            <footer class="post-full-footer">
                <!-- Everything inside the #author tags pulls data from the author -->
                <!-- #author-->
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                <!-- /author  -->
            </footer>

            <!-- If you use Disqus comments, just uncomment this block.
            The only thing you need to change is "test-apkdzgmqhj" - which
            should be replaced with your own Disqus site-id. -->
            
                <section class="post-full-comments">
                    <div id="disqus_thread"></div>
                    <script>
                        var disqus_config = function () {
                            this.page.url = 'http://localhost:4001/';
                            this.page.identifier = 'iOS 삽질 블로그';
                        };
                        (function() {
                            var d = document, s = d.createElement('script');
                            s.src = 'https://jglee.disqus.com/embed.js';
                            s.setAttribute('data-timestamp', +new Date());
                            (d.head || d.body).appendChild(s);
                        })();
                    </script>
                </section>
            

        </article>

    </div>
</main>

<!-- Links to Previous/Next posts -->
<aside class="read-next outer">
    <div class="inner">
        <div class="read-next-feed">
            
                
                
                
                
                    <article class="read-next-card"
                        
                            style="background-image: url(/assets/images/blog-cover.jpg)"
                        
                    >
                        <header class="read-next-card-header">
                            <small class="read-next-card-header-sitetitle">&mdash; iOS 삽질 블로그 &mdash;</small>
                            
                                <h3 class="read-next-card-header-title"><a href="/tag/ios/">Ios</a></h3>
                            
                        </header>
                        <div class="read-next-divider"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 14.5s2 3 5 3 5.5-2.463 5.5-5.5S21 6.5 18 6.5c-5 0-7 11-12 11C2.962 17.5.5 15.037.5 12S3 6.5 6 6.5s4.5 3.5 4.5 3.5"/></svg>
</div>
                        <div class="read-next-card-content">
                            <ul>
                                
                                
                                  
                                    
                                        
                                        
                                            <li><a href="/WWDC25-Swift-62-InlineArray-iOS-%EC%95%B1-%EC%84%B1%EB%8A%A5-%EB%B0%8F-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%B5%9C%EC%A0%81%ED%99%94">[WWDC25] Swift 6.2 InlineArray: iOS 앱 성능 및 메모리 최적화</a></li>
                                        
                                    
                                  
                                
                                  
                                    
                                  
                                
                                  
                                
                                  
                                    
                                        
                                        
                                            <li><a href="/Thinking-in-SwiftUI-2%EC%9E%A5-State-and-Binding">Thinking in SwiftUI - 2장 State and Binding</a></li>
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                            <li><a href="/Thinking-in-SwiftUI-1%EC%9E%A5-View-Trees">Thinking in SwiftUI - 1장 View Trees</a></li>
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                            </ul>
                        </div>
                        <footer class="read-next-card-footer">
                            <a href="/tag/ios/">
                                
                                    See all 26 posts  →
                                
                            </a>
                        </footer>
                    </article>
                
            

            <!-- If there's a next post, display it using the same markup included from - partials/post-card.hbs -->
            
                
    <article class="post-card post-template">
        
            <a class="post-card-image-link" href="/WWDC25-Swift-62-InlineArray-iOS-%EC%95%B1-%EC%84%B1%EB%8A%A5-%EB%B0%8F-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%B5%9C%EC%A0%81%ED%99%94">
                <div class="post-card-image" style="background-image: url(/assets/images/ios/2025-06-15-WWDC25-Swift-62-InlineArray-iOS-앱-성능-및-메모리-최적화/2025-07-19_18-47-30.png)"></div>
            </a>
        
        <div class="post-card-content">
            <a class="post-card-content-link" href="/WWDC25-Swift-62-InlineArray-iOS-%EC%95%B1-%EC%84%B1%EB%8A%A5-%EB%B0%8F-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%B5%9C%EC%A0%81%ED%99%94">
                <header class="post-card-header">
                    
                        
                            
                                <span class="post-card-tags">Ios</span>
                            
                        
                    

                    <h2 class="post-card-title">[WWDC25] Swift 6.2 InlineArray: iOS 앱 성능 및 메모리 최적화</h2>
                </header>
                <section class="post-card-excerpt">
                    <p>- [https://developer.apple.com/kr/videos/play/wwdc2025/245](https://developer.apple.com/kr/videos/play/wwdc2025/245) ### Swift 앱의 성능 최적화와 InlineArray의 등장 Swift 애플리케이션 개발에서 성능 최적화, 특히 메모리 효율성은 중요한 과제입니다. 이번 WWDC25에서 Swift 6.2와 함께 소개된 **InlineArray**는 이러한 메모리 사용량 및 성능 개선을 위한 핵심</p>
                </section>
            </a>
            <footer class="post-card-meta">
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </footer>
        </div>
    </article>

            

            <!-- If there's a previous post, display it using the same markup included from - partials/post-card.hbs -->
            
                
    <article class="post-card post-template no-image">
        
        <div class="post-card-content">
            <a class="post-card-content-link" href="/Thinking-in-SwiftUI-3%EC%9E%A5-Layout">
                <header class="post-card-header">
                    
                        
                            
                                <span class="post-card-tags">Uncategorized</span>
                            
                        
                    

                    <h2 class="post-card-title">Thinking in SwiftUI - 3장 Layout</h2>
                </header>
                <section class="post-card-excerpt">
                    <p>Text 기본적으로 Text 뷰는 제안된 크기에 맞게 조정됩니다. 텍스트는 이 작업을 수행하기 위해 다음 순서로 여러 전략을 사용합니다: 텍스트를 여러 줄로 나누기(단어 줄 바꿈), 단어를 나누기(줄 바꿈), 자르기, 마지막으로 텍스트를 조정하기. 텍스트는 항상</p>
                </section>
            </a>
            <footer class="post-card-meta">
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </footer>
        </div>
    </article>

            

        </div>
    </div>
</aside>

<!-- Floating header which appears on-scroll, included from includes/floating-header.hbs -->
<div class="floating-header">
    <div class="floating-header-logo">
        <a href="http://localhost:4001/">
            
                <img src="/assets/images/blog-icon.png" alt="iOS 삽질 블로그 icon" />
            
            <span>iOS 삽질 블로그</span>
        </a>
    </div>
    <span class="floating-header-divider">&mdash;</span>
    <div class="floating-header-title">[WWDC25] Swift 6.2 동시성 개선</div>
    <div class="floating-header-share">
        <div class="floating-header-share-label">Share this <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
    <path d="M7.5 15.5V4a1.5 1.5 0 1 1 3 0v4.5h2a1 1 0 0 1 1 1h2a1 1 0 0 1 1 1H18a1.5 1.5 0 0 1 1.5 1.5v3.099c0 .929-.13 1.854-.385 2.748L17.5 23.5h-9c-1.5-2-5.417-8.673-5.417-8.673a1.2 1.2 0 0 1 1.76-1.605L7.5 15.5zm6-6v2m-3-3.5v3.5m6-1v2"/>
</svg>
</div>
        <a class="floating-header-share-tw" href="https://twitter.com/share?text=%5BWWDC25%5D+Swift+6.2+%EB%8F%99%EC%8B%9C%EC%84%B1+%EA%B0%9C%EC%84%A0&amp;url=https://leejigun.github.io/WWDC25-Swift-62-%EB%8F%99%EC%8B%9C%EC%84%B1-%EA%B0%9C%EC%84%A0"
            onclick="window.open(this.href, 'share-twitter', 'width=550,height=235');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M30.063 7.313c-.813 1.125-1.75 2.125-2.875 2.938v.75c0 1.563-.188 3.125-.688 4.625a15.088 15.088 0 0 1-2.063 4.438c-.875 1.438-2 2.688-3.25 3.813a15.015 15.015 0 0 1-4.625 2.563c-1.813.688-3.75 1-5.75 1-3.25 0-6.188-.875-8.875-2.625.438.063.875.125 1.375.125 2.688 0 5.063-.875 7.188-2.5-1.25 0-2.375-.375-3.375-1.125s-1.688-1.688-2.063-2.875c.438.063.813.125 1.125.125.5 0 1-.063 1.5-.25-1.313-.25-2.438-.938-3.313-1.938a5.673 5.673 0 0 1-1.313-3.688v-.063c.813.438 1.688.688 2.625.688a5.228 5.228 0 0 1-1.875-2c-.5-.875-.688-1.813-.688-2.75 0-1.063.25-2.063.75-2.938 1.438 1.75 3.188 3.188 5.25 4.25s4.313 1.688 6.688 1.813a5.579 5.579 0 0 1 1.5-5.438c1.125-1.125 2.5-1.688 4.125-1.688s3.063.625 4.188 1.813a11.48 11.48 0 0 0 3.688-1.375c-.438 1.375-1.313 2.438-2.563 3.188 1.125-.125 2.188-.438 3.313-.875z"/></svg>

        </a>
        <a class="floating-header-share-fb" href="https://www.facebook.com/sharer/sharer.php?u=https://leejigun.github.io/WWDC25-Swift-62-%EB%8F%99%EC%8B%9C%EC%84%B1-%EA%B0%9C%EC%84%A0"
            onclick="window.open(this.href, 'share-facebook','width=580,height=296');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M19 6h5V0h-5c-3.86 0-7 3.14-7 7v3H8v6h4v16h6V16h5l1-6h-6V7c0-.542.458-1 1-1z"/></svg>

        </a>
    </div>
    <progress class="progress" value="0">
        <div class="progress-container">
            <span class="progress-bar"></span>
        </div>
    </progress>
</div>


<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->


        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="http://localhost:4001/">iOS 삽질 블로그</a> &copy; 2025</section>
                <section class="poweredby">Github page blog of <a href="https://github.com/Leejigun">Leejigun</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyller/jasper2" target="_blank" rel="noopener">Jasper2</a></section>
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    
                    
                    <!-- <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a> -->
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    

    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-154736789-1', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>

// NOTE: Scroll performance is poor in Safari
// - this appears to be due to the events firing much more slowly in Safari.
//   Dropping the scroll event and using only a raf loop results in smoother
//   scrolling but continuous processing even when not scrolling
$(document).ready(function () {
    // Start fitVids
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
    // End fitVids

    var progressBar = document.querySelector('progress');
    var header = document.querySelector('.floating-header');
    var title = document.querySelector('.post-full-title');

    var lastScrollY = window.scrollY;
    var lastWindowHeight = window.innerHeight;
    var lastDocumentHeight = $(document).height();
    var ticking = false;

    function onScroll() {
        lastScrollY = window.scrollY;
        requestTick();
    }

    function onResize() {
        lastWindowHeight = window.innerHeight;
        lastDocumentHeight = $(document).height();
        requestTick();
    }

    function requestTick() {
        if (!ticking) {
            requestAnimationFrame(update);
        }
        ticking = true;
    }

    function update() {
        var trigger = title.getBoundingClientRect().top + window.scrollY;
        var triggerOffset = title.offsetHeight + 35;
        var progressMax = lastDocumentHeight - lastWindowHeight;

        // show/hide floating header
        if (lastScrollY >= trigger + triggerOffset) {
            header.classList.add('floating-active');
        } else {
            header.classList.remove('floating-active');
        }

        progressBar.setAttribute('max', progressMax);
        progressBar.setAttribute('value', lastScrollY);

        ticking = false;
    }

    window.addEventListener('scroll', onScroll, {passive: true});
    window.addEventListener('resize', onResize, false);

    update();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
