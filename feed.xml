<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://leejigun.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://leejigun.github.io/" rel="alternate" type="text/html" /><updated>2025-07-19T18:49:09+09:00</updated><id>https://leejigun.github.io/feed.xml</id><title type="html">iOS 삽질 블로그</title><subtitle>iOS developer.</subtitle><entry><title type="html">[WWDC25] Swift 6.2 InlineArray: iOS 앱 성능 및 메모리 최적화</title><link href="https://leejigun.github.io/WWDC25-Swift-62-InlineArray-iOS-%EC%95%B1-%EC%84%B1%EB%8A%A5-%EB%B0%8F-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%B5%9C%EC%A0%81%ED%99%94" rel="alternate" type="text/html" title="[WWDC25] Swift 6.2 InlineArray: iOS 앱 성능 및 메모리 최적화" /><published>2025-06-15T09:00:00+09:00</published><updated>2025-06-15T09:00:00+09:00</updated><id>https://leejigun.github.io/WWDC25-Swift-62-InlineArray-iOS-%EC%95%B1-%EC%84%B1%EB%8A%A5-%EB%B0%8F-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%B5%9C%EC%A0%81%ED%99%94</id><content type="html" xml:base="https://leejigun.github.io/WWDC25-Swift-62-InlineArray-iOS-%EC%95%B1-%EC%84%B1%EB%8A%A5-%EB%B0%8F-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%B5%9C%EC%A0%81%ED%99%94"><![CDATA[<h1 id="wwdc25-swift-62-inlinearray-ios-앱-성능-및-메모리-최적화">[WWDC25] Swift 6.2 InlineArray: iOS 앱 성능 및 메모리 최적화</h1>

<p>표지: %5BWWDC25%5D%20Swift%206%202%20InlineArray%20iOS%20%E1%84%8B%E1%85%A2%E1%86%B8%20%E1%84%89%E1%85%A5%E1%86%BC%E1%84%82%E1%85%B3%E1%86%BC%20%E1%84%86%E1%85%B5%E1%86%BE%20%20212eb0887722806da08aedb08f0473de/2025-07-19_18-47-30.png
URL: https://developer.apple.com/kr/videos/play/wwdc2025/245
상태: 작성 중
Tags: iOS
작성일: 2025/06/15</p>

<ul>
  <li><a href="https://developer.apple.com/kr/videos/play/wwdc2025/245">https://developer.apple.com/kr/videos/play/wwdc2025/245</a></li>
</ul>

<h3 id="swift-앱의-성능-최적화와-inlinearray의-등장">Swift 앱의 성능 최적화와 InlineArray의 등장</h3>

<p>Swift 애플리케이션 개발에서 성능 최적화, 특히 메모리 효율성은 중요한 과제입니다. 이번 WWDC25에서 Swift 6.2와 함께 소개된 <strong>InlineArray</strong>는 이러한 메모리 사용량 및 성능 개선을 위한 핵심 도구로 제시되었습니다. 이 글은 InlineArray의 특징과 기존 <code class="language-plaintext highlighter-rouge">Array</code>와의 차이점, 그리고 실제 iOS 앱 개발에서의 활용 방안을 분석합니다.</p>

<blockquote>
  <p>Swift 6.2의 InlineArray는 iOS 앱의 메모리 및 성능 최적화를 위한 새로운 핵심 도구입니다.</p>

</blockquote>

<h3 id="inlinearray의-구조적-차별점">InlineArray의 구조적 차별점</h3>

<p>기존 <code class="language-plaintext highlighter-rouge">Array</code>는 동적 크기 조절과 값 타입 특성 유지를 위해 힙 할당 버퍼 및 Copy-on-Write 최적화를 사용합니다. 반면 <strong>InlineArray</strong>는 컴파일 시점에 크기가 결정되는 고정 크기 배열이며, 요소를 힙 할당 없이 직접 인라인으로 저장합니다. 이는 참조 계산, 고유성/독점성 검사, 그리고 Copy-on-Write 과정에서 발생하는 런타임 오버헤드를 제거하여 성능을 향상시킵니다. 또한, 컴파일 시점에 크기를 알 수 있어 경계 검사 생략 등 추가적인 최적화 가능성을 제공합니다.</p>

<blockquote>
  <p>InlineArray는 고정 크기 인라인 스토리지를 통해 힙 할당 및 런타임 오버헤드를 줄여 성능을 개선합니다.</p>

</blockquote>

<p><img src="/assets/images/ios/2025-06-15-WWDC25-Swift-62-InlineArray-iOS-앱-성능-및-메모리-최적화/image.png" alt="image.png" /></p>

<h3 id="inlinearray-사용의-전략적-고려사항">InlineArray 사용의 전략적 고려사항</h3>

<p>InlineArray는 크기가 고정되어 있고, 빈번한 접근이 필요하며, 복사 및 참조 공유가 불필요한 데이터 구조에 적합합니다. WWDC25 세션에서는 이미지 파서의 픽셀 캐시와 같은 예시를 통해 그 효율성을 강조했습니다. 구체적인 활용 사례로는 <strong>SwiftUI View 내부의 고정된 상태 관리</strong>, <strong>데이터 파싱 시의 임시 고정 버퍼</strong>, 그리고 <strong>유틸리티 함수 내부의 고정 크기 계산용 배열</strong> 등이 있습니다. 이러한 시나리오에서 InlineArray는 불필요한 힙 할당 및 해제 비용을 절감하여 앱의 성능을 개선할 수 있습니다.</p>

<blockquote>
  <p>InlineArray는 고정 크기 데이터, 성능에 민감한 코드 경로, 임베디드 시스템 등 특정 시나리오에서 효율적입니다.</p>

</blockquote>

<h3 id="inlinearray-샘플-코드-분석">InlineArray 샘플 코드 분석</h3>

<p>InlineArray의 사용법은 일반 <code class="language-plaintext highlighter-rouge">Array</code>와 유사하나, 타입 선언 시 크기를 명시해야 합니다. 다음 코드는 3개의 <code class="language-plaintext highlighter-rouge">Int</code> 요소를 가지는 <code class="language-plaintext highlighter-rouge">InlineArray</code>의 선언, 초기화 및 요소 변경을 보여줍니다. <code class="language-plaintext highlighter-rouge">append</code>나 <code class="language-plaintext highlighter-rouge">removeFirst</code>와 같은 동적 크기 조절 메서드는 사용할 수 없으며, 할당 시 Copy-on-Write 없이 즉시 요소들을 복사합니다. 또한, 다른 크기의 InlineArray 타입 간에는 직접 할당이 불가능합니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// InlineArray 선언 및 초기화</span>
<span class="c1">// 3개의 Int 요소를 가지는 InlineArray를 선언하고 초기화합니다.</span>
<span class="k">var</span> <span class="nv">array</span><span class="p">:</span> <span class="kt">InlineArray</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span> <span class="kt">Int</span><span class="o">&gt;</span> <span class="o">=</span> <span class="kt">InlineArray</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"초기 InlineArray: </span><span class="se">\(</span><span class="n">array</span><span class="se">)</span><span class="s">"</span><span class="p">)</span> <span class="c1">// 출력 예시: 초기 InlineArray: [1, 2, 3]</span>

<span class="c1">// 요소 변경 (인덱스를 통한 접근)</span>
<span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"요소 변경 후: </span><span class="se">\(</span><span class="n">array</span><span class="se">)</span><span class="s">"</span><span class="p">)</span> <span class="c1">// 출력 예시: 요소 변경 후: [4, 2, 3]</span>

<span class="c1">// InlineArray는 복사 시 즉시 요소들을 복사합니다 (Copy-on-Write가 아님).</span>
<span class="k">var</span> <span class="nv">copy</span> <span class="o">=</span> <span class="n">array</span>
<span class="n">copy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span> <span class="c1">// copy는 변경되지만, 원본 array는 변경되지 않습니다.</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"원본 array: </span><span class="se">\(</span><span class="n">array</span><span class="se">)</span><span class="s">"</span><span class="p">)</span> <span class="c1">// 출력 예시: 원본 array: [4, 2, 3]</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"복사된 copy: </span><span class="se">\(</span><span class="n">copy</span><span class="se">)</span><span class="s">"</span><span class="p">)</span> <span class="c1">// 출력 예시: 복사된 copy: [10, 2, 3]</span>
</code></pre></div></div>

<ul>
  <li>크기가 고정되어 있어 append 또는 removeFirst와 같은 메서드는 사용할 수 없습니다.</li>
  <li>다른 크기의 InlineArray로는 할당할 수 없습니다.</li>
</ul>

<blockquote>
  <p>InlineArray는 고정 크기를 명시하며, 동적 배열 메서드를 지원하지 않고 복사 시 즉시 전체 요소를 복사합니다.</p>

</blockquote>

<h3 id="swift-앱-최적화의-새로운-지평">Swift 앱 최적화의 새로운 지평</h3>

<p><strong>InlineArray</strong>는 Swift 6.2의 주요 성능 개선 사항 중 하나로, 고정 크기 데이터 처리 시 메모리 사용량과 실행 속도를 개선하는 데 기여합니다. 불필요한 힙 할당과 런타임 메모리 관리 오버헤드를 제거함으로써 iOS 앱의 효율성을 증대시킬 수 있습니다. 개발자들은 최신 Xcode를 통해 InlineArray 및 관련 <strong>Span</strong> 타입에 대해 추가 학습하고 실제 프로젝트에 적용하여 앱의 성능을 향상시킬 수 있을 것입니다.</p>

<blockquote>
  <p>InlineArray는 Swift 앱의 메모리 효율성과 실행 속도를 높여 성능 최적화에 기여하는 중요한 도구입니다.</p>

</blockquote>

<p>일반적인 Array</p>

<p><img src="/assets/images/ios/2025-06-15-WWDC25-Swift-62-InlineArray-iOS-앱-성능-및-메모리-최적화/image 1.png" alt="image.png" /></p>

<ul>
  <li>Stack에는 해당 변수의 메모리 좌표값만 자지고 Heap 메모리에 실제 저장</li>
</ul>

<p>InlineArray</p>

<p><img src="/assets/images/ios/2025-06-15-WWDC25-Swift-62-InlineArray-iOS-앱-성능-및-메모리-최적화/image 2.png" alt="image.png" /></p>

<ul>
  <li>Stack 메모리에 직접 저장</li>
</ul>]]></content><author><name>jglee</name></author><category term="ios" /><summary type="html"><![CDATA[[WWDC25] Swift 6.2 InlineArray: iOS 앱 성능 및 메모리 최적화]]></summary></entry><entry><title type="html">[WWDC25] Swift 6.2 동시성 개선</title><link href="https://leejigun.github.io/WWDC25-Swift-62-%EB%8F%99%EC%8B%9C%EC%84%B1-%EA%B0%9C%EC%84%A0" rel="alternate" type="text/html" title="[WWDC25] Swift 6.2 동시성 개선" /><published>2025-06-14T09:00:00+09:00</published><updated>2025-06-14T09:00:00+09:00</updated><id>https://leejigun.github.io/WWDC25-Swift-62-%EB%8F%99%EC%8B%9C%EC%84%B1-%EA%B0%9C%EC%84%A0</id><content type="html" xml:base="https://leejigun.github.io/WWDC25-Swift-62-%EB%8F%99%EC%8B%9C%EC%84%B1-%EA%B0%9C%EC%84%A0"><![CDATA[<h3 id="왜-동시성이-어려웠을까요">왜 동시성이 어려웠을까요?</h3>

<p>이전 Swift 6에서는 언어가 특정 작업을 개발자의 명시적 지시 없이 <strong>백그라운드 스레드나 다른 액터로 암시적으로 전환(오프로드)</strong>하는 경향이 있었습니다. 이 때문에 개발자가 의도하지 않더라도 <strong>데이터 경쟁(data race)</strong>에 취약한 코드가 컴파일러 오류를 유발할 수 있었죠. 동시성 프로그래밍은 여러 작업이 메모리를 공유하기 때문에 실수에 취약하며, 예상치 못한 결과로 이어질 수 있어 본질적으로 어렵습니다.
<em>**</em></p>

<blockquote>
  <p><strong>이전 Swift 6은 암시적인 백그라운드 오프로드로 인해 의도치 않은 데이터 경쟁이 발생하기 쉬워 동시성 코딩이 복잡했습니다.</strong></p>

</blockquote>

<hr />

<h3 id="swift-62의-새로운-동시성-접근-방식">Swift 6.2의 새로운 동시성 접근 방식</h3>

<p>Swift 6.2는 이러한 문제를 해결하기 위해 동시성에 대한 근본적인 접근 방식을 변경했습니다. 이제 개발자가 명시적으로 동시성을 도입하기로 결정할 때까지 코드가 기본적으로 <strong>단일 스레드 상태</strong>를 유지합니다. 이는 개발자가 가장 자연스럽게 작성하는 코드가 기본적으로 데이터 경쟁으로부터 자유롭도록 하여, 프로젝트에 동시성을 도입하는 더 쉬운 경로를 제공합니다. 즉, 코드를 병렬로 실행하고자 <strong>동시성을 선택적으로 도입</strong>할 경우에만 데이터 경쟁 안전이 보호됩니다.</p>

<blockquote>
  <p><strong>Swift 6.2는 명시적인 동시성 도입 전까지 코드를 기본적으로 단일 스레드 상태로 유지하여 데이터 경쟁을 사전에 방지합니다.</strong></p>

</blockquote>

<p><img src="/assets/images/ios/2025-06-14-WWDC25-Swift-62-동시성-개선/image.png" alt="image.png" /></p>

<hr />

<h3 id="핵심-동시성-개선-사항">핵심 동시성 개선 사항</h3>

<p><img src="/assets/images/ios/2025-06-14-WWDC25-Swift-62-동시성-개선/image 1.png" alt="image.png" /></p>

<h3 id="1-호출자의-액터에서-비동기-함수-실행-async-functions-run-on-the-callers-actor">1. 호출자의 액터에서 비동기 함수 실행 (Async Functions Run on the Caller’s Actor)</h3>

<p>이전 Swift 6에서는 특정 비동기 함수가 언어에 의해 암시적으로 백그라운드로 오프로드되는 경우가 많았습니다. 이로 인해 개발자가 의도하지 않았음에도 데이터 경쟁에 취약한 코드가 컴파일러 오류를 유발할 수 있었습니다.</p>

<blockquote>
  <p><strong>이전 Swift 6에서는 비동기 함수가 암시적으로 백그라운드에서 실행되어 데이터 경쟁을 유발할 수 있었습니다.</strong></p>

</blockquote>

<p>문제 상황 (Swift 6 이전):</p>

<p>예를 들어, PhotoProcessor 클래스에 extractSticker라는 비동기 메서드가 있고, 이 메서드가 MainActor에 격리된 StickerModel 클래스 내에서 호출될 때 문제가 발생할 수 있었습니다. extractSticker가 내부적으로 MainActor가 아닌 다른 스레드에서 실행되도록 암시적으로 오프로드될 경우, MainActor의 UI 코드와 공유 상태에 접근하려 할 때 데이터 경쟁 위험이 발생하여 컴파일러 오류가 발생할 수 있었습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Swift 6 (이전)</span>
<span class="c1">// 비동기 함수 호출 시 암시적 오프로드로 인한 잠재적 데이터 경쟁 오류</span>
<span class="kd">class</span> <span class="kt">PhotoProcessor</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">extractSticker</span><span class="p">(</span><span class="nv">data</span><span class="p">:</span> <span class="kt">Data</span><span class="p">,</span> <span class="n">with</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">String</span><span class="p">?)</span> <span class="k">async</span> <span class="o">-&gt;</span> <span class="kt">Sticker</span><span class="p">?</span> <span class="p">{</span>
        <span class="c1">// 이미지 처리 로직 (시간이 오래 걸릴 수 있음)</span>
        <span class="c1">// 이 함수가 MainActor에 격리되지 않아 백그라운드로 암시적 오프로드될 가능성</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">@MainActor</span> <span class="kd">final</span> <span class="kd">class</span> <span class="kt">StickerModel</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">photoProcessor</span> <span class="o">=</span> <span class="kt">PhotoProcessor</span><span class="p">()</span>

    <span class="kd">func</span> <span class="nf">extractSticker</span><span class="p">(</span><span class="n">_</span> <span class="nv">item</span><span class="p">:</span> <span class="kt">PhotosPickerItem</span><span class="p">)</span> <span class="k">async</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Sticker</span><span class="p">?</span> <span class="p">{</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">data</span> <span class="o">=</span> <span class="k">try</span> <span class="k">await</span> <span class="n">item</span><span class="o">.</span><span class="nf">loadTransferable</span><span class="p">(</span><span class="nv">type</span><span class="p">:</span> <span class="kt">Data</span><span class="o">.</span><span class="k">self</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="c1">// 여기서 photoProcessor.extractSticker 호출 시 데이터 경쟁 위험이 감지될 수 있음</span>
        <span class="k">return</span> <span class="k">await</span> <span class="n">photoProcessor</span><span class="o">.</span><span class="nf">extractSticker</span><span class="p">(</span><span class="nv">data</span><span class="p">:</span> <span class="n">data</span><span class="p">,</span> <span class="nv">with</span><span class="p">:</span> <span class="n">item</span><span class="o">.</span><span class="n">itemIdentifier</span><span class="p">)</span>
        <span class="c1">// 에러 메시지 예시: "Reference to property 'photoProcessor' in non-isolated actor-relative context cannot be used to satisfy an @MainActor requirement"</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>StickerModel.extractSticker: StickerModel 클래스가 @MainActor 로 정의하고 있기 때문에 MainActor에서 실행</li>
  <li>PhotoProcessor.extractSticker: MainActor에 격리되지 않아 백그라운드로 실행될 가능성 높음</li>
</ul>

<p>Swift 6.2의 개선:</p>

<p>Swift 6.2에서는 특정 액터에 연결되지 않은 비동기 함수(actor-isolated가 아닌 async 함수)는 이제 해당 함수가 호출된 액터에서 계속 실행됩니다. 즉, PhotoProcessor의 extractSticker와 같이 액터가 지정되지 않은 비동기 함수를 MainActor 내에서 호출하면, 해당 함수는 MainActor 컨텍스트 내에서 실행됩니다. 이는 비동기 함수에 전달된 값이 액터 외부로 전송되지 않도록 하여 데이터 경쟁을 방지합니다. 개발자는 비동기 함수가 내부적으로 작업을 오프로드하더라도 가변 상태에 대해 걱정할 필요가 없어집니다. 예를 들어, UI 업데이트 로직에서 MainActor를 잘못 타서 발생할 수 있었던 데이터 경쟁 문제를 예방할 수 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Swift 6.2</span>
<span class="c1">// 호출자의 액터에서 비동기 함수 실행</span>
<span class="kd">class</span> <span class="kt">PhotoProcessor</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">extractSticker</span><span class="p">(</span><span class="nv">data</span><span class="p">:</span> <span class="kt">Data</span><span class="p">,</span> <span class="n">with</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">String</span><span class="p">?)</span> <span class="k">async</span> <span class="o">-&gt;</span> <span class="kt">Sticker</span><span class="p">?</span> <span class="p">{</span>
        <span class="c1">// 이 함수는 여전히 MainActor에 있지 않지만,</span>
        <span class="c1">// MainActor에서 호출되면 MainActor 컨텍스트 내에서 실행됩니다.</span>
        <span class="c1">// 내부적으로 필요한 경우에만 명시적으로 다른 액터로 작업을 오프로드할 수 있습니다.</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">@MainActor</span> <span class="kd">final</span> <span class="kd">class</span> <span class="kt">StickerModel</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">photoProcessor</span> <span class="o">=</span> <span class="kt">PhotoProcessor</span><span class="p">()</span>

    <span class="kd">func</span> <span class="nf">extractSticker</span><span class="p">(</span><span class="n">_</span> <span class="nv">item</span><span class="p">:</span> <span class="kt">PhotosPickerItem</span><span class="p">)</span> <span class="k">async</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Sticker</span><span class="p">?</span> <span class="p">{</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">data</span> <span class="o">=</span> <span class="k">try</span> <span class="k">await</span> <span class="n">item</span><span class="o">.</span><span class="nf">loadTransferable</span><span class="p">(</span><span class="nv">type</span><span class="p">:</span> <span class="kt">Data</span><span class="o">.</span><span class="k">self</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="c1">// 이제 이 호출은 MainActor 컨텍스트 내에서 안전하게 이루어집니다.</span>
        <span class="k">return</span> <span class="k">await</span> <span class="n">photoProcessor</span><span class="o">.</span><span class="nf">extractSticker</span><span class="p">(</span><span class="nv">data</span><span class="p">:</span> <span class="n">data</span><span class="p">,</span> <span class="nv">with</span><span class="p">:</span> <span class="n">item</span><span class="o">.</span><span class="n">itemIdentifier</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p><strong>Swift 6.2에서는 비동기 함수가 호출된 액터에서 계속 실행되도록 변경되어, <code class="language-plaintext highlighter-rouge">MainActor</code> 내에서의 데이터 경쟁 위험을 줄였습니다.</strong></p>

</blockquote>

<h3 id="2-격리된-적합성-isolated-conformances">2. 격리된 적합성 (Isolated Conformances)</h3>

<p>Swift 6.2는 <code class="language-plaintext highlighter-rouge">MainActor</code>와 같은 액터에 격리된 유형(actor-isolated types)이 프로토콜을 준수하는 것을 더 쉽게 만들었습니다.</p>

<blockquote>
  <p><strong>Swift 6.2는 액터에 격리된 타입이 프로토콜을 더 쉽게 준수하도록 개선했습니다.</strong></p>

</blockquote>

<p>문제 상황 (Swift 6 이전):</p>

<p>MainActor에 격리된 StickerModel 클래스가 Exportable이라는 프로토콜을 준수해야 한다고 가정해 봅시다. Exportable 프로토콜은 액터 격리를 요구하지 않습니다. Swift 6에서는 컴파일러가 StickerModel의 export() 메서드가 MainActor 외부에서도 호출될 수 있다고 가정하여, MainActor 상태를 사용하는 것을 막았습니다. 이는 잠재적인 데이터 경쟁 때문입니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Swift 6 (이전)</span>
<span class="kd">protocol</span> <span class="kt">Exportable</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">export</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">StickerModel</span><span class="p">:</span> <span class="kt">Exportable</span> <span class="p">{</span>
    <span class="c1">// error: Conformance of 'StickerModel' to protocol 'Exportable' crosses into main actor-isolated code and can cause data races</span>
    <span class="c1">// StickerModel이 @MainActor로 격리되어 있기 때문에,</span>
    <span class="c1">// export() 메서드가 MainActor 외부에서 호출될 경우 데이터 경쟁이 발생할 수 있다고 컴파일러가 판단합니다.</span>
    <span class="kd">func</span> <span class="nf">export</span><span class="p">()</span> <span class="p">{</span> <span class="n">photoProcessor</span><span class="o">.</span><span class="nf">exportAsPNG</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Swift 6.2의 개선:</p>

<p>MainActor 상태를 필요로 하는 적합성은 이제 @MainActor 속성을 사용하여 <strong>‘격리된 적합성(Isolated Conformance)’</strong>으로 명시할 수 있습니다. 컴파일러는 MainActor 적합성이 MainActor 내에서만 사용되도록 보장하여 안전성을 유지합니다. 개발자는 코드가 동시적으로 적합성을 사용할 때만 데이터 경쟁 안전 문제를 해결하면 됩니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Swift 6.2</span>
<span class="kd">protocol</span> <span class="kt">Exportable</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">export</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// @MainActor 속성을 사용하여 StickerModel의 Exportable 적합성이 MainActor에 격리됨을 명시</span>
<span class="kd">extension</span> <span class="kt">StickerModel</span><span class="p">:</span> <span class="kd">@MainActor</span> <span class="kt">Exportable</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">export</span><span class="p">()</span> <span class="p">{</span> <span class="n">photoProcessor</span><span class="o">.</span><span class="nf">exportAsPNG</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// MainActor 격리된 ImageExporter 구조체 내에서 StickerModel을 사용하는 것은 안전합니다.</span>
<span class="kd">@MainActor</span> <span class="kd">struct</span> <span class="kt">ImageExporter</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">items</span><span class="p">:</span> <span class="p">[</span><span class="n">any</span> <span class="kt">Exportable</span><span class="p">]</span>

    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">add</span><span class="p">(</span><span class="n">_</span> <span class="nv">item</span><span class="p">:</span> <span class="kt">StickerModel</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">items</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">exportAll</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">item</span> <span class="k">in</span> <span class="n">items</span> <span class="p">{</span>
            <span class="n">item</span><span class="o">.</span><span class="nf">export</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 하지만 만약 ImageExporter가 nonisolated로 선언된다면, MainActor에 격리된 StickerModel의 적합성을</span>
<span class="c1">// nonisolated 컨텍스트에서 사용하려 할 때 컴파일러 오류가 발생합니다.</span>
<span class="c1">// 이는 컴파일러가 MainActor의 상태가 안전하게 유지되도록 강제하는 것입니다.</span>
<span class="kd">nonisolated</span> <span class="kd">struct</span> <span class="kt">ImageExporter</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">items</span><span class="p">:</span> <span class="p">[</span><span class="n">any</span> <span class="kt">Exportable</span><span class="p">]</span>

    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">add</span><span class="p">(</span><span class="n">_</span> <span class="nv">item</span><span class="p">:</span> <span class="kt">StickerModel</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">items</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="c1">// error: Main actor-isolated conformance of 'StickerModel' to 'Exportable' cannot be used in nonisolated context</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">exportAll</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">item</span> <span class="k">in</span> <span class="n">items</span> <span class="p">{</span>
            <span class="n">item</span><span class="o">.</span><span class="nf">export</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p><strong>이제 <code class="language-plaintext highlighter-rouge">@MainActor</code> 속성으로 프로토콜 적합성을 명시하여, <code class="language-plaintext highlighter-rouge">MainActor</code> 내에서 프로토콜을 안전하게 사용할 수 있습니다.</strong></p>

</blockquote>

<h3 id="3-기본-추론-모드-opt-in-mode-to-infer-mainactor-by-default">3. 기본 추론 모드 (Opt-in Mode to Infer MainActor by Default)</h3>

<p>이 모드는 프로젝트의 모든 가변 상태를 기본적으로 <code class="language-plaintext highlighter-rouge">MainActor</code>로 보호하여, 안전하지 않은 전역 및 정적 변수 호출과 같은 데이터 경쟁 안전 오류를 제거하는 <strong>선택적(opt-in) 기능</strong>입니다. 이는 대부분 단일 스레드인 코드에서 동시성 관련 주석을 줄이는 데 도움이 되며, 앱, 스크립트 및 기타 실행 대상에 권장됩니다.</p>

<blockquote>
  <p><strong>‘기본 추론 모드’는 프로젝트의 모든 가변 상태를 <code class="language-plaintext highlighter-rouge">MainActor</code>로 자동 보호하여 동시성 관련 주석을 줄여줍니다.</strong></p>

</blockquote>

<p>문제 상황 (Swift 6 이전):</p>

<p>전역 및 정적 변수는 어디서든 접근할 수 있는 가변 상태를 가질 수 있어 데이터 경쟁에 취약합니다. StickerLibrary.shared와 같은 정적 변수는 Sendable 타입이 아닌 경우 동시성 안전하지 않다는 경고 또는 오류를 발생시킬 수 있었습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Swift 6 (이전)</span>
<span class="c1">// 안전하지 않은 정적 변수 사용</span>
<span class="kd">final</span> <span class="kd">class</span> <span class="kt">StickerLibrary</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="k">let</span> <span class="nv">shared</span><span class="p">:</span> <span class="kt">StickerLibrary</span> <span class="o">=</span> <span class="o">.</span><span class="nf">init</span><span class="p">()</span> <span class="c1">// error: Static property 'shared' is not concurrency-safe because non-'Sendable' type 'StickerLibrary' may have shared mutable state</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Swift 6.2의 개선:</p>

<p>이 모드를 활성화하면, 기본적으로 모든 가변 상태가 MainActor로 추론되어 보호됩니다. 따라서 개발자가 PhotoProcessor와 같은 특정 유형이나 파일 내에 캡슐화된 동시성 코드를 제외하고 대부분의 코드를 단일 스레드처럼 작성하더라도, MainActor 주석을 명시적으로 추가할 필요 없이 안전한 코드를 작성할 수 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Swift 6.2 (기본 MainActor 추론 모드 활성화 시)</span>
<span class="c1">// 명시적인 @MainActor 주석 없이도 안전한 코드</span>
<span class="c1">// (프로젝트 설정에서 'Infer Main Actor by Default' 활성화 가정)</span>

<span class="kd">final</span> <span class="kd">class</span> <span class="kt">StickerLibrary</span> <span class="p">{</span>
    <span class="c1">// 이제 이 정적 변수는 자동으로 MainActor에 격리된 것으로 추론됩니다.</span>
    <span class="kd">static</span> <span class="k">let</span> <span class="nv">shared</span><span class="p">:</span> <span class="kt">StickerLibrary</span> <span class="o">=</span> <span class="o">.</span><span class="nf">init</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">final</span> <span class="kd">class</span> <span class="kt">StickerModel</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">photoProcessor</span><span class="p">:</span> <span class="kt">PhotoProcessor</span>
    <span class="k">var</span> <span class="nv">selection</span><span class="p">:</span> <span class="p">[</span><span class="kt">PhotosPickerItem</span><span class="p">]</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">StickerModel</span><span class="p">:</span> <span class="kt">Exportable</span> <span class="p">{</span>
    <span class="c1">// 이 적합성도 MainActor에 격리된 것으로 자동으로 추론됩니다.</span>
    <span class="kd">func</span> <span class="nf">export</span><span class="p">()</span> <span class="p">{</span> <span class="n">photoProcessor</span><span class="o">.</span><span class="nf">exportAsPNG</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>이 모드를 활성화하면 명시적인 <code class="language-plaintext highlighter-rouge">MainActor</code> 주석 없이도 대부분의 코드가 <code class="language-plaintext highlighter-rouge">MainActor</code>로 안전하게 보호됩니다.</strong></p>

<h3 id="4concurrent속성-the-attribute">4. <code class="language-plaintext highlighter-rouge">@concurrent</code> 속성 (The Attribute)</h3>

<p>CPU 집약적인 작업을 백그라운드로 오프로드할 때 앱의 반응성을 유지하기 위해 <strong><code class="language-plaintext highlighter-rouge">@concurrent</code> 속성</strong>이 도입되었습니다.</p>

<p><strong><code class="language-plaintext highlighter-rouge">@concurrent</code> 속성은 CPU 집약적인 작업을 백그라운드 스레드에서 실행하여 앱의 반응성을 유지하는 데 사용됩니다.</strong></p>

<p>사용 목적:</p>

<p>이 속성을 사용하면 함수가 항상 <strong>동시 스레드 풀(concurrent thread pool)</strong>에서 실행되도록 하여, 현재 액터(예: MainActor)가 다른 작업을 동시에 수행할 수 있도록 합니다. 이는 UI 스레드를 차단하지 않고 무거운 작업을 처리할 때 특히 유용합니다.</p>

<p>샘플 코드:</p>

<p>PhotoProcessor 클래스에서 이미지를 분석하여 스티커를 추출하는 extractSubject 메서드가 CPU 집약적인 작업이라고 가정해 봅시다. 이 작업을 @concurrent로 표시하면, 이 함수가 호출될 때 MainActor와 같은 호출 액터를 차단하지 않고 별도의 동시 스레드 풀에서 실행될 것임을 보장합니다. 실제 CPU 집약적인 작업에는 Core ML 모델 실행, 복잡한 이미지 필터링, 대용량 데이터 처리 등이 포함될 수 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Swift 6.2</span>
<span class="kd">class</span> <span class="kt">PhotoProcessor</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">cachedStickers</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">:</span> <span class="kt">Sticker</span><span class="p">]</span> <span class="o">=</span> <span class="p">[:]</span>

    <span class="kd">func</span> <span class="nf">extractSticker</span><span class="p">(</span><span class="nv">data</span><span class="p">:</span> <span class="kt">Data</span><span class="p">,</span> <span class="n">with</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">async</span> <span class="o">-&gt;</span> <span class="kt">Sticker</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nv">sticker</span> <span class="o">=</span> <span class="n">cachedStickers</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">sticker</span> <span class="c1">// 캐시된 스티커가 있다면 즉시 반환</span>
        <span class="p">}</span>

        <span class="c1">// extractSubject 메서드는 CPU 집약적이므로 @concurrent 속성을 사용하여 백그라운드 스레드에서 실행</span>
        <span class="k">let</span> <span class="nv">sticker</span> <span class="o">=</span> <span class="k">await</span> <span class="k">Self</span><span class="o">.</span><span class="nf">extractSubject</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="n">data</span><span class="p">)</span>
        <span class="n">cachedStickers</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">sticker</span>
        <span class="k">return</span> <span class="n">sticker</span>
    <span class="p">}</span>

    <span class="c1">// @concurrent 속성: 이 함수는 항상 동시 스레드 풀에서 실행됩니다.</span>
    <span class="kd">@concurrent</span> <span class="kd">static</span> <span class="kd">func</span> <span class="nf">extractSubject</span><span class="p">(</span><span class="n">from</span> <span class="nv">data</span><span class="p">:</span> <span class="kt">Data</span><span class="p">)</span> <span class="k">async</span> <span class="o">-&gt;</span> <span class="kt">Sticker</span> <span class="p">{</span>
        <span class="c1">// 실제 CPU 집약적인 이미지 처리 및 피사체 추출 로직</span>
        <span class="c1">// 예: Core ML 모델 실행, 복잡한 이미지 필터링 등</span>
        <span class="c1">// 이 작업은 MainActor를 차단하지 않습니다.</span>
        <span class="k">return</span> <span class="kt">Sticker</span><span class="p">()</span> <span class="c1">// 예시 반환</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p><strong><code class="language-plaintext highlighter-rouge">@concurrent</code>는 <code class="language-plaintext highlighter-rouge">MainActor</code>를 차단하지 않고 무거운 작업을 병렬 스레드에서 효율적으로 처리하도록 보장합니다.</strong></p>

</blockquote>

<hr />

<h3 id="더-쉬워진-동시성-더-강력해진-swift">더 쉬워진 동시성, 더 강력해진 Swift</h3>

<p><img src="/assets/images/ios/2025-06-14-WWDC25-Swift-62-동시성-개선/image 2.png" alt="image.png" /></p>

<p>이러한 언어 변경 사항들은 함께 작동하여 동시성을 더 쉽게 다룰 수 있도록 돕습니다. 개발자는 먼저 데이터 경쟁 위험이 없는 <strong><code class="language-plaintext highlighter-rouge">MainActor</code>에서 기본적으로 실행되는 코드를 작성</strong>하고, 필요할 때 병렬 실행을 위해 특정 코드를 안전하게 오프로드할 수 있습니다. 또한, Swift 6.2는 비동기 코드의 디버깅 경험을 크게 개선하여 LLDB가 스레드 간 전환 시에도 비동기 함수 실행을 추적하고, 작업 이름 지정 및 가시성을 제공합니다.</p>

<p>이러한 개선은 Swift 커뮤니티의 피드백을 통해 이루어졌으며, Swift가 초보자와 전문가 모두에게 더 쉽게 사용될 수 있도록 언어를 발전시키는 데 기여합니다.</p>

<blockquote>
  <p><strong>Swift 6.2의 개선 사항들은 동시성 코딩을 단순화하고 디버깅 경험을 향상시켜 Swift를 더욱 강력하게 만듭니다.</strong></p>

</blockquote>

<hr />

<h3 id="어떻게-적용할-수-있나요">어떻게 적용할 수 있나요?</h3>

<p>이러한 동시성 관련 언어 변경 사항들은 선택 사항으로 구성되었으며, Xcode 빌드 설정의 <strong>Swift 컴파일러 - 동시성 섹션</strong>에서 활성화할 수 있습니다. SwiftSettings API를 사용하여 Swift 패키지 매니페스트 파일에서도 이 기능을 활성화할 수 있습니다.</p>

<p>Xcode 빌드 설정에서 활성화:</p>

<p>Swift Compiler - Concurrency 섹션에서 “Strict Concurrency Checking”을 Complete로 설정하고 “Infer Main Actor by Default”를 활성화할 수 있습니다.</p>

<p>또한, Swift 6.2에는 필요한 코드 변경 사항을 자동으로 적용할 수 있는 <strong>마이그레이션 도구</strong>가 포함되어 있습니다. 이 도구는 주로 액터 격리 관련 경고 및 오류를 수정하고, <code class="language-plaintext highlighter-rouge">Sendable</code> 준수와 관련된 변경 사항을 제안하여 기존 코드를 새 동시성 모델에 맞게 업데이트하는 데 도움을 줍니다.</p>

<p>Swift 6.2의 동시성 개선은 개발자들이 더욱 안전하고 효율적인 애플리케이션을 만들 수 있도록 돕는 중요한 진전입니다. 지금 바로 Xcode를 업데이트하고 새로운 동시성 기능을 경험해 보세요!</p>

<blockquote>
  <p><strong>Swift 6.2 동시성 기능은 Xcode 빌드 설정이나 Swift Package Manager를 통해 활성화할 수 있으며, 기존 코드 마이그레이션 도구도 제공됩니다.</strong></p>

</blockquote>

<p><strong>참고:</strong> 이 글은 WWDC25 비디오 (“Improve memory usage and performance with Swift”, “What’s new in Swift”) 및 관련 Swift 6.2 발표 자료를 바탕으로 작성되었습니다.</p>

<hr />]]></content><author><name>jglee</name></author><category term="ios" /><summary type="html"><![CDATA[왜 동시성이 어려웠을까요?]]></summary></entry><entry><title type="html">Thinking in SwiftUI - 3장 Layout</title><link href="https://leejigun.github.io/Thinking-in-SwiftUI-3%EC%9E%A5-Layout" rel="alternate" type="text/html" title="Thinking in SwiftUI - 3장 Layout" /><published>2025-06-05T03:16:50+09:00</published><updated>2025-06-05T03:16:50+09:00</updated><id>https://leejigun.github.io/Thinking-in-SwiftUI---3%EC%9E%A5-Layout</id><content type="html" xml:base="https://leejigun.github.io/Thinking-in-SwiftUI-3%EC%9E%A5-Layout"><![CDATA[<h3 id="text">Text</h3>

<p>기본적으로 Text 뷰는 제안된 크기에 맞게 조정됩니다. 텍스트는 이 작업을 수행하기 위해 다음 순서로 여러 전략을 사용합니다: 텍스트를 여러 줄로 나누기(단어 줄 바꿈), 단어를 나누기(줄 바꿈), 자르기, 마지막으로 텍스트를 조정하기.</p>

<p>텍스트는 항상 콘텐츠를 렌더링하는데 필요한 정확한 크기를 반환합니다. 이 크기는 제안된 너비보다 작거나 같고 최소한 한 줄의 높이입니다(0 제안 제외). 즉, 텍스트는 0부터 콘텐츠 전체를 렌더링하는데 필요한 크기까지 임의의 너비를 가질 수 있습니다.</p>

<p>다음은 Text(“Hello, World!”)가 제안된 크기에 따라 어떻게 렌더링되는지에 대한 몇 가지 예입니다. 점선 사각형은 제안된 크기를 나타내고, 실선 사각형은 반환된 크기를 나타냅니다.</p>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 2.png" alt="Untitled" /></p>

<p>→ <code class="language-plaintext highlighter-rouge">.lineLimit(_ number:)</code>를 사용하면 제안된 수직 공간에 관계없이 렌더링할 최대 라인 수를 지정할 수 있습니다. nil을 지정하면 줄 제한이 없음을 의미합니다.</p>

<p>→ <code class="language-plaintext highlighter-rouge">.lineLimit(_limit:reservesSpace:)</code>를 사용하면 렌더링할 최대 줄 수를 지정하고, 비어 있는지 여부에 관계없이 보고된 크기에 이러한 줄의 공간을 항상 포함하는 옵션을 제공합니다.</p>

<p>→ <code class="language-plaintext highlighter-rouge">.truncationMode(_ mode:)</code>를 사용하면 잘림을 적용할 위치를 지정할 수 있습니다.</p>

<p>→ <code class="language-plaintext highlighter-rouge">.minimumScaleFactor(_ Factor:)</code>를 사용하면 제안된 크기에 맞도록 글꼴 크기를 축소할 수 있는 텍스트의 양을 지정할 수 있습니다.</p>

<p>만약, fixedSize()를 Text에 적용시키면, 제안과 다른 결과를 보여준다.</p>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 3.png" alt="Untitled" /></p>

<h3 id="shapes"><strong>Shapes</strong></h3>

<p>대부분의 기본 제공 모양(<strong>Rectangle</strong>, <strong>RoundedRectangle</strong>, <strong>Capsule</strong> 및 <strong>Ellipse</strong>)은 0부터 무한대까지 제안된 크기를 수용하고 사용 가능한 공간을 채웁 니다. <strong>원은 예외입니다.</strong> 제안된 크기에 맞춰지고 원의 실제 크기를 다시 보고합니다. 모양에 nil을 제안하는 경우(즉, .fixedSize로 래핑하는 경우) 기본 크기는 10 10입니다.</p>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 4.png" alt="Untitled" /></p>

<h2 id="colors"><strong>Colors</strong></h2>

<p><code class="language-plaintext highlighter-rouge">Color.red</code>와 같이 색상을 뷰로 직접 사용하는 경우, 레이아웃 관점에서는 <code class="language-plaintext highlighter-rouge">Rectangle().fill(⋯)</code>처럼 동작합니다.</p>

<p>그러나 특별한 경우가 있습니다. ignoresSafeAreaEdges에 색상을 넣으면, 해당 색상이 마법처럼 ignoresSafeAreaEdges으로 확장됩니다. 이 동작은 레이아웃에 영향을 주지 않지만, 우리 모두가 어느 시점에서 이 문제를 겪게 될 것이므로, 이를 언급하고자 했습니다. 이를 방지하기 위해서는, .background에서 ignoresSafeAreaEdges 매개변수를 사용하거나, Color 대신 Rectangle().fill(⋯)을 사용할 수 있습니다.</p>

<h3 id="image"><strong>Image</strong></h3>

<p>기본적으로 이미지 보기는 정적 값, 즉 기본 이미지의 크기를 보고합니다. 이미지에 대해 <code class="language-plaintext highlighter-rouge">.resizeable()</code>을 호출하면 보기가 완전히 유연해집니다. 그런 다음 이미지는 제안된 크기를 수락하고 이를 다시 보고하며 이미지를 해당 크기로 압축합니다. 실제로 크기 조 정이 가능한 거의 모든 이미지는 다음과 결합됩니다.</p>

<p>이미지가 왜곡되는 것을 방지하기 위한 <code class="language-plaintext highlighter-rouge">.aspectRatio(contentMode:)</code> 또는 <code class="language-plaintext highlighter-rouge">.scaleToFit()</code> modifier를 사용합니다.</p>

<h3 id="divider"><strong>Divider</strong></h3>

<p>구분선이 수평 스택 외부에서 사용되는 경우 제안된 너비를 수락하고 구분선의 높이를 보고합니다. 수평 스택 내에서 구분 선은 제안된 높이를 승인하고 구분선의 너비를 보고합니다. <strong>nil을 제안하면 상황에 따라 가변 축의 기본 크기가 10이 됩 니다.</strong></p>

<h3 id="spacer"><strong>Spacer</strong></h3>

<p>수평 또는 수직 스택 외부에서 Spacer는 <strong>최소 길이부터 무한대까지 제안된 크기를 허용</strong>합니다.</p>

<p>수직 스택 내에서 Spacer는 최소 길이에서 무한대까지의 높이를 허용하지만 <strong>너비 는 0으로 보고됩니다.</strong></p>

<p>스페이서의 최소 길이는 minLength를 사용하여 길이를 지정하지 않는 한 기본 패딩의 길이입니다.</p>

<h2 id="modifier-view">Modifier View</h2>

<hr />

<p>ViewModifier는 항상 다른 레이어 내부에 기존 뷰를 래핑합니다. <strong>수정자는 적용된 뷰의 상위가 됩니다.</strong> SwiftUI에는 ViewModifier 프로토콜을 준수하는 값을 적용하기 위한 .modifier API가 있지만 SwiftUI의 내장 수정자는 모두 View의 확장으로 노출됩니다(이는 자체 뷰 수정자에도 좋은 방법입니다). 이 섹션에서는 레이아웃에 영향을 미치는 뷰 수정자를 설명합니다.</p>

<h3 id="frame">Frame</h3>

<ul>
  <li>고정값 지정</li>
  <li>유연하게 지정
    <ul>
      <li>유연하게 frame 값을 설정한 경우 2번 범위를 정하게 됩니다.</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 5.png" alt="Untitled" /></p>

<p>만약 다음과 같이 설정한 경우 320 480 화면에서 렌더링될 때</p>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 6.png" alt="Untitled" /></p>

<ol>
  <li>
    <p>시스템은 패딩을 320, 480으로 제안합니다.</p>
  </li>
  <li>
    <p>패딩은 배경에 300 460을 제안합니다.</p>
  </li>
  <li>
    <p>배경은 기본 하위 뷰에 동일한 300 460을 제안합니다. (frame).</p>
  </li>
</ol>

<ul>
  <li>일단 가능한 최대값을 제안</li>
</ul>

<ol>
  <li>
    <p>프레임은 하위 뷰(텍스트)에 동일한 300 460을 제안합니다.</p>
  </li>
  <li>
    <p>텍스트에서는 크기가 76 17이라고 보고합니다.</p>
  </li>
  <li>
    <p>프레임의 너비는 max(0, min( .infinity, 300)) = 300이 됩니다.</p>
  </li>
</ol>

<ul>
  <li>0 및 .infinity 값은 유연한 프레임에 대해 지정된 인수입니다.</li>
</ul>

<ol>
  <li>
    <p>배경은 유연한 프레임의 크기(300 17)를 제안합니다.</p>
  </li>
  <li>
    <p>색상은 제안된 크기를 수락하고 보고합니다. (300 17)</p>
  </li>
  <li>
    <p>배경은 기본 하위 뷰의 크기(300 17)를 보고합니다.</p>
  </li>
  <li>
    <p>패딩은 각 측면에 10포인트를 추가하고 크기를 320 37로 보고합니다.</p>
  </li>
</ol>

<h2 id="aspectratio">AspectRatio</h2>

<p>AspectRatio 유연한 frame 사이즈로 작업할 때 유용하게 사용할 수 있습니다. 예를 들어 아래 코드는 4:3 인 직사각형을 그릴 수 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Color</span><span class="o">.</span><span class="n">secondary</span>
	<span class="o">.</span><span class="nf">aspectRatio</span><span class="p">(</span><span class="mi">4</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="nv">contentMode</span><span class="p">:</span> <span class="o">.</span><span class="n">fit</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 7.png" alt="Untitled" /></p>

<p>aspectRatio의 일반적으로 이미지에 사용합니다. 이미지에 .resizable() 을 붙이면 사이즈에 맞게 이미지가 늘어나거나 줄어드는데, 이미지가 깨지지 않도록 aspectRatio 를 사용해 화면 사이즈에 맞춰 이미지 사이즈를 조절할 수 있습니다.</p>

<p><strong>만약, 비율을 적용하지 않은 경우 어떻게 될까?</strong></p>

<p>aspectRatio modifier는 하위 뷰의 이상적인 크기를 제안을 통해 조사하고, 비율을 적용합니다.</p>

<p>만약, 이미지를 사용했을 때 이미지의 사이즈가 100:30 이라고 가정하고, 전체 사이즈가 200:200 이면, 아래와 같은 절차를 따라 사이즈를 설정합니다.</p>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 8.png" alt="Untitled" /></p>

<ol>
  <li>
    <p>AspectRatio의 크기는 200x200으로 제안을 내려보냅니다.</p>
  </li>
  <li>
    <p>AspectRatio는 이미지에 nil x nil로 제안합니다.(사이즈 제한 없이)</p>
  </li>
  <li>
    <p>이미지의 이상적인 크기는 100x30으로 제안을 올려보냅니다.</p>
  </li>
  <li>
    <p>가로 세로 비율이 100/30인 직사각형을 200 200에 맞춥니다.</p>
  </li>
</ol>

<ul>
  <li>200 60이며 이 크기를 이미지에 제안합니다.</li>
</ul>

<ol>
  <li>이미지의 크기는 200 60으로 보고됩니다.</li>
  <li>AspectRatio는 하위 뷰의 크기인 200 60을 자체 크기로 보고합니다.</li>
</ol>

<blockquote>
  <p>AspectRatio를 적용한다고 반드시 비율에 맞게 조정되는건 아닙니다. 하위뷰가 유연하지 않을 경우 적용되지 않을 수 있습니다.</p>

</blockquote>

<h3 id="overlay-and-background"><strong>Overlay and Background</strong></h3>

<p>Overlay와 Background는 SwiftUI에서 가장 유용한 수정자 중 하나입니다. 레이아웃 측면에서는 정확히 동일한 방식으로 작동합니다. 유일한 차이점은 Overlay는 기본 View 위에 보조 View를 그리는 반면, Background는 기본 View 뒤에 보조 View를 그리는 것입니다. 예를 들어, 일부 텍스트 뒤에 배경을 그리려면 다음과 같이 할 수 있습니다.</p>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 9.png" alt="Untitled" /></p>

<p>Background와 overlay는 기본 하위 View의 레이아웃에 영향을 미치지 않습니다. 보고된 overlay 또는 background의 크기는 항상 기본 하위 View의 보고된 크기입니다.</p>

<h2 id="container-view">Container View</h2>

<hr />

<p>HStack과 VStack은 단순해보이지만, 결과를 파악하는데 복잡할 수 있다.</p>

<p>만약 아래와 같이 사이즈를 지정하지 않은 경우 제안된 크기에 따라서 다른 결과가 나온다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">HStack</span><span class="p">(</span><span class="nv">spacing</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> 
	<span class="kt">Color</span><span class="o">.</span><span class="n">cyan</span> 
	<span class="kt">Text</span><span class="p">(</span><span class="s">"Hello, World!"</span><span class="p">)</span> 
	<span class="kt">Color</span><span class="o">.</span><span class="n">teal</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 10.png" alt="Untitled" /></p>

<ol>
  <li>큰 크기를 제공한 케이스 (150x50)
    <ol>
      <li>모두 충분한 크기를 제공받았지만, Text의 경우에는 텍스트가 들어간 경우의 사이즈가 이상적인 상한선 크기로 잡을 수 있다.</li>
      <li>그에 비해서 Color는 유연하기 때문에 채울 수 있는 만큼 Text를 채우고 남은 공간을 Color가 나눠 가지게 된다.</li>
    </ol>
  </li>
  <li>작은 크기를 제공한 케이스 (100x50)
    <ol>
      <li>3개 모두 표현하기에 충분하지 않은 사이즈가 나온 경우 3등분하게 된다. 필요에 따라서 텍스트가 줄바꿈되거나 잘리게 된다.</li>
    </ol>
  </li>
  <li>만약 극단적으로 작은 사이즈를 준다면 (40x40)
    <ol>
      <li>이 경우 사이즈를 설정할 수 없기 때문에, Text가 Container의 제안을 무시하고 이상적인 사이즈로 표시해버립니다.</li>
      <li>
        <p>대안은 .layoutPriority modifier를 적용해 내부 View 사이에 우선순위를 제공하는 것 입니다.</p>

        <p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 11.png" alt="Untitled" /></p>
      </li>
    </ol>
  </li>
</ol>

<h3 id="zstack">ZStack</h3>

<p>ZStack은 얼핏보면 overlay나 background와 동일한 역할을 할 것 같지만, overlay와 background는 ViewModifier기 때문에 하위뷰의 사이즈에 영향을 받는다. 그에 비해서 ZStack은 컨테이너기 때문에 내부의 View의 크기와 상관없이 Size를 잡게된다.</p>

<p>만약, 아래 코드를 root 에서 실행하게되면, 화면 전체를 다 가리게 된다.</p>

<h3 id="scrollview">ScrollView</h3>

<p>제안된 화면을 가득 채우게 되고, 내부 View는 contents의 사이즈에 맞춰진다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">ScrollView</span> <span class="p">{</span> 
	<span class="kt">Image</span><span class="p">(</span><span class="s">"logo"</span><span class="p">)</span>
		<span class="o">.</span><span class="nf">resizable</span><span class="p">()</span>
		<span class="o">.</span><span class="nf">aspectRatio</span><span class="p">(</span><span class="o">.</span><span class="n">fit</span><span class="p">)</span> 
	<span class="kt">Text</span><span class="p">(</span><span class="s">"This is a longer text"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>scrollView에 Shape 의 서브 뷰를 넣으면 10x10으로 표시되는 것을 볼 수 있다. 이는 Shape의 ProposedView의 기본값이 10, 10 이기 때문이다.</p>

</blockquote>

<h3 id="geometryreader"><strong>GeometryReader</strong></h3>

<p>제안받은 크기에 접근하는데 사용합니다. GeometryProxy 를 통해 제안받은 크기에 접근 할 수 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">GeometryReader</span> <span class="p">{</span> <span class="n">proxy</span> <span class="k">in</span> 
	<span class="kt">Text</span><span class="p">(</span><span class="nv">verbatim</span><span class="p">:</span> <span class="s">"</span><span class="se">\(</span><span class="n">proxy</span><span class="o">.</span><span class="n">size</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>그러나 스택 오버플로우나 다른 사이트를 볼 때 GeometryReader에서 이슈가 생겨 고통받는 경우가 많습니다. 예를 들어서 GeometryReader 를 주위에 배치하고, Text의 사이즈를 측정하려고 하는 경우 Text 주변의 레이아웃이 잘못 나오는 경우가 많이 보고됩니다.</p>

<p>GeometryReader는 꼭 필요한 경우에만 써야 하고, 다음과 같은 경우에 유용하게 사용할 수 있습니다.</p>

<ul>
  <li>GeometryReader 내부에 유연한 View를 넣는 경우 레이아웃 사이즈를 체크할 수 있습니다.
    <ul>
      <li>예를 들어서 ScrollView 안에 GeometryReader를 넣는 경우 ScrollView의 내부 View 사이즈를 알 수 있습니다.</li>
    </ul>
  </li>
  <li>background나 overlay 안에 GeometryReader를 넣으면 기본 View 크기에는 영향을 미치지 않지만 관련된 다양한 값을 읽을 수 있습니다. (고급 레이아웃 장에서 더 자세한 예를 살펴보겠습니다.)</li>
</ul>

<h3 id="list">List</h3>

<hr />

<p>List는 UIkit에서 UITableView와 동일합니다. List 자체는 제안받은 크기를 가지며, ScrollView와 유사하게 View 자체는 너비와 높이를 제안하지 않습니다.</p>

<p>행의 높이가 고정되지 않은 UITableView와 비슷하고 내부에 배치된 항목을 기준으로 내부 View의 높이를 추정합니다.</p>

<h3 id="lazyhstack-lazyvstack">LazyHStack, LazyVStack</h3>

<p>List와 동일하게 View가 보여질 때 업데이트 한다.</p>

<h3 id="lazyvgrid-lazyhgrid">LazyVGrid, LazyHGrid</h3>

<p>LazyVGrid와 LazyHGrid는 모두 동일한 기본 알고리즘을 사용하여 열이나 행의 크기를 계산하므로 이 섹션 에서는 LazyVGrid에 중점을 둘 것입니다.</p>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 12.png" alt="Untitled" /></p>

<p>그리드는 iOS 16에서 추가되었고, 17 이상에서도 아직 버그가 많기 때문에 짧게 다루고 넘어간다.</p>

<p>(가급적 쓰지 말것)</p>

<h3 id="viewthatfits"><strong>ViewThatFits</strong></h3>

<p>제안된 크기에 따라 다른 보기를 표시하려면 ViewThatFits를 사용하면 됩니다. 여러 개의 하위 뷰가 필요한 경우, 제안된 크기에 맞는 첫 번째 하위 뷰를 표시합니다. 이는 각 하위 뷰의 이상적인 크기를 파악하기 위해 nil을 제안하고, 이상적인 크기가 제안된 크기 내에 맞는 첫 번째 하위 뷰(코드에 하위 뷰가 나타나는 순서대로)를 표시합니다. 적합한 하위 뷰가 없으면 마지막 하위 뷰를 선택합니다.</p>

<h3 id="rendering-modiers"><strong>Rendering Modi!ers</strong></h3>

<p>SwiftUI에는 offset, RotationEffect, scaleEffect 등과 같이 뷰의 렌더링 방식에는 영향을 주지만 레이아웃 자체에는 영향을 미치지 않는 여러 뷰 수정자가 있습니다. 이러한 수정자는 CGContext.translate와 같은 작업을 수행한다고 생각할 수 있습니다. 이는 뷰가 그려지는 위치를 변경하지만, 레이아웃 시스템에서 보면 뷰는 여전히 원래 위치에 있습니다.</p>

<h2 id="alignment"><strong>Alignment</strong></h2>

<p>기본적으로 거의 모든 뷰는 하위 뷰의 중앙에 배치됩니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Text</span><span class="p">(</span><span class="s">"Hello"</span><span class="p">)</span>
	<span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">width</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="nv">height</span><span class="p">:</span> <span class="mi">100</span><span class="p">)</span> <span class="c1">// 기본값이 .center</span>
</code></pre></div></div>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 13.png" alt="Untitled" /></p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Text</span><span class="p">(</span><span class="s">"Hello"</span><span class="p">)</span>
	<span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">width</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="nv">height</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="nv">alignment</span><span class="p">:</span> <span class="o">.</span><span class="n">bottomTrailing</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 14.png" alt="Untitled" /></p>

<p>정렬 가이드</p>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 15.png" alt="Untitled" /></p>

<p>ZStack 역시 기본값은 .center라 아래의 경우 가운데에 쌓이게 된다.</p>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 16.png" alt="Untitled" /></p>

<h3 id="정렬-가이드-수정">정렬 가이드 수정</h3>

<p>center, bottom같은 기본 정렬 가이드라인을 수정할 수 있다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">image</span> <span class="o">=</span> <span class="kt">Image</span><span class="p">(</span><span class="nv">systemName</span><span class="p">:</span> <span class="s">"pencil.circle.!ll"</span><span class="p">)</span> 
	<span class="o">.</span><span class="nf">alignmentGuide</span><span class="p">(</span><span class="o">.</span><span class="n">firstTextBaseline</span><span class="p">,</span> <span class="nv">computeValue</span><span class="p">:</span> <span class="p">{</span> <span class="n">dimension</span> <span class="k">in</span>
		<span class="n">dimension</span><span class="o">.</span><span class="n">height</span><span class="o">/</span><span class="mi">2</span> 
	<span class="p">}</span>
<span class="p">)</span>
</code></pre></div></div>

<p>image의 .firstTextBaseline을 줄여서 Image 가 firstTextBaseline으로 정렬했더니 아래로 밀리게 된다.</p>

<p>이렇게 수정한 이미지를 적용하면 다음과 같이 가이드라인이 변경된다.</p>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 17.png" alt="Untitled" /></p>

<p>하지만 firstTextBaseline 을 수정했기 때문에 center로 설정하면 바뀌는게 없다.</p>

<p>이를 사용해 다음과 같이 범용적으로 적용 가능한 뱃지 아이콘을 만들수도 있다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="n">badge</span><span class="o">&lt;</span><span class="kt">B</span><span class="p">:</span> <span class="kt">View</span><span class="o">&gt;</span><span class="p">(</span><span class="kd">@ViewBuilder</span> <span class="n">_</span> <span class="nv">badge</span><span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">B</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="nf">overlay</span><span class="p">(</span><span class="nv">alignment</span><span class="p">:</span> <span class="o">.</span><span class="n">topTrailing</span><span class="p">)</span> <span class="p">{</span> <span class="nf">badge</span><span class="p">()</span>
                <span class="o">.</span><span class="nf">alignmentGuide</span><span class="p">(</span><span class="o">.</span><span class="n">top</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">height</span><span class="o">/</span><span class="mi">2</span> <span class="p">}</span>
		            <span class="o">.</span><span class="nf">alignmentGuide</span><span class="p">(</span><span class="o">.</span><span class="n">trailing</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span> <span class="p">}</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 18.png" alt="Untitled" /></p>]]></content><author><name>jglee</name></author><category term="uncategorized" /><summary type="html"><![CDATA[Text]]></summary></entry><entry><title type="html">Thinking in SwiftUI - 2장 State and Binding</title><link href="https://leejigun.github.io/Thinking-in-SwiftUI-2%EC%9E%A5-State-and-Binding" rel="alternate" type="text/html" title="Thinking in SwiftUI - 2장 State and Binding" /><published>2025-06-05T03:16:40+09:00</published><updated>2025-06-05T03:16:40+09:00</updated><id>https://leejigun.github.io/Thinking-in-SwiftUI---2%EC%9E%A5-State-and-Binding</id><content type="html" xml:base="https://leejigun.github.io/Thinking-in-SwiftUI-2%EC%9E%A5-State-and-Binding"><![CDATA[<ul>
  <li><a href="https://wlaxhrl.tistory.com/91">https://wlaxhrl.tistory.com/91</a></li>
</ul>

<p>(Data Flow Through SwiftUI)</p>

<p><strong>(여기서 중요한건 SSOT !!)</strong></p>

<h3 id="state"><strong>@State</strong></h3>

<hr />

<p><strong>뷰의 상태를 관리하기 위한 프로퍼티 래퍼.</strong></p>

<ul>
  <li>Value Type</li>
  <li>뷰의 로컬 데이터 (내부 프로퍼티)</li>
  <li>뷰에서 소유되고 관리되어야 하는 데이터 (ex. 텍스트필드, 토글버튼 등)</li>
</ul>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---2장-State-and-Binding/Untitled.png" alt="Untitled" /></p>

<p>Counter 예시를 살펴보면, 버튼을 누를 때마다 상태값이 변경되고 화면이 다시 그려집니다. 만약 버튼의 라벨에 상태값을 바인딩하지 않았다면, SwiftUI는 업데이트할 필요가 없다는 것을 인지하고 화면을 다시 그리지 않습니다.</p>

<h2 id="view의-생성-4단계">View의 생성 4단계</h2>

<hr />

<ol>
  <li>Counter 구조체가 처음 생성되면, View tree는 만들어지지만 아직 Render tree에 노드가 존재하지 않습니다. State라는 PropertyWrapper 역시 초기값을 할당하고 있지만, 아직 아무것도 바인딩하지 않았기 떄문에 View는 비어있습니다.</li>
</ol>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---2장-State-and-Binding/Untitled 1.png" alt="Untitled" /></p>

<ol>
  <li>SwiftUI는 Render tree에 노드를 생성하면서 State를 할당합니다. 이제 PropertyWrapper 의 메모리는 랜더 노드를 가리키게 됩니다.</li>
</ol>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---2장-State-and-Binding/Untitled 2.png" alt="Untitled" /></p>

<ol>
  <li>View의 body 부분이 실행되고, <code class="language-plaintext highlighter-rouge">Button</code>이 생성됩니다. 이제 state 값은 랜더 노드를 가리키고 있기 때문에 <code class="language-plaintext highlighter-rouge">Button</code> 의 label 값은 랜더 노드에 저장된 값을 사용합니다.</li>
</ol>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---2장-State-and-Binding/Untitled 3.png" alt="Untitled" /></p>

<ol>
  <li>마지막으로 노드의 값을 읽어 값이 설정된 view body 부분을 랜더링해 실제 UI를 만듭니다.</li>
</ol>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---2장-State-and-Binding/Untitled 4.png" alt="Untitled" /></p>

<h2 id="이벤트-발생-3단계">이벤트 발생 3단계</h2>

<hr />

<ol>
  <li>View에 이벤트가 발생하면 뷰와 연결된 랜더 트리에 전달되고, 랜더 트리를 지켜보고 있던 PropertyWrapper 쪽에 메모리가 증가합니다.</li>
  <li>State가 변경되었기 때문에 body가 다시 실행되고, View tree 가 구성됩니다.</li>
  <li>다시 구성된 View tree를 기반으로 랜더트리의 값이 변경되고, UI가 다시 랜더링됩니다.</li>
</ol>

<p>(ex) <strong>SwiftUI 프레임워크의 Button의 highlight 상태는 Button 내부에서 @State로 관리된다.</strong> 이는 터치 중일 때는 highlighted 상태로, 터치가 끝났을 때는 highlighted가 아닌 상태로 관리될 수 있기 때문에, <strong>외부에서 관리할 필요 없이 Button 내부에서만 관리</strong>하면 된다.</p>

<blockquote>
  <p>원래 @State property wrapper는 value type에만 사용했지만, iOS 17에서 Observable 매크로가 도입되면서 변경되었다. 하지만, 17 이전 OS에서는 value 타입에만 사용해야 합니다.</p>

</blockquote>

<h2 id="state-and-observable"><strong>State and Observable</strong></h2>

<hr />

<p>@State를 사용할 때 2가지 실수를 저지를 수 있습니다.</p>

<ol>
  <li>외부에서 전달받은 객체를 사용하는 경우</li>
  <li>View 전용 객체인데, @State를 사용하지 않는 경우</li>
</ol>

<p>둘 다 객체의 수명과 관련이 있습니다. 외부에서 수명이 관리되는 객체의 경우 @State를 사용하지 않는다는 것 입니다.</p>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---2장-State-and-Binding/Untitled 5.png" alt="Untitled" /></p>

<p>만약, 위와 같이 모델을 외부에서 전달받는 경우 초기값은 Button에 잘 셋팅되겠지만, 이미 View가 만들어진 상태에서 외부에서 Model의 값을 변경해도 상태 변화에 영향을 주지 못합니다.</p>

<h2 id="observableobject-protocol"><strong>ObservableObject Protocol</strong></h2>

<hr />

<p>iOS 17 이후에는 @Obserable 매크로를 사용해 편하게 사용할 수 있지만, 17 이전에는 다양안 <strong>ObservableObject Protocol</strong> 의 속성 래퍼는 사용할 수 있습니다.</p>

<ol>
  <li>@StateObject
    <ol>
      <li>@State와 거의 동일한 방식으로 동작</li>
      <li>랜더 트리에 노드가 생성될 때 초기값을 지정합니다.</li>
      <li>@State와 동일하게 private하게 사용해야 합니다. (외부에서  전답하거나, 조작하지 말것)</li>
    </ol>
  </li>
  <li>@ObservableObject
    <ol>
      <li>@StateObject 보다 간단한 구조로 초기값을 할당하지 않고 구독한 하는 관계</li>
    </ol>
  </li>
</ol>

<h2 id="observableobject"><strong>@ObservableObject</strong></h2>

<hr />

<ul>
  <li>Reference Type</li>
  <li>이미 관리(소유)하고 있는 데이터에 적용하면 좋음</li>
  <li>외부로부터의 데이터를 표현할 때</li>
</ul>

<p>case 1 : State 로 int 값을 표현할 때</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">ContentView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@State</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">rootCount</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">CountView</span><span class="p">(</span><span class="nv">rootCount</span><span class="p">:</span> <span class="n">rootCount</span><span class="p">)</span>
        <span class="kt">Button</span><span class="p">(</span><span class="nv">action</span><span class="p">:</span> <span class="p">{</span><span class="n">rootCount</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">},</span> <span class="nv">label</span><span class="p">:</span> <span class="p">{</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"Root Add"</span><span class="p">)</span>
        <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>case 2 : ObservedObject 로 모델을 표현할 때</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">CountView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@ObservedObject</span> <span class="k">var</span> <span class="nv">viewModel</span> <span class="o">=</span> <span class="kt">CountViewModel</span><span class="p">()</span>
    <span class="k">let</span> <span class="nv">rootCount</span><span class="p">:</span> <span class="kt">Int</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">VStack</span> <span class="p">{</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"Root: </span><span class="se">\(</span><span class="n">rootCount</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"Count: </span><span class="se">\(</span><span class="n">viewModel</span><span class="o">.</span><span class="n">count</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
            <span class="kt">Button</span><span class="p">(</span><span class="nv">action</span><span class="p">:</span> <span class="p">{</span><span class="n">viewModel</span><span class="o">.</span><span class="nf">addCount</span><span class="p">()},</span> <span class="nv">label</span><span class="p">:</span> <span class="p">{</span>
                <span class="kt">Text</span><span class="p">(</span><span class="s">"Counter Add"</span><span class="p">)</span>
            <span class="p">})</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="https://miro.medium.com/v2/resize:fit:302/1*6QE-DMrqDVycvuFBx0sp4g.gif" alt="" /></p>

<p>Root Add 버튼을 누를 때마다 ViewModel이 초기화되고 있었다. 그러니까 Count가 0부터 새롭게 시작하게 된다.</p>

<blockquote>
  <p>ViewModel이 View에 붙어있기 때문에 root add 버튼을 누르면 뷰가 새로 만들어지면서 ViewModel 도 교체된다.</p>

</blockquote>

<h3 id="stateobject"><strong>@StateObject</strong></h3>

<blockquote>
  <p>A state object behaves like an observed object, except that SwiftUI knows to create and manage a single object instance for a given view instance, regardless of how many times it recreates the view.</p>

</blockquote>

<p>StateObject는 ObservedObject와 거의 똑같으나, 이 StateObject는 하나의 객체로 만들어지고, View가 얼마나 초기화되든지 상관없이 별개의 객체로 관리된다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">CountView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@StateObject</span> <span class="k">var</span> <span class="nv">viewModel</span> <span class="o">=</span> <span class="kt">CountViewModel</span><span class="p">()</span>
    <span class="k">let</span> <span class="nv">rootCount</span><span class="p">:</span> <span class="kt">Int</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">VStack</span> <span class="p">{</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"Root: </span><span class="se">\(</span><span class="n">rootCount</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"Count: </span><span class="se">\(</span><span class="n">viewModel</span><span class="o">.</span><span class="n">count</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
            <span class="kt">Button</span><span class="p">(</span><span class="nv">action</span><span class="p">:</span> <span class="p">{</span><span class="n">viewModel</span><span class="o">.</span><span class="nf">addCount</span><span class="p">()},</span> <span class="nv">label</span><span class="p">:</span> <span class="p">{</span>
                <span class="kt">Text</span><span class="p">(</span><span class="s">"Counter Add"</span><span class="p">)</span>
            <span class="p">})</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="https://miro.medium.com/v2/resize:fit:302/1*8Kw64zPUp4mu4KmVMzo6fg.gif" alt="" /></p>

<p>Root Add를 눌러도 Count가 초기화되지 않는다! 기존의 데이터가 보존되는 것을 확인할 수 있다.</p>

<h3 id="stateobject-vs-observedobject">StateObject vs ObservedObject</h3>

<p>애플이 추천하는 StateObject와 ObservedObject의 사용법은 Observable Object를 처음 초기화할 때는 StateObject를 사용하고, 이미 객체화된 것을 넘겨 받을 때 ObservedObject의 사용을 추천하고 있다. </p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 직접 View에서 만들 때</span>
<span class="kd">struct</span> <span class="kt">UpperView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
  <span class="kd">@StateObject</span> <span class="k">var</span> <span class="nv">viewModel</span><span class="p">:</span> <span class="kt">ViewModel</span> <span class="o">=</span> <span class="kt">ViewModel</span><span class="p">()</span>
  <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kt">LowerView</span><span class="p">(</span><span class="nv">viewModel</span><span class="p">:</span> <span class="n">viewModel</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 외부에서 넘겨받을 때</span>
<span class="kd">struct</span> <span class="kt">LowerView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
  <span class="kd">@ObservedObject</span> <span class="k">var</span> <span class="nv">viewModel</span><span class="p">:</span> <span class="kt">ViewModel</span>
  <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kt">Text</span><span class="p">(</span><span class="s">"Hello"</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>@StateObject</strong>와 <strong>@ObservedObject</strong>는 각각의 생명주기와 사용법을 살펴보자.</p>

<ol>
  <li><strong>@StateObject</strong>:
    <ul>
      <li><strong>생명주기</strong>: <strong>@StateObject</strong>는 뷰가 생성될 때 인스턴스를 만들고, 뷰가 소멸될 때 인스턴스를 해제합니다. 뷰의 생명주기와 일치하며, 뷰가 인스턴스를 소유하고 관리합니다.</li>
      <li><strong>사용법</strong>: 주로 뷰 내에서 상태를 유지해야 하는 경우에 사용됩니다. 예를 들어, 뷰 내에서 데이터를 수정하고 해당 변경 사항을 추적해야 할 때 유용합니다.</li>
    </ul>
  </li>
  <li><strong>@ObservedObject</strong>:
    <ul>
      <li><strong>생명주기</strong>: <strong>@ObservedObject</strong>는 뷰가 생성될 때마다 새로운 인스턴스를 만듭니다. 뷰의 생명주기와는 독립적으로 동작하며, 뷰가 인스턴스를 소유하지 않습니다. 따라서 뷰가 인스턴스를 생성하고 해제하지 않습니다.</li>
      <li><strong>사용법</strong>: 다른 뷰에서 관찰하고 싶은 객체의 변경 사항을 감지할 때 사용됩니다. 주로 다른 뷰에서 생성한 인스턴스를 참조하고 싶을 때 유용합니다.</li>
    </ul>
  </li>
</ol>

<p>간단히 말하면, <strong>@StateObject</strong>는 뷰가 인스턴스를 소유하고 관리하며, <strong>@ObservedObject</strong>는 뷰가 인스턴스를 생성하지 않고 변경 사항을 감지할 때 사용됩니다. 이를 이해하면 SwiftUI에서 상태 관리를 더 효율적으로 할 수 있습니다!</p>

<h2 id="update-view-performance">Update, View Performance</h2>

<hr />

<p>앞서 본 것과 같이 State와 UI가 연결되어 자동으로 업데이트 된다. 상태가 변경된다고 전체 UI를 다시 그리는게 아니라, 특정 State와 View 사이에 종속성을 설정해 그 부분만 업데이트 되게 된다.</p>

<p>SwiftUI는 일부 State가 변경 될 때 View Tree에서 꼭 필요한 부분만 다시 랜더링되도록 많은 노력을 기울인다. 그러니 이런 노력을 방해하지 않는 방식으로 코드를 작성하는 것도 중요하다.</p>

<ol>
  <li>예를 들어 모든 State를 하나의 큰 객체 안에 넣는다면, 특정 변경으로 모든 하위의 작은 뷰를 업데이트 할 수 있다. 따라서 State를 작은 단위로 나눠서 뷰를 업데이트 하는게 성능적으로 더 도움이됩니다.</li>
  <li>실제로 필요한 값만 하위 View로 전달하는게 중요합니다. 많은 데이터를 가진 큰 객체가 있고, 이 객체를 통으로 넘겨주게 되면, 객체가 업데이트 될 때 마다 객체가 업데이트 될 수 있습니다.</li>
</ol>

<p>성능 이슈가 발생할 때 어떤 뷰의 body가 실행되는지 판단하는 몇가지 방법이 있습니다.</p>

<h3 id="1-print-삽입">1. print 삽입</h3>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---2장-State-and-Binding/Untitled 6.png" alt="Untitled" /></p>

<h3 id="2-selfprintcahnges">2. Self.printCahnges()</h3>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---2장-State-and-Binding/Untitled 7.png" alt="Untitled" /></p>

<p>print문과 다르게 재실행된 이유를 같이 호출해줍니다.</p>

<ul>
  <li>상태 변경으로 다시 호출되는 경우 ⇒ 상태 이름, 속성 표시</li>
  <li>뷰 값 자체가 변경된 경우 ⇒ 속성이 변경된 경우 @self가 기록됩니다.</li>
  <li>View의 ID 값이 변경된 경우 ⇒ @identity가 기록됩니다. (일반적으로 새로 삽입된 경우)</li>
</ul>

<h3 id="3-instruments">3. instruments</h3>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---2장-State-and-Binding/Untitled 8.png" alt="Untitled" /></p>

<h3 id="observable-매크로"><strong>Observable 매크로</strong></h3>

<hr />

<p><a href="https://developer.apple.com/documentation/Observation">Observation</a>을 통해 SwiftUI는 observable data model 에 의존성을 형성하고 data 가 변할때마다 UI 를 업데이트 합니다.</p>

<h3 id="기존-observableobject-와-달라지는-것들"><strong>기존 ObservableObject 와 달라지는 것들</strong></h3>

<p><strong>첫번째: 코드가 간결해짐</strong></p>

<p>| <strong>AS-IS</strong> | <strong>TO-BE</strong> |
| — | — |
| final class Book: ObservableObject {
    @Published var title = “Sample Book Title”
    var isAvailable = true
}</p>

<p>struct BookView: View {
    @ObservedObject var book: Book
    
    var body: some View {
        Text(book.title)
    }
} | @Observable final class Book {
    var title = “Sample Book Title”
    var isAvailable = true
}</p>

<p>struct BookView: View {
    var book: Book
    
    var body: some View {
        Text(book.title)
    }
} |</p>

<p><strong>두번째: 뷰 업데이트 매커니즘이 좀 더 효율적으로 바뀜</strong></p>

<p>@Observable 매크로를 쓰면</p>

<p>뷰의 body 에서 프로퍼티를 직접 읽어야지만 뷰 업데이트가 된다.</p>

<p>ObservableObject에서는 published 프로퍼티가 변하면 뷰가 해당 프로퍼티를 읽고 있지 않아도 다시 그려진다.</p>

<p><strong>세번째: data model object 를 optional로 들고 있을 수 있다.</strong></p>

<p><strong>네번째: data model objects를 collection으로도 가능하다.</strong></p>

<p><a href="https://eunjin3786.tistory.com/580"><strong>https://eunjin3786.tistory.com/580</strong></a></p>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---2장-State-and-Binding/Untitled 9.png" alt="Untitled" /></p>

<ul>
  <li>매크로 기능은 iOS 17 이상</li>
</ul>

<p>새로운 매크로 기반 객체 관찰 모델은 <strong>편리한 구문</strong>을 도입하고, 뷰와 관찰 가능한 객체 간의 종속성이 형성되는 방식을 변경합니다. 이전 속성 래퍼를 사용할 때, SwiftUI는 <code class="language-plaintext highlighter-rouge">@StateObject</code>의 <code class="language-plaintext highlighter-rouge">objectWillChange</code> 게시자를 맹목적으로 구독하거나, <code class="language-plaintext highlighter-rouge">@ObservedObject</code>를 뷰에서 선언했습니다.</p>

<p>새로운 <code class="language-plaintext highlighter-rouge">Observable</code> 매크로를 사용하면, <code class="language-plaintext highlighter-rouge">Observable</code>의 모든 속성이 뷰 본문에서 접근하는 객체는 객체가 어디에서 왔는지에 관계없이 이 뷰에 대한 종속성을 형성합니다.</p>

<p><strong>이 새로운 모델은 훨씬 더 간결하고 효율적입니다.</strong> 예를 들어, 뷰 본문에서 전역 <strong>싱글톤(관찰 가능)</strong>에 액세스할 경우, <code class="language-plaintext highlighter-rouge">@ObservedObject</code>를 사용하여 싱글톤을 뷰에 전달할 필요 없이, 액세스된 속성과 뷰 사이에 자동으로 종속성이 형성됩니다. 관찰 가능한 객체는 옵션, 배열 또는 다른 컬렉션에 중첩될 수 있으며, 속성 수준 추적으로 인해 관찰 및 뷰 업데이트가 예상대로 계속 작동합니다.</p>

<p>또한, 뷰 본문에서 객체의 속성 하나만 사용하는 경우, 다른 속성이 변경되어도 이 뷰는 다시 그려지지 않습니다. 모델 객체를 사용하지 않는 경우(예: 코드의 한 분기에만 존재하는 경우), 모델은 전혀 관찰되지 않습니다. 이를 통해 불필요한 뷰 업데이트를 줄여 성능을 향상시킬 수 있습니다. 이전에는 모델 객체를 수동으로 분할하여 더 세분화된 뷰 업데이트를 얻었습니다.</p>]]></content><author><name>jglee</name></author><category term="swiftui" /><category term="ios" /><summary type="html"><![CDATA[https://wlaxhrl.tistory.com/91]]></summary></entry><entry><title type="html">Thinking in SwiftUI - 1장 View Trees</title><link href="https://leejigun.github.io/Thinking-in-SwiftUI-1%EC%9E%A5-View-Trees" rel="alternate" type="text/html" title="Thinking in SwiftUI - 1장 View Trees" /><published>2025-06-05T03:16:30+09:00</published><updated>2025-06-05T03:16:30+09:00</updated><id>https://leejigun.github.io/Thinking-in-SwiftUI---1%EC%9E%A5-View-Trees</id><content type="html" xml:base="https://leejigun.github.io/Thinking-in-SwiftUI-1%EC%9E%A5-View-Trees"><![CDATA[<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---1장-View-Trees/Untitled.png" alt="Untitled" /></p>

<p>위와 같은 코드를 작성하면, 중앙에 일시적인 청사진이 구축되며, 이를 ‘View Tree’라고 합니다. 그 결과, 왼쪽처럼 View가 렌더링되어 보여집니다.</p>

<p>뷰 트리를 살펴보면, 트리는 역순으로 그려집니다. ‘<code class="language-plaintext highlighter-rouge">background</code>‘는 트리의 최상단에 위치하지만, 실제로는 아무것도 그리지 않고, ‘<code class="language-plaintext highlighter-rouge">Text</code>’ 뒤쪽에 위치하게 됩니다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">View Tree</code>: 일시적인 인스턴스로 뷰를 구성하는 청사진</li>
</ul>

<p>만약, 아래와 같이 순서를 변경하게 된다면</p>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---1장-View-Trees/Untitled 1.png" alt="Untitled" /></p>

<p><code class="language-plaintext highlighter-rouge">background</code>는 <code class="language-plaintext highlighter-rouge">padding</code>의 자식이 되며, <code class="language-plaintext highlighter-rouge">Text</code>에 <code class="language-plaintext highlighter-rouge">background</code>이 붙게 됩니다. 그러면 <code class="language-plaintext highlighter-rouge">background</code>에 <code class="language-plaintext highlighter-rouge">padding</code>이 붙어서 다음과 같은 모습이 됩니다.</p>

<h2 id="viewbuilders"><strong>ViewBuilders</strong></h2>

<hr />

<p>SwiftUI는 ‘<strong>뷰 빌더(ViewBuilder)</strong>‘라는 특별한 구문을 이용해 뷰 목록을 구성합니다. 뷰 빌더는 이 목적을 위해 Swift 언어에 추가된 결과 빌더 기능을 기반으로 만들어졌습니다. 예를 들어, 이미지를 텍스트 옆에 표시하는 뷰를 구성하는 방법은 다음과 같습니다.</p>

<p>(뷰 빌더는 <code class="language-plaintext highlighter-rouge">ResultBuilder</code> 피처의 위에 구현되었다)</p>

<ul>
  <li><a href="https://minsone.github.io/swift-resultbuilder">https://minsone.github.io/swift-resultbuilder</a></li>
  <li><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0289-result-builders.md">https://github.com/apple/swift-evolution/blob/main/proposals/0289-result-builders.md</a></li>
</ul>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---1장-View-Trees/Untitled 2.png" alt="Untitled" /></p>

<p><strong><code class="language-plaintext highlighter-rouge">HStack</code></strong>은 클로저를 매개변수로 사용하며, 이 클로저는 <strong><code class="language-plaintext highlighter-rouge">@ViewBuilder</code></strong>로 표시됩니다. 이를 통해 내부에 여러 표현식을 작성할 수 있으며, 각 표현식은 뷰를 나타냅니다. 본질적으로 스택에 전달된 클로저는 이 예제에서 스택의 하위 뷰가 되는 뷰 목록을 생성합니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">ViewBuilder</span> <span class="p">{</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">func</span> <span class="n">buildBlock</span><span class="o">&lt;</span><span class="kt">C0</span><span class="p">,</span> <span class="kt">C1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">c0</span><span class="p">:</span> <span class="kt">C0</span><span class="p">,</span> <span class="n">_</span> <span class="nv">c1</span><span class="p">:</span> <span class="kt">C1</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="kt">TupleView</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">C0</span><span class="p">,</span> <span class="kt">C1</span><span class="p">)</span><span class="o">&gt;</span> <span class="k">where</span> <span class="kt">C0</span> <span class="p">:</span> <span class="kt">View</span><span class="p">,</span> <span class="kt">C1</span> <span class="p">:</span> <span class="kt">View</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위 예제의 스택에는 내부에 <strong>두 개의 뷰 표현식</strong>이 있으므로 두 개의 매개변수가 있는 뷰 빌더의 <strong><code class="language-plaintext highlighter-rouge">buildBlock</code></strong> 메소드가 호 출됩니다. 반환 유형에서 볼 수 있듯이 이는 이미지와 텍스트라는 두 가지 보기를 래핑하는 <strong><code class="language-plaintext highlighter-rouge">TupleView</code></strong>를 구성합니다. 뷰 빌더 를 뷰 목록을 나타내는 <strong><code class="language-plaintext highlighter-rouge">TupleView</code></strong>를 구성하는 메커니즘으로 생각할 수 있습니다.</p>

<p><strong>하위 뷰를 구성하는 뷰 컴포넌트</strong> (암시적으로 <code class="language-plaintext highlighter-rouge">@ViewBuilder</code>로 표시)</p>

<ul>
  <li>스택, 그리드 등과 같은 <strong>모든 컨테이너 뷰</strong></li>
  <li><code class="language-plaintext highlighter-rouge">background</code>, <code class="language-plaintext highlighter-rouge">overlay</code>..</li>
</ul>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---1장-View-Trees/Untitled 3.png" alt="Untitled" /></p>

<ul>
  <li><a href="https://zeddios.tistory.com/m/1366">https://zeddios.tistory.com/m/1366</a></li>
</ul>

<h2 id="dynamic-content-동적-컨텐츠"><strong>Dynamic Content (동적 컨텐츠)</strong></h2>

<hr />

<p>SwiftUI 코드를 작성하고 ViewBuilder를 통해서 View 목록을 작성하는데, 이 때 View 목록도 동적일 수 있습니다. if - else 구문을 통해서 뷰를 동적으로 구성하는 방법은 아래와 같습니다.</p>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---1장-View-Trees/Untitled 4.png" alt="Untitled" /></p>

<p>if 문 대신, if let, switch 문도 사용 가능합니다.</p>

<h2 id="render-trees">Render Trees</h2>

<hr />

<p>View Tree는 일시적으로 만들어지는 청사진의 역할을 하는 반면에, Render Tree는 더 긴 수명으로 계속 머무르다가 상태가 바뀌면 현재 상태를 반영하도록 업데이트 하는 역할을 합니다.</p>

<p>랜더 트리는 SwiftUI 내부에 존재하기 때문에, 직접 다룰일은 없습니다. 하지만, SwiftUI의 동작을 이해하는데 유용한 모델입니다.</p>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---1장-View-Trees/Untitled 5.png" alt="Untitled" /></p>

<p>만약 옵셔널한 View 구조가 있다면, View Tree에서는 다음과 같이 생성됩니다.</p>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---1장-View-Trees/Untitled 6.png" alt="Untitled" /></p>

<p>하지만, Render Tree의 경우에는 다릅니다. Text가 nil일 경우 View Tree가 Render Tree를 만들 땐 실제로 View에 대응되도록 HStack 안에 Image 하나만 존재합니다.</p>

<p>만약에 State가 업데이트되서 View 업데이트가 동작하게 된다면, Render Tree에 Text가 삽입되거나, 제거됩니다. (하지만, Text의 문구가 변경어도 Text View가 새로 만들어지는 건 아닙니다.)</p>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---1장-View-Trees/Untitled 7.png" alt="Untitled" /></p>

<h2 id="lifetime">LifeTime</h2>

<hr />

<p>위에서 언급했듯이 View Tree는 일시적인 청사진의 역할을 합니다. 따라서 View의 수명(Life Time)과는 관계가 없습니다. 하지만 Render Tree는 처음 랜더링 된 시점부터 View가 더 이상 표시되지 않을 때 까지 수명을 가집니다. 다만, Render Treedml 수명은 화면상의 UI와 동일하지 않습니다.</p>

<p>만약, 스크롤 뷰 안에 큰 VStack이 있고 많은 View를 랜더링하는 경우 화면에 View가 보이는 여뷰랑 상관없이 모든 VStack의 하위 뷰 노드가 만들어집니다.</p>

<p>VStack은 LazyStack과 달리 바로 바쁘게 랜더링을 시작합니다. 그렇다고 LazyStack을 사용한다고 바로 바로 화면에서 보이지 않는다고 해제되는 건 아닙니다. 생성되는 시점이 늦어질 뿐 화면을 벗어나도 Render 노드가 유지됩니다.</p>

<p>(자세한 내용은 상태(State)에 대한 파트에서 다룰 예정입니다. 중요한건 렌더 트리의 노드를 통제할 수 없다는 것 입니다.)</p>

<p>SwiftUI에서는 실용적인 사용을 위해서 View의 LifeTime을 체크할 수 있도록 3가지 인터페이스 터널을 제공합니다.</p>

<ol>
  <li>onAppear
    <ol>
      <li>뷰가 화면에 나타날 때마다 실행됩니다. Render Tree의 노드가 생산될 때 호출되는게 아니라, View가 화면에 노출될 때마다 실행되기 때문에 여러번 호출할 수 있습니다. 예를들어서 LazyVStack 또는 List의 뷰가 스크롤을 통해 화면 밖으로 나갔다가 다시 돌아올 경우에도 매번 onAppear가 호출됩니다.</li>
      <li>TabView에서 탭을 전환할 때 역시 매번 호출됩니다.</li>
    </ol>
  </li>
  <li>onDisappear
    <ol>
      <li>화면에서 뷰가 사라질 때 호출됩니다. onAppear와 동일한 규칙으로 여러번 호출될 수 있습니다.</li>
    </ol>
  </li>
  <li>task
    <ol>
      <li>비동기 작업에 사용되는 onAppear와 onDisappear 두가지의 조합입니다. 이 task modifier는 onAppear가 호출되는 시점에 작업을 생성하고, onDisappear가 호출되는 시점에 작업을 취소합니다.</li>
    </ol>
  </li>
</ol>

<p>View의 id가 유지되는 동안은 값이 변경되어도 SwiftUI 관점에서의 View는 동일합니다.</p>

<p>State, ObservedObject는 View의 id와 연결된 저장소입니다. View의 lifetime 동안 body가 재계산되더라도 저장소의 메모리를 유지합니다.</p>

<p>View의 id가 변경되면 새로운 View로 간주되며 이전 View는 메모리에서 해제됩니다.</p>

<p>SwiftUI에서 View의 lifetime과 State의 lifetime은 동일한 의미를 갖습니다.</p>

<h2 id="identity-식별성"><strong>Identity (식별성)</strong></h2>

<hr />

<p>만약 작성한 코드에서 View의 ID값을 할당하지 않는다면, View Tree에서 생성될 View마다 고유 ID 값을 할당합니다. 이렇게 자동으로 할당되는 ID를 암시적 ID라 합니다. 이 ID 값을 통해서 뷰를 식별할 수 있고 ID가 동일할 경우 View를 새로 만드는게 아닌, 상태값을 업데이트 합니다.</p>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---1장-View-Trees/Untitled 8.png" alt="Untitled" /></p>

<p>특이한 부분은 if else  브랜치에서 1이라는 동일한 ID 값 아래에 다른 ID값을 가진다는 것 입니다. 따라서 동일한 양쪽 다 동일한 Text를 사용하고 있지만, 다른 ID값을 가지고 있어 condition이 변경되면 새로 View를 만들어 추가하게 됩니다.</p>

<p>View Tree에서의 암시적인 ID 할당이 아닌, 명시적으로 ID 값을 할당할 수도 있습니다. 주로 ForEach를 통해 반복적인 View를 생성하고 해당 View의 상태를 업데이트 하기 위해서 명시적으로 ID를 지정합니다.</p>

<p>ID는 Hashable 값을 사용할 수 있습니다.</p>

<p>아래의 경우 true, false 값을 ID로 사용해 2개의 Text를 번갈아 추가 삭제 할 수 있습니다.</p>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---1장-View-Trees/Untitled 9.png" alt="Untitled" /></p>

<ul>
  <li>Explicit id는 <strong><code class="language-plaintext highlighter-rouge">.id(_:)</code></strong> 메서드를 사용하여 명시적으로 지정할 수 있습니다.</li>
</ul>

<p>그렇다면, 다음과 같이 하나의 Text를 만들어서 2번 사용하는 경우 ID값이 어떻게 될까?</p>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---1장-View-Trees/Untitled 10.png" alt="Untitled" /></p>

<p>View Tree에 표시된 것 처럼 다른 위치에 있기 때문에 View Tree에서 서로 다른 암시적인 ID값을 할당하고 별도의 뷰로 간주됩니다. 이 부분 때문에 View Tree를 청사진이라 생각할 수 있는 것 입니다.</p>

<p>다음으로 만약에 이런 condition에 따라 분기하는 applayIf 를 만들고 적용하면 어떻게 될까?</p>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---1장-View-Trees/Untitled 11.png" alt="Untitled" /></p>

<p>적용한 코드 샘플을 보면 if else 형태로 하이라이트가 들어가면 background 모디파이어를 추가하는 형태로 구현하고 View Tree 역시 if else 형태와 유사한 모습을 보이고 있다.</p>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---1장-View-Trees/Untitled 12.png" alt="Untitled" /></p>

<p>이 경우 동일하게 Text는 변함이 없지만, 불필요하게 2개의 Text가 condition에 따라서 생성, 제거되는 모습을 볼 수 있다. 이런 패턴이 아닌 아래와 같은 패턴을 사용하는게 좋다.</p>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---1장-View-Trees/Untitled 13.png" alt="Untitled" /></p>

<p>이 경우 if else 의 값에 따라서 상태값을 변경해 랜더 노드를 추가, 삭제하지 않는다.</p>

<h2 id="view의-life-time-단계">View의 Life Time 단계</h2>

<hr />

<h3 id="1-appearing">1. Appearing</h3>

<ol>
  <li>스테이트 구독 (State, <strong>ObservedObject</strong>)</li>
  <li>body 계산, 스테이트 연결</li>
  <li>body 처음 호출</li>
  <li><strong>뷰 그래프</strong> 업데이트, UI 그리기</li>
  <li><strong>onAppear는 top-down으로 실행됨</strong></li>
</ol>

<h3 id="2-updating">2. Updating</h3>

<ol>
  <li>스테이트 변경 또는 publisher 구독으로 유저 액션 발생</li>
  <li>이전 스냅샷과 뷰 계층 비교</li>
  <li>변경된 뷰를 무력화한다</li>
  <li>뷰 그래프 업데이트하고 무력화된 뷰를 그림. 모든 업데이트 플로우는 뷰 계층을 타고 내려옴</li>
</ol>

<h3 id="3-disappearing">3. Disappearing</h3>

<ol>
  <li>뷰 계층에서 제거되고 호출. top-down으로 실행</li>
  <li>View가 화면에서 사라질 때 발생합니다.</li>
  <li>이 단계에서는 View의 정리(clean-up) 작업이 이루어집니다.</li>
  <li>예를 들어, <strong><code class="language-plaintext highlighter-rouge">onDisappear</code></strong> modifier를 사용하여 Disappearing 단계에서 리소스를 해제하거나 데이터를 저장할 수 있습니다.</li>
</ol>

<p><a href="https://www.vadimbulavin.com/swiftui-view-lifecycle/">https://www.vadimbulavin.com/swiftui-view-lifecycle/</a></p>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---1장-View-Trees/Untitled 14.png" alt="Untitled" /></p>]]></content><author><name>jglee</name></author><category term="swiftui" /><category term="ios" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Thinking in SwiftUI - 2장 State and Binding</title><link href="https://leejigun.github.io/Thinking-in-SwiftUI-2%EC%9E%A5-State-and-Binding" rel="alternate" type="text/html" title="Thinking in SwiftUI - 2장 State and Binding" /><published>2024-05-27T04:47:00+09:00</published><updated>2024-05-27T04:47:00+09:00</updated><id>https://leejigun.github.io/Thinking-in-SwiftUI---2%EC%9E%A5-State-and-Binding</id><content type="html" xml:base="https://leejigun.github.io/Thinking-in-SwiftUI-2%EC%9E%A5-State-and-Binding"><![CDATA[<h1 id="thinking-in-swiftui---2장-state-and-binding">Thinking in SwiftUI - 2장 State and Binding</h1>

<p>Created: 2024년 5월 26일 오후 7:47
Tags: SwiftUI, iOS</p>

<p>이전 장에서 SwiftUI code가 <strong>View tree</strong>라는 청사진(블루프린트) 로 구성되는 방법과 영구 <strong>Render tree</strong>로 변환되는 방법에 대해서 알아보았습니다. 이번 장에서는 상태 기반으로 View tree를 구성하고 Render tree를 업데이트 하는 방법을 살펴봅니다.</p>

<p>일반적으로 뷰의 업데이트 주기는 다음과 같습니다.</p>

<ol>
  <li>상태를 기반으로 View Tree가 구성됩니다.</li>
  <li>현재 View Tree를 기반으로 Render Tree가 노드를 생성, 제거, 업데이트 합니다.</li>
  <li>이벤트가 발생해 상태가 변경됩니다.</li>
  <li>1번부터 3번까지 반복합니다.</li>
</ol>

<p>SwiftUI가 상태를 지속적으로 관찰하고 있기 때문에 언제 View tree가 다시 생성되는지, Render tree가 업데이트 되는지, 뷰의 무엇을 업데이트 해야 하는지 걱정할 필요가 없습니다. 다만, 너무 지나치게 광범위한 View 업데이트는 성능 이슈가 발생할 수 있고, 이번 장의 뒷 부분에서 다시 알아보겠습니다.</p>

<p>SwiftUI의 핵심이라고 할 수 있는 <strong>Property Wrapper</strong>에 대한 내용입니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>프로퍼티 래퍼는 속성에 적용되는 래퍼(Wrapper)로, 속성의 값에 추가적인 로직을 적용하거나, 값이 변경될 때 다른 동작을 수행할 수 있도록 해준다.
</code></pre></div></div>

<ul>
  <li><strong>@State, @Binding, @StateObject, @ObservedObject, @EnvironmentObject</strong> 등</li>
</ul>

<h2 id="data-flow-through-swiftui"><strong>Data Flow Through SwiftUI</strong></h2>

<hr />

<ul>
  <li><a href="https://wlaxhrl.tistory.com/91">https://wlaxhrl.tistory.com/91</a></li>
</ul>

<p>(Data Flow Through SwiftUI)</p>

<p><strong>(여기서 중요한건 SSOT !!)</strong></p>

<h3 id="state"><strong>@State</strong></h3>

<hr />

<p><strong>뷰의 상태를 관리하기 위한 프로퍼티 래퍼.</strong></p>

<ul>
  <li>Value Type</li>
  <li>뷰의 로컬 데이터 (내부 프로퍼티)</li>
  <li>뷰에서 소유되고 관리되어야 하는 데이터 (ex. 텍스트필드, 토글버튼 등)</li>
</ul>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/2/Untitled.png" alt="Untitled" /></p>

<p>Counter 예시를 살펴보면, 버튼을 누를 때마다 상태값이 변경되고 화면이 다시 그려집니다. 만약 버튼의 라벨에 상태값을 바인딩하지 않았다면, SwiftUI는 업데이트할 필요가 없다는 것을 인지하고 화면을 다시 그리지 않습니다.</p>

<h2 id="view의-생성-4단계">View의 생성 4단계</h2>

<hr />

<ol>
  <li>Counter 구조체가 처음 생성되면, View tree는 만들어지지만 아직 Render tree에 노드가 존재하지 않습니다. State라는 PropertyWrapper 역시 초기값을 할당하고 있지만, 아직 아무것도 바인딩하지 않았기 떄문에 View는 비어있습니다.</li>
</ol>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/2/Untitled 1.png" alt="Untitled" /></p>

<ol>
  <li>SwiftUI는 Render tree에 노드를 생성하면서 State를 할당합니다. 이제 PropertyWrapper 의 메모리는 랜더 노드를 가리키게 됩니다.</li>
</ol>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/2/Untitled 2.png" alt="Untitled" /></p>

<ol>
  <li>View의 body 부분이 실행되고, <code class="language-plaintext highlighter-rouge">Button</code>이 생성됩니다. 이제 state 값은 랜더 노드를 가리키고 있기 때문에 <code class="language-plaintext highlighter-rouge">Button</code> 의 label 값은 랜더 노드에 저장된 값을 사용합니다.</li>
</ol>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/2/Untitled 3.png" alt="Untitled" /></p>

<ol>
  <li>마지막으로 노드의 값을 읽어 값이 설정된 view body 부분을 랜더링해 실제 UI를 만듭니다.</li>
</ol>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/2/Untitled 4.png" alt="Untitled" /></p>

<h2 id="이벤트-발생-3단계">이벤트 발생 3단계</h2>

<hr />

<ol>
  <li>View에 이벤트가 발생하면 뷰와 연결된 랜더 트리에 전달되고, 랜더 트리를 지켜보고 있던 PropertyWrapper 쪽에 메모리가 증가합니다.</li>
  <li>State가 변경되었기 때문에 body가 다시 실행되고, View tree 가 구성됩니다.</li>
  <li>다시 구성된 View tree를 기반으로 랜더트리의 값이 변경되고, UI가 다시 랜더링됩니다.</li>
</ol>

<p>(ex) <strong>SwiftUI 프레임워크의 Button의 highlight 상태는 Button 내부에서 @State로 관리된다.</strong> 이는 터치 중일 때는 highlighted 상태로, 터치가 끝났을 때는 highlighted가 아닌 상태로 관리될 수 있기 때문에, <strong>외부에서 관리할 필요 없이 Button 내부에서만 관리</strong>하면 된다.</p>

<blockquote>
  <p>원래 @State property wrapper는 value type에만 사용했지만, iOS 17에서 Observable 매크로가 도입되면서 변경되었다. 하지만, 17 이전 OS에서는 value 타입에만 사용해야 합니다.</p>

</blockquote>

<h2 id="state-and-observable"><strong>State and Observable</strong></h2>

<hr />

<p>@State를 사용할 때 2가지 실수를 저지를 수 있습니다.</p>

<ol>
  <li>외부에서 전달받은 객체를 사용하는 경우</li>
  <li>View 전용 객체인데, @State를 사용하지 않는 경우</li>
</ol>

<p>둘 다 객체의 수명과 관련이 있습니다. 외부에서 수명이 관리되는 객체의 경우 @State를 사용하지 않는다는 것 입니다.</p>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/2/Untitled 5.png" alt="Untitled" /></p>

<p>만약, 위와 같이 모델을 외부에서 전달받는 경우 초기값은 Button에 잘 셋팅되겠지만, 이미 View가 만들어진 상태에서 외부에서 Model의 값을 변경해도 상태 변화에 영향을 주지 못합니다.</p>

<h2 id="observableobject-protocol"><strong>ObservableObject Protocol</strong></h2>

<hr />

<p>iOS 17 이후에는 @Obserable 매크로를 사용해 편하게 사용할 수 있지만, 17 이전에는 다양안 <strong>ObservableObject Protocol</strong> 의 속성 래퍼는 사용할 수 있습니다.</p>

<ol>
  <li>@StateObject
    <ol>
      <li>@State와 거의 동일한 방식으로 동작</li>
      <li>랜더 트리에 노드가 생성될 때 초기값을 지정합니다.</li>
      <li>@State와 동일하게 private하게 사용해야 합니다. (외부에서  전답하거나, 조작하지 말것)</li>
    </ol>
  </li>
  <li>@ObservableObject
    <ol>
      <li>@StateObject 보다 간단한 구조로 초기값을 할당하지 않고 구독한 하는 관계</li>
    </ol>
  </li>
</ol>

<h2 id="observableobject"><strong>@ObservableObject</strong></h2>

<hr />

<ul>
  <li>Reference Type</li>
  <li>이미 관리(소유)하고 있는 데이터에 적용하면 좋음</li>
  <li>외부로부터의 데이터를 표현할 때</li>
</ul>

<p>case 1 : State 로 int 값을 표현할 때</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">ContentView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@State</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">rootCount</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">CountView</span><span class="p">(</span><span class="nv">rootCount</span><span class="p">:</span> <span class="n">rootCount</span><span class="p">)</span>
        <span class="kt">Button</span><span class="p">(</span><span class="nv">action</span><span class="p">:</span> <span class="p">{</span><span class="n">rootCount</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">},</span> <span class="nv">label</span><span class="p">:</span> <span class="p">{</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"Root Add"</span><span class="p">)</span>
        <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>case 2 : ObservedObject 로 모델을 표현할 때</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">CountView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@ObservedObject</span> <span class="k">var</span> <span class="nv">viewModel</span> <span class="o">=</span> <span class="kt">CountViewModel</span><span class="p">()</span>
    <span class="k">let</span> <span class="nv">rootCount</span><span class="p">:</span> <span class="kt">Int</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">VStack</span> <span class="p">{</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"Root: </span><span class="se">\(</span><span class="n">rootCount</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"Count: </span><span class="se">\(</span><span class="n">viewModel</span><span class="o">.</span><span class="n">count</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
            <span class="kt">Button</span><span class="p">(</span><span class="nv">action</span><span class="p">:</span> <span class="p">{</span><span class="n">viewModel</span><span class="o">.</span><span class="nf">addCount</span><span class="p">()},</span> <span class="nv">label</span><span class="p">:</span> <span class="p">{</span>
                <span class="kt">Text</span><span class="p">(</span><span class="s">"Counter Add"</span><span class="p">)</span>
            <span class="p">})</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="https://miro.medium.com/v2/resize:fit:302/1*6QE-DMrqDVycvuFBx0sp4g.gif" alt="" /></p>

<p>Root Add 버튼을 누를 때마다 ViewModel이 초기화되고 있었다. 그러니까 Count가 0부터 새롭게 시작하게 된다.</p>

<blockquote>
  <p>ViewModel이 View에 붙어있기 때문에 root add 버튼을 누르면 뷰가 새로 만들어지면서 ViewModel 도 교체된다.</p>

</blockquote>

<h3 id="stateobject"><strong>@StateObject</strong></h3>

<blockquote>
  <p>A state object behaves like an observed object, except that SwiftUI knows to create and manage a single object instance for a given view instance, regardless of how many times it recreates the view.</p>

</blockquote>

<p>StateObject는 ObservedObject와 거의 똑같으나, 이 StateObject는 하나의 객체로 만들어지고, View가 얼마나 초기화되든지 상관없이 별개의 객체로 관리된다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">CountView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@StateObject</span> <span class="k">var</span> <span class="nv">viewModel</span> <span class="o">=</span> <span class="kt">CountViewModel</span><span class="p">()</span>
    <span class="k">let</span> <span class="nv">rootCount</span><span class="p">:</span> <span class="kt">Int</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">VStack</span> <span class="p">{</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"Root: </span><span class="se">\(</span><span class="n">rootCount</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"Count: </span><span class="se">\(</span><span class="n">viewModel</span><span class="o">.</span><span class="n">count</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
            <span class="kt">Button</span><span class="p">(</span><span class="nv">action</span><span class="p">:</span> <span class="p">{</span><span class="n">viewModel</span><span class="o">.</span><span class="nf">addCount</span><span class="p">()},</span> <span class="nv">label</span><span class="p">:</span> <span class="p">{</span>
                <span class="kt">Text</span><span class="p">(</span><span class="s">"Counter Add"</span><span class="p">)</span>
            <span class="p">})</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="https://miro.medium.com/v2/resize:fit:302/1*8Kw64zPUp4mu4KmVMzo6fg.gif" alt="" /></p>

<p>Root Add를 눌러도 Count가 초기화되지 않는다! 기존의 데이터가 보존되는 것을 확인할 수 있다.</p>

<h3 id="stateobject-vs-observedobject">StateObject vs ObservedObject</h3>

<p>애플이 추천하는 StateObject와 ObservedObject의 사용법은 Observable Object를 처음 초기화할 때는 StateObject를 사용하고, 이미 객체화된 것을 넘겨 받을 때 ObservedObject의 사용을 추천하고 있다. </p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 직접 View에서 만들 때</span>
<span class="kd">struct</span> <span class="kt">UpperView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
  <span class="kd">@StateObject</span> <span class="k">var</span> <span class="nv">viewModel</span><span class="p">:</span> <span class="kt">ViewModel</span> <span class="o">=</span> <span class="kt">ViewModel</span><span class="p">()</span>
  <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kt">LowerView</span><span class="p">(</span><span class="nv">viewModel</span><span class="p">:</span> <span class="n">viewModel</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 외부에서 넘겨받을 때</span>
<span class="kd">struct</span> <span class="kt">LowerView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
  <span class="kd">@ObservedObject</span> <span class="k">var</span> <span class="nv">viewModel</span><span class="p">:</span> <span class="kt">ViewModel</span>
  <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kt">Text</span><span class="p">(</span><span class="s">"Hello"</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>@StateObject</strong>와 <strong>@ObservedObject</strong>는 각각의 생명주기와 사용법을 살펴보자.</p>

<ol>
  <li><strong>@StateObject</strong>:
    <ul>
      <li><strong>생명주기</strong>: <strong>@StateObject</strong>는 뷰가 생성될 때 인스턴스를 만들고, 뷰가 소멸될 때 인스턴스를 해제합니다. 뷰의 생명주기와 일치하며, 뷰가 인스턴스를 소유하고 관리합니다.</li>
      <li><strong>사용법</strong>: 주로 뷰 내에서 상태를 유지해야 하는 경우에 사용됩니다. 예를 들어, 뷰 내에서 데이터를 수정하고 해당 변경 사항을 추적해야 할 때 유용합니다.</li>
    </ul>
  </li>
  <li><strong>@ObservedObject</strong>:
    <ul>
      <li><strong>생명주기</strong>: <strong>@ObservedObject</strong>는 뷰가 생성될 때마다 새로운 인스턴스를 만듭니다. 뷰의 생명주기와는 독립적으로 동작하며, 뷰가 인스턴스를 소유하지 않습니다. 따라서 뷰가 인스턴스를 생성하고 해제하지 않습니다.</li>
      <li><strong>사용법</strong>: 다른 뷰에서 관찰하고 싶은 객체의 변경 사항을 감지할 때 사용됩니다. 주로 다른 뷰에서 생성한 인스턴스를 참조하고 싶을 때 유용합니다.</li>
    </ul>
  </li>
</ol>

<p>간단히 말하면, <strong>@StateObject</strong>는 뷰가 인스턴스를 소유하고 관리하며, <strong>@ObservedObject</strong>는 뷰가 인스턴스를 생성하지 않고 변경 사항을 감지할 때 사용됩니다. 이를 이해하면 SwiftUI에서 상태 관리를 더 효율적으로 할 수 있습니다!</p>

<h2 id="update-view-performance">Update, View Performance</h2>

<hr />

<p>앞서 본 것과 같이 State와 UI가 연결되어 자동으로 업데이트 된다. 상태가 변경된다고 전체 UI를 다시 그리는게 아니라, 특정 State와 View 사이에 종속성을 설정해 그 부분만 업데이트 되게 된다.</p>

<p>SwiftUI는 일부 State가 변경 될 때 View Tree에서 꼭 필요한 부분만 다시 랜더링되도록 많은 노력을 기울인다. 그러니 이런 노력을 방해하지 않는 방식으로 코드를 작성하는 것도 중요하다.</p>

<ol>
  <li>예를 들어 모든 State를 하나의 큰 객체 안에 넣는다면, 특정 변경으로 모든 하위의 작은 뷰를 업데이트 할 수 있다. 따라서 State를 작은 단위로 나눠서 뷰를 업데이트 하는게 성능적으로 더 도움이됩니다.</li>
  <li>실제로 필요한 값만 하위 View로 전달하는게 중요합니다. 많은 데이터를 가진 큰 객체가 있고, 이 객체를 통으로 넘겨주게 되면, 객체가 업데이트 될 때 마다 객체가 업데이트 될 수 있습니다.</li>
</ol>

<p>성능 이슈가 발생할 때 어떤 뷰의 body가 실행되는지 판단하는 몇가지 방법이 있습니다.</p>

<h3 id="1-print-삽입">1. print 삽입</h3>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/2/Untitled 6.png" alt="Untitled" /></p>

<h3 id="2-selfprintcahnges">2. Self.printCahnges()</h3>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/2/Untitled 7.png" alt="Untitled" /></p>

<p>print문과 다르게 재실행된 이유를 같이 호출해줍니다.</p>

<ul>
  <li>상태 변경으로 다시 호출되는 경우 ⇒ 상태 이름, 속성 표시</li>
  <li>뷰 값 자체가 변경된 경우 ⇒ 속성이 변경된 경우 @self가 기록됩니다.</li>
  <li>View의 ID 값이 변경된 경우 ⇒ @identity가 기록됩니다. (일반적으로 새로 삽입된 경우)</li>
</ul>

<h3 id="3-instruments">3. instruments</h3>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/2/Untitled 8.png" alt="Untitled" /></p>

<h3 id="observable-매크로"><strong>Observable 매크로</strong></h3>

<hr />

<p><a href="https://developer.apple.com/documentation/Observation">Observation</a>을 통해 SwiftUI는 observable data model 에 의존성을 형성하고 data 가 변할때마다 UI 를 업데이트 합니다.</p>

<h3 id="기존-observableobject-와-달라지는-것들"><strong>기존 ObservableObject 와 달라지는 것들</strong></h3>

<p><strong>첫번째: 코드가 간결해짐</strong></p>

<p>| <strong>AS-IS</strong> | <strong>TO-BE</strong> |
| — | — |
| final class Book: ObservableObject {
    @Published var title = “Sample Book Title”
    var isAvailable = true
}</p>

<p>struct BookView: View {
    @ObservedObject var book: Book
    
    var body: some View {
        Text(book.title)
    }
} | @Observable final class Book {
    var title = “Sample Book Title”
    var isAvailable = true
}</p>

<p>struct BookView: View {
    var book: Book
    
    var body: some View {
        Text(book.title)
    }
} |</p>

<p><strong>두번째: 뷰 업데이트 매커니즘이 좀 더 효율적으로 바뀜</strong></p>

<p>@Observable 매크로를 쓰면</p>

<p>뷰의 body 에서 프로퍼티를 직접 읽어야지만 뷰 업데이트가 된다.</p>

<p>ObservableObject에서는 published 프로퍼티가 변하면 뷰가 해당 프로퍼티를 읽고 있지 않아도 다시 그려진다.</p>

<p><strong>세번째: data model object 를 optional로 들고 있을 수 있다.</strong></p>

<p><strong>네번째: data model objects를 collection으로도 가능하다.</strong></p>

<p><a href="https://eunjin3786.tistory.com/580"><strong>https://eunjin3786.tistory.com/580</strong></a></p>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/2/Untitled 9.png" alt="Untitled" /></p>

<ul>
  <li>매크로 기능은 iOS 17 이상</li>
</ul>

<p>새로운 매크로 기반 객체 관찰 모델은 <strong>편리한 구문</strong>을 도입하고, 뷰와 관찰 가능한 객체 간의 종속성이 형성되는 방식을 변경합니다. 이전 속성 래퍼를 사용할 때, SwiftUI는 <code class="language-plaintext highlighter-rouge">@StateObject</code>의 <code class="language-plaintext highlighter-rouge">objectWillChange</code> 게시자를 맹목적으로 구독하거나, <code class="language-plaintext highlighter-rouge">@ObservedObject</code>를 뷰에서 선언했습니다.</p>

<p>새로운 <code class="language-plaintext highlighter-rouge">Observable</code> 매크로를 사용하면, <code class="language-plaintext highlighter-rouge">Observable</code>의 모든 속성이 뷰 본문에서 접근하는 객체는 객체가 어디에서 왔는지에 관계없이 이 뷰에 대한 종속성을 형성합니다.</p>

<p><strong>이 새로운 모델은 훨씬 더 간결하고 효율적입니다.</strong> 예를 들어, 뷰 본문에서 전역 <strong>싱글톤(관찰 가능)</strong>에 액세스할 경우, <code class="language-plaintext highlighter-rouge">@ObservedObject</code>를 사용하여 싱글톤을 뷰에 전달할 필요 없이, 액세스된 속성과 뷰 사이에 자동으로 종속성이 형성됩니다. 관찰 가능한 객체는 옵션, 배열 또는 다른 컬렉션에 중첩될 수 있으며, 속성 수준 추적으로 인해 관찰 및 뷰 업데이트가 예상대로 계속 작동합니다.</p>

<p>또한, 뷰 본문에서 객체의 속성 하나만 사용하는 경우, 다른 속성이 변경되어도 이 뷰는 다시 그려지지 않습니다. 모델 객체를 사용하지 않는 경우(예: 코드의 한 분기에만 존재하는 경우), 모델은 전혀 관찰되지 않습니다. 이를 통해 불필요한 뷰 업데이트를 줄여 성능을 향상시킬 수 있습니다. 이전에는 모델 객체를 수동으로 분할하여 더 세분화된 뷰 업데이트를 얻었습니다.</p>]]></content><author><name>jglee</name></author><category term="swiftui" /><category term="ios" /><summary type="html"><![CDATA[Thinking in SwiftUI - 2장 State and Binding]]></summary></entry><entry><title type="html">Thinking in SwiftUI - 1장 View Trees</title><link href="https://leejigun.github.io/Thinking-in-SwiftUI-1%EC%9E%A5-View-Trees" rel="alternate" type="text/html" title="Thinking in SwiftUI - 1장 View Trees" /><published>2024-05-27T04:47:00+09:00</published><updated>2024-05-27T04:47:00+09:00</updated><id>https://leejigun.github.io/Thinking-in-SwiftUI---1%EC%9E%A5-View-Trees</id><content type="html" xml:base="https://leejigun.github.io/Thinking-in-SwiftUI-1%EC%9E%A5-View-Trees"><![CDATA[<h1 id="thinking-in-swiftui---1장-view-trees">Thinking in SwiftUI - 1장 View Trees</h1>

<p>Created: 2024년 5월 26일 오후 6:23
Tags: SwiftUI, iOS</p>

<p>뷰 트리와 렌더 트리는 SwiftUI 작업을 이해하는 데 있어 가장 기본적이고 중요한 개념입니다. 원하는 레이아웃을 얻기 위해서는 뷰 트리의 구성 방식을 이해해야 합니다.</p>

<p>상태가 어떻게 작동하는지 이해하려면, SwiftUI에서 뷰의 수명과 그것이 만들고 있는 뷰 트리와의 관계를 이해하는 것이 중요합니다. 이를 이해하면, 데이터를 효율적으로 로드하고 필요할 때 뷰를 업데이트하는 SwiftUI 코드를 작성하는 데 도움이 됩니다.</p>

<p>마지막으로, 애니메이션과 전환이 어떻게 작동하는지 이해하려면 뷰 트리에 대한 이해가 필요합니다.</p>

<ul>
  <li>뷰 트리</li>
  <li>뷰 수명</li>
  <li>애니메이션 전환</li>
</ul>

<h2 id="view-tree와-render-tree"><strong>View Tree와 Render Tree</strong></h2>

<hr />

<p><img src="/assets/images/swiftui/thinking-in-swiftui/1/Untitled.png" alt="Untitled" /></p>

<p>위와 같은 코드를 작성하면, 중앙에 일시적인 청사진이 구축되며, 이를 ‘View Tree’라고 합니다. 그 결과, 왼쪽처럼 View가 렌더링되어 보여집니다.</p>

<p>뷰 트리를 살펴보면, 트리는 역순으로 그려집니다. ‘<code class="language-plaintext highlighter-rouge">background</code>‘는 트리의 최상단에 위치하지만, 실제로는 아무것도 그리지 않고, ‘<code class="language-plaintext highlighter-rouge">Text</code>’ 뒤쪽에 위치하게 됩니다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">View Tree</code>: 일시적인 인스턴스로 뷰를 구성하는 청사진</li>
</ul>

<p>만약, 아래와 같이 순서를 변경하게 된다면</p>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/1/Untitled 1.png" alt="Untitled" /></p>

<p><code class="language-plaintext highlighter-rouge">background</code>는 <code class="language-plaintext highlighter-rouge">padding</code>의 자식이 되며, <code class="language-plaintext highlighter-rouge">Text</code>에 <code class="language-plaintext highlighter-rouge">background</code>이 붙게 됩니다. 그러면 <code class="language-plaintext highlighter-rouge">background</code>에 <code class="language-plaintext highlighter-rouge">padding</code>이 붙어서 다음과 같은 모습이 됩니다.</p>

<h2 id="viewbuilders"><strong>ViewBuilders</strong></h2>

<hr />

<p>SwiftUI는 ‘<strong>뷰 빌더(ViewBuilder)</strong>‘라는 특별한 구문을 이용해 뷰 목록을 구성합니다. 뷰 빌더는 이 목적을 위해 Swift 언어에 추가된 결과 빌더 기능을 기반으로 만들어졌습니다. 예를 들어, 이미지를 텍스트 옆에 표시하는 뷰를 구성하는 방법은 다음과 같습니다.</p>

<p>(뷰 빌더는 <code class="language-plaintext highlighter-rouge">ResultBuilder</code> 피처의 위에 구현되었다)</p>

<ul>
  <li><a href="https://minsone.github.io/swift-resultbuilder">https://minsone.github.io/swift-resultbuilder</a></li>
  <li><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0289-result-builders.md">https://github.com/apple/swift-evolution/blob/main/proposals/0289-result-builders.md</a></li>
</ul>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/1/Untitled 2.png" alt="Untitled" /></p>

<p><strong><code class="language-plaintext highlighter-rouge">HStack</code></strong>은 클로저를 매개변수로 사용하며, 이 클로저는 <strong><code class="language-plaintext highlighter-rouge">@ViewBuilder</code></strong>로 표시됩니다. 이를 통해 내부에 여러 표현식을 작성할 수 있으며, 각 표현식은 뷰를 나타냅니다. 본질적으로 스택에 전달된 클로저는 이 예제에서 스택의 하위 뷰가 되는 뷰 목록을 생성합니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">ViewBuilder</span> <span class="p">{</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">func</span> <span class="n">buildBlock</span><span class="o">&lt;</span><span class="kt">C0</span><span class="p">,</span> <span class="kt">C1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">c0</span><span class="p">:</span> <span class="kt">C0</span><span class="p">,</span> <span class="n">_</span> <span class="nv">c1</span><span class="p">:</span> <span class="kt">C1</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="kt">TupleView</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">C0</span><span class="p">,</span> <span class="kt">C1</span><span class="p">)</span><span class="o">&gt;</span> <span class="k">where</span> <span class="kt">C0</span> <span class="p">:</span> <span class="kt">View</span><span class="p">,</span> <span class="kt">C1</span> <span class="p">:</span> <span class="kt">View</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위 예제의 스택에는 내부에 <strong>두 개의 뷰 표현식</strong>이 있으므로 두 개의 매개변수가 있는 뷰 빌더의 <strong><code class="language-plaintext highlighter-rouge">buildBlock</code></strong> 메소드가 호 출됩니다. 반환 유형에서 볼 수 있듯이 이는 이미지와 텍스트라는 두 가지 보기를 래핑하는 <strong><code class="language-plaintext highlighter-rouge">TupleView</code></strong>를 구성합니다. 뷰 빌더 를 뷰 목록을 나타내는 <strong><code class="language-plaintext highlighter-rouge">TupleView</code></strong>를 구성하는 메커니즘으로 생각할 수 있습니다.</p>

<p><strong>하위 뷰를 구성하는 뷰 컴포넌트</strong> (암시적으로 <code class="language-plaintext highlighter-rouge">@ViewBuilder</code>로 표시)</p>

<ul>
  <li>스택, 그리드 등과 같은 <strong>모든 컨테이너 뷰</strong></li>
  <li><code class="language-plaintext highlighter-rouge">background</code>, <code class="language-plaintext highlighter-rouge">overlay</code>..</li>
</ul>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/1/Untitled 3.png" alt="Untitled" /></p>

<ul>
  <li><a href="https://zeddios.tistory.com/m/1366">https://zeddios.tistory.com/m/1366</a></li>
</ul>

<h2 id="dynamic-content-동적-컨텐츠"><strong>Dynamic Content (동적 컨텐츠)</strong></h2>

<hr />

<p>SwiftUI 코드를 작성하고 ViewBuilder를 통해서 View 목록을 작성하는데, 이 때 View 목록도 동적일 수 있습니다. if - else 구문을 통해서 뷰를 동적으로 구성하는 방법은 아래와 같습니다.</p>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/1/Untitled 4.png" alt="Untitled" /></p>

<p>if 문 대신, if let, switch 문도 사용 가능합니다.</p>

<h2 id="render-trees">Render Trees</h2>

<hr />

<p>View Tree는 일시적으로 만들어지는 청사진의 역할을 하는 반면에, Render Tree는 더 긴 수명으로 계속 머무르다가 상태가 바뀌면 현재 상태를 반영하도록 업데이트 하는 역할을 합니다.</p>

<p>랜더 트리는 SwiftUI 내부에 존재하기 때문에, 직접 다룰일은 없습니다. 하지만, SwiftUI의 동작을 이해하는데 유용한 모델입니다.</p>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/1/Untitled 5.png" alt="Untitled" /></p>

<p>만약 옵셔널한 View 구조가 있다면, View Tree에서는 다음과 같이 생성됩니다.</p>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/1/Untitled 6.png" alt="Untitled" /></p>

<p>하지만, Render Tree의 경우에는 다릅니다. Text가 nil일 경우 View Tree가 Render Tree를 만들 땐 실제로 View에 대응되도록 HStack 안에 Image 하나만 존재합니다.</p>

<p>만약에 State가 업데이트되서 View 업데이트가 동작하게 된다면, Render Tree에 Text가 삽입되거나, 제거됩니다. (하지만, Text의 문구가 변경어도 Text View가 새로 만들어지는 건 아닙니다.)</p>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/1/Untitled 7.png" alt="Untitled" /></p>

<h2 id="lifetime">LifeTime</h2>

<hr />

<p>위에서 언급했듯이 View Tree는 일시적인 청사진의 역할을 합니다. 따라서 View의 수명(Life Time)과는 관계가 없습니다. 하지만 Render Tree는 처음 랜더링 된 시점부터 View가 더 이상 표시되지 않을 때 까지 수명을 가집니다. 다만, Render Treedml 수명은 화면상의 UI와 동일하지 않습니다.</p>

<p>만약, 스크롤 뷰 안에 큰 VStack이 있고 많은 View를 랜더링하는 경우 화면에 View가 보이는 여뷰랑 상관없이 모든 VStack의 하위 뷰 노드가 만들어집니다.</p>

<p>VStack은 LazyStack과 달리 바로 바쁘게 랜더링을 시작합니다. 그렇다고 LazyStack을 사용한다고 바로 바로 화면에서 보이지 않는다고 해제되는 건 아닙니다. 생성되는 시점이 늦어질 뿐 화면을 벗어나도 Render 노드가 유지됩니다.</p>

<p>(자세한 내용은 상태(State)에 대한 파트에서 다룰 예정입니다. 중요한건 렌더 트리의 노드를 통제할 수 없다는 것 입니다.)</p>

<p>SwiftUI에서는 실용적인 사용을 위해서 View의 LifeTime을 체크할 수 있도록 3가지 인터페이스 터널을 제공합니다.</p>

<ol>
  <li>onAppear
    <ol>
      <li>뷰가 화면에 나타날 때마다 실행됩니다. Render Tree의 노드가 생산될 때 호출되는게 아니라, View가 화면에 노출될 때마다 실행되기 때문에 여러번 호출할 수 있습니다. 예를들어서 LazyVStack 또는 List의 뷰가 스크롤을 통해 화면 밖으로 나갔다가 다시 돌아올 경우에도 매번 onAppear가 호출됩니다.</li>
      <li>TabView에서 탭을 전환할 때 역시 매번 호출됩니다.</li>
    </ol>
  </li>
  <li>onDisappear
    <ol>
      <li>화면에서 뷰가 사라질 때 호출됩니다. onAppear와 동일한 규칙으로 여러번 호출될 수 있습니다.</li>
    </ol>
  </li>
  <li>task
    <ol>
      <li>비동기 작업에 사용되는 onAppear와 onDisappear 두가지의 조합입니다. 이 task modifier는 onAppear가 호출되는 시점에 작업을 생성하고, onDisappear가 호출되는 시점에 작업을 취소합니다.</li>
    </ol>
  </li>
</ol>

<p>View의 id가 유지되는 동안은 값이 변경되어도 SwiftUI 관점에서의 View는 동일합니다.</p>

<p>State, ObservedObject는 View의 id와 연결된 저장소입니다. View의 lifetime 동안 body가 재계산되더라도 저장소의 메모리를 유지합니다.</p>

<p>View의 id가 변경되면 새로운 View로 간주되며 이전 View는 메모리에서 해제됩니다.</p>

<p>SwiftUI에서 View의 lifetime과 State의 lifetime은 동일한 의미를 갖습니다.</p>

<h2 id="identity-식별성"><strong>Identity (식별성)</strong></h2>

<hr />

<p>만약 작성한 코드에서 View의 ID값을 할당하지 않는다면, View Tree에서 생성될 View마다 고유 ID 값을 할당합니다. 이렇게 자동으로 할당되는 ID를 암시적 ID라 합니다. 이 ID 값을 통해서 뷰를 식별할 수 있고 ID가 동일할 경우 View를 새로 만드는게 아닌, 상태값을 업데이트 합니다.</p>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/1/Untitled 8.png" alt="Untitled" /></p>

<p>특이한 부분은 if else  브랜치에서 1이라는 동일한 ID 값 아래에 다른 ID값을 가진다는 것 입니다. 따라서 동일한 양쪽 다 동일한 Text를 사용하고 있지만, 다른 ID값을 가지고 있어 condition이 변경되면 새로 View를 만들어 추가하게 됩니다.</p>

<p>View Tree에서의 암시적인 ID 할당이 아닌, 명시적으로 ID 값을 할당할 수도 있습니다. 주로 ForEach를 통해 반복적인 View를 생성하고 해당 View의 상태를 업데이트 하기 위해서 명시적으로 ID를 지정합니다.</p>

<p>ID는 Hashable 값을 사용할 수 있습니다.</p>

<p>아래의 경우 true, false 값을 ID로 사용해 2개의 Text를 번갈아 추가 삭제 할 수 있습니다.</p>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/1/Untitled 9.png" alt="Untitled" /></p>

<ul>
  <li>Explicit id는 <strong><code class="language-plaintext highlighter-rouge">.id(_:)</code></strong> 메서드를 사용하여 명시적으로 지정할 수 있습니다.</li>
</ul>

<p>그렇다면, 다음과 같이 하나의 Text를 만들어서 2번 사용하는 경우 ID값이 어떻게 될까?</p>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/1/Untitled 10.png" alt="Untitled" /></p>

<p>View Tree에 표시된 것 처럼 다른 위치에 있기 때문에 View Tree에서 서로 다른 암시적인 ID값을 할당하고 별도의 뷰로 간주됩니다. 이 부분 때문에 View Tree를 청사진이라 생각할 수 있는 것 입니다.</p>

<p>다음으로 만약에 이런 condition에 따라 분기하는 applayIf 를 만들고 적용하면 어떻게 될까?</p>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/1/Untitled 11.png" alt="Untitled" /></p>

<p>적용한 코드 샘플을 보면 if else 형태로 하이라이트가 들어가면 background 모디파이어를 추가하는 형태로 구현하고 View Tree 역시 if else 형태와 유사한 모습을 보이고 있다.</p>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/1/Untitled 12.png" alt="Untitled" /></p>

<p>이 경우 동일하게 Text는 변함이 없지만, 불필요하게 2개의 Text가 condition에 따라서 생성, 제거되는 모습을 볼 수 있다. 이런 패턴이 아닌 아래와 같은 패턴을 사용하는게 좋다.</p>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/1/Untitled 13.png" alt="Untitled" /></p>

<p>이 경우 if else 의 값에 따라서 상태값을 변경해 랜더 노드를 추가, 삭제하지 않는다.</p>

<h2 id="view의-life-time-단계">View의 Life Time 단계</h2>

<hr />

<h3 id="1-appearing">1. Appearing</h3>

<ol>
  <li>스테이트 구독 (State, <strong>ObservedObject</strong>)</li>
  <li>body 계산, 스테이트 연결</li>
  <li>body 처음 호출</li>
  <li><strong>뷰 그래프</strong> 업데이트, UI 그리기</li>
  <li><strong>onAppear는 top-down으로 실행됨</strong></li>
</ol>

<h3 id="2-updating">2. Updating</h3>

<ol>
  <li>스테이트 변경 또는 publisher 구독으로 유저 액션 발생</li>
  <li>이전 스냅샷과 뷰 계층 비교</li>
  <li>변경된 뷰를 무력화한다</li>
  <li>뷰 그래프 업데이트하고 무력화된 뷰를 그림. 모든 업데이트 플로우는 뷰 계층을 타고 내려옴</li>
</ol>

<h3 id="3-disappearing">3. Disappearing</h3>

<ol>
  <li>뷰 계층에서 제거되고 호출. top-down으로 실행</li>
  <li>View가 화면에서 사라질 때 발생합니다.</li>
  <li>이 단계에서는 View의 정리(clean-up) 작업이 이루어집니다.</li>
  <li>예를 들어, <strong><code class="language-plaintext highlighter-rouge">onDisappear</code></strong> modifier를 사용하여 Disappearing 단계에서 리소스를 해제하거나 데이터를 저장할 수 있습니다.</li>
</ol>

<p><a href="https://www.vadimbulavin.com/swiftui-view-lifecycle/">https://www.vadimbulavin.com/swiftui-view-lifecycle/</a></p>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/1/Untitled 14.png" alt="Untitled" /></p>]]></content><author><name>jglee</name></author><category term="swiftui" /><category term="ios" /><summary type="html"><![CDATA[Thinking in SwiftUI - 1장 View Trees]]></summary></entry><entry><title type="html">Thinking in SwiftUI - 3장 Layout</title><link href="https://leejigun.github.io/Thinking-in-SwiftUI-3%EC%9E%A5-Layout" rel="alternate" type="text/html" title="Thinking in SwiftUI - 3장 Layout" /><published>2024-05-27T04:47:00+09:00</published><updated>2024-05-27T04:47:00+09:00</updated><id>https://leejigun.github.io/Thinking-in-SwiftUI---3%EC%9E%A5-Layout</id><content type="html" xml:base="https://leejigun.github.io/Thinking-in-SwiftUI-3%EC%9E%A5-Layout"><![CDATA[<h1 id="thinking-in-swiftui---3장-layout">Thinking in SwiftUI - 3장 Layout</h1>

<p>Created: 2024년 5월 26일 오후 10:51</p>

<p>SwiftUI의 레이아웃 알고리즘은 간단합니다. 상위 뷰는 하위 뷰에 크기를 제안하고, 하위 뷰는 그 제안에 따라 자신의 크기를 결정 후, 이 크기를 상위 뷰에 보고합니다. 그 다음 상위 뷰는 이를 자신의 좌표계 내에 배치합니다. 본질적으로, 레이아웃 프로세스의 목표는 각 뷰에 위치와 크기를 제공하는 것입니다.</p>

<p>가장 먼저 염두에 두어야 할 점은 SwiftUI의 레이아웃 알고리즘이 뷰 트리를 따라 <strong>하향식으로 진행</strong>된다는 것입니다. 그러므로 뷰 빌더 코드에 의해 생성된 뷰 트리를 이해하는 것이 중요합니다</p>

<p>( 이에 대한 자세한 내용은 뷰 트리 장을 참조하세요 ).</p>

<p>실제 뷰 트리에 레이아웃 알고리즘을 적용하는 방법을 더 잘 이해하기 위해 예제를 살펴보겠습니다.</p>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/3/Untitled.png" alt="Untitled" /></p>

<p>이 예에서 VStack은 루트 뷰이므로 안전 화면 영역을 제안된 크기로 받게 됩니다. 자체 크기를 결정하기 위해 스택은 먼저 하위 뷰에 크기를 재귀적으로 제안합니다.</p>

<p>이미지는 지구본 기호의 크기를 기준으로 크기를 보고하고, 텍스트는 제안된 크기와 렌더링해야 하는 문자열을 기준으로 크기를 보고합니다. 이미지와 텍스트가 크기를 정확히 결정하는 방법에 대해 자세히 설명하겠습니다(크기는 나중에).</p>

<p>이제 스택은 두 개의 하위 뷰를 서로 아래에 배치하여 둘 사이에 기본 간격을 삽입합니다. 스택은 하위 뷰 프레임의 합집합 크기로 자체 크기를 계산하고 이를 다시 창에 보고합니다.</p>

<ol>
  <li>상위 뷰는 하위 뷰에 크기를 제안합니다.</li>
  <li>하위 뷰는 이 제안을 기반으로 자신의 크기를 결정하며, 자신의 하위 뷰가 있는 경우 1단계부터 다시 시작합니다.</li>
  <li>하위 뷰는 결정한 크기를 상위 뷰에 보고합니다.</li>
  <li>상위 뷰는 보고받은 크기에 따라 하위 뷰를 배치합니다.</li>
</ol>

<blockquote>
  <p>3단계에서 하위 뷰에 의해 보고된 크기는 하위 뷰의 최종 크기입니다. 상위 뷰는 이 크기를 일방적으로 변경할 수 없습니다. 상위 뷰는 2단계로 돌아가 또 다른 크기 제안을 할 수 있지만, 결국 하위 뷰는 자신에게 적합한 크기를 선택하여 결정합니다.</p>

</blockquote>

<p>자세한 순서를 다시 보면 아래와 같습니다.</p>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/3/Untitled 1.png" alt="Untitled" /></p>

<p>이 예시에서는 safe area 가 320 480인 창이 있다고 가정합니다.</p>

<ol>
  <li>시스템은 배경에 320 480 사이즈를 제안합니다.</li>
  <li>배경은 기본 하위 뷰에 동일한 320 480 사이즈를 제안합니다.</li>
  <li>패딩은 각 가장자리에서 10포인트를 뺀 300 460 사이즈를 텍스트에 제안합니다.</li>
  <li>텍스트는 그 크기를 51 17로 보고합니다.</li>
  <li>패딩은 각 가장자리에 10포인트를 추가하여, 크기를 71 37로 보고합니다.</li>
  <li>배경은 보조 하위 뷰(색상)에 패딩된 텍스트의 크기인 71 37을 제안합니다.</li>
  <li>색상은 제안된 71 37 사이즈를 수용하고 그대로 보고합니다.</li>
  <li>배경은 기본 하위 뷰의 크기인 71 37을 보고합니다.</li>
</ol>

<h2 id="leaf-views"><strong>Leaf Views</strong></h2>

<hr />

<h3 id="text">Text</h3>

<p>기본적으로 Text 뷰는 제안된 크기에 맞게 조정됩니다. 텍스트는 이 작업을 수행하기 위해 다음 순서로 여러 전략을 사용합니다: 텍스트를 여러 줄로 나누기(단어 줄 바꿈), 단어를 나누기(줄 바꿈), 자르기, 마지막으로 텍스트를 조정하기.</p>

<p>텍스트는 항상 콘텐츠를 렌더링하는데 필요한 정확한 크기를 반환합니다. 이 크기는 제안된 너비보다 작거나 같고 최소한 한 줄의 높이입니다(0 제안 제외). 즉, 텍스트는 0부터 콘텐츠 전체를 렌더링하는데 필요한 크기까지 임의의 너비를 가질 수 있습니다.</p>

<p>다음은 Text(“Hello, World!”)가 제안된 크기에 따라 어떻게 렌더링되는지에 대한 몇 가지 예입니다. 점선 사각형은 제안된 크기를 나타내고, 실선 사각형은 반환된 크기를 나타냅니다.</p>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/3/Untitled 2.png" alt="Untitled" /></p>

<p>→ <code class="language-plaintext highlighter-rouge">.lineLimit(_ number:)</code>를 사용하면 제안된 수직 공간에 관계없이 렌더링할 최대 라인 수를 지정할 수 있습니다. nil을 지정하면 줄 제한이 없음을 의미합니다.</p>

<p>→ <code class="language-plaintext highlighter-rouge">.lineLimit(_limit:reservesSpace:)</code>를 사용하면 렌더링할 최대 줄 수를 지정하고, 비어 있는지 여부에 관계없이 보고된 크기에 이러한 줄의 공간을 항상 포함하는 옵션을 제공합니다.</p>

<p>→ <code class="language-plaintext highlighter-rouge">.truncationMode(_ mode:)</code>를 사용하면 잘림을 적용할 위치를 지정할 수 있습니다.</p>

<p>→ <code class="language-plaintext highlighter-rouge">.minimumScaleFactor(_ Factor:)</code>를 사용하면 제안된 크기에 맞도록 글꼴 크기를 축소할 수 있는 텍스트의 양을 지정할 수 있습니다.</p>

<p>만약, fixedSize()를 Text에 적용시키면, 제안과 다른 결과를 보여준다.</p>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/3/Untitled 3.png" alt="Untitled" /></p>

<h3 id="shapes"><strong>Shapes</strong></h3>

<p>대부분의 기본 제공 모양(<strong>Rectangle</strong>, <strong>RoundedRectangle</strong>, <strong>Capsule</strong> 및 <strong>Ellipse</strong>)은 0부터 무한대까지 제안된 크기를 수용하고 사용 가능한 공간을 채웁 니다. <strong>원은 예외입니다.</strong> 제안된 크기에 맞춰지고 원의 실제 크기를 다시 보고합니다. 모양에 nil을 제안하는 경우(즉, .fixedSize로 래핑하는 경우) 기본 크기는 10 10입니다.</p>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/3/Untitled 4.png" alt="Untitled" /></p>

<h2 id="colors"><strong>Colors</strong></h2>

<p><code class="language-plaintext highlighter-rouge">Color.red</code>와 같이 색상을 뷰로 직접 사용하는 경우, 레이아웃 관점에서는 <code class="language-plaintext highlighter-rouge">Rectangle().fill(⋯)</code>처럼 동작합니다.</p>

<p>그러나 특별한 경우가 있습니다. ignoresSafeAreaEdges에 색상을 넣으면, 해당 색상이 마법처럼 ignoresSafeAreaEdges으로 확장됩니다. 이 동작은 레이아웃에 영향을 주지 않지만, 우리 모두가 어느 시점에서 이 문제를 겪게 될 것이므로, 이를 언급하고자 했습니다. 이를 방지하기 위해서는, .background에서 ignoresSafeAreaEdges 매개변수를 사용하거나, Color 대신 Rectangle().fill(⋯)을 사용할 수 있습니다.</p>

<h3 id="image"><strong>Image</strong></h3>

<p>기본적으로 이미지 보기는 정적 값, 즉 기본 이미지의 크기를 보고합니다. 이미지에 대해 <code class="language-plaintext highlighter-rouge">.resizeable()</code>을 호출하면 보기가 완전히 유연해집니다. 그런 다음 이미지는 제안된 크기를 수락하고 이를 다시 보고하며 이미지를 해당 크기로 압축합니다. 실제로 크기 조 정이 가능한 거의 모든 이미지는 다음과 결합됩니다.</p>

<p>이미지가 왜곡되는 것을 방지하기 위한 <code class="language-plaintext highlighter-rouge">.aspectRatio(contentMode:)</code> 또는 <code class="language-plaintext highlighter-rouge">.scaleToFit()</code> modifier를 사용합니다.</p>

<h3 id="divider"><strong>Divider</strong></h3>

<p>구분선이 수평 스택 외부에서 사용되는 경우 제안된 너비를 수락하고 구분선의 높이를 보고합니다. 수평 스택 내에서 구분 선은 제안된 높이를 승인하고 구분선의 너비를 보고합니다. <strong>nil을 제안하면 상황에 따라 가변 축의 기본 크기가 10이 됩 니다.</strong></p>

<h3 id="spacer"><strong>Spacer</strong></h3>

<p>수평 또는 수직 스택 외부에서 Spacer는 <strong>최소 길이부터 무한대까지 제안된 크기를 허용</strong>합니다.</p>

<p>수직 스택 내에서 Spacer는 최소 길이에서 무한대까지의 높이를 허용하지만 <strong>너비 는 0으로 보고됩니다.</strong></p>

<p>스페이서의 최소 길이는 minLength를 사용하여 길이를 지정하지 않는 한 기본 패딩의 길이입니다.</p>

<h2 id="modifier-view">Modifier View</h2>

<hr />

<p>ViewModifier는 항상 다른 레이어 내부에 기존 뷰를 래핑합니다. <strong>수정자는 적용된 뷰의 상위가 됩니다.</strong> SwiftUI에는 ViewModifier 프로토콜을 준수하는 값을 적용하기 위한 .modifier API가 있지만 SwiftUI의 내장 수정자는 모두 View의 확장으로 노출됩니다(이는 자체 뷰 수정자에도 좋은 방법입니다). 이 섹션에서는 레이아웃에 영향을 미치는 뷰 수정자를 설명합니다.</p>

<h3 id="frame">Frame</h3>

<ul>
  <li>고정값 지정</li>
  <li>유연하게 지정
    <ul>
      <li>유연하게 frame 값을 설정한 경우 2번 범위를 정하게 됩니다.</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/3/Untitled 5.png" alt="Untitled" /></p>

<p>만약 다음과 같이 설정한 경우 320 480 화면에서 렌더링될 때</p>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/3/Untitled 6.png" alt="Untitled" /></p>

<ol>
  <li>
    <p>시스템은 패딩을 320, 480으로 제안합니다.</p>
  </li>
  <li>
    <p>패딩은 배경에 300 460을 제안합니다.</p>
  </li>
  <li>
    <p>배경은 기본 하위 뷰에 동일한 300 460을 제안합니다. (frame).</p>
  </li>
</ol>

<ul>
  <li>일단 가능한 최대값을 제안</li>
</ul>

<ol>
  <li>
    <p>프레임은 하위 뷰(텍스트)에 동일한 300 460을 제안합니다.</p>
  </li>
  <li>
    <p>텍스트에서는 크기가 76 17이라고 보고합니다.</p>
  </li>
  <li>
    <p>프레임의 너비는 max(0, min( .infinity, 300)) = 300이 됩니다.</p>
  </li>
</ol>

<ul>
  <li>0 및 .infinity 값은 유연한 프레임에 대해 지정된 인수입니다.</li>
</ul>

<ol>
  <li>
    <p>배경은 유연한 프레임의 크기(300 17)를 제안합니다.</p>
  </li>
  <li>
    <p>색상은 제안된 크기를 수락하고 보고합니다. (300 17)</p>
  </li>
  <li>
    <p>배경은 기본 하위 뷰의 크기(300 17)를 보고합니다.</p>
  </li>
  <li>
    <p>패딩은 각 측면에 10포인트를 추가하고 크기를 320 37로 보고합니다.</p>
  </li>
</ol>

<h2 id="aspectratio">AspectRatio</h2>

<p>AspectRatio 유연한 frame 사이즈로 작업할 때 유용하게 사용할 수 있습니다. 예를 들어 아래 코드는 4:3 인 직사각형을 그릴 수 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Color</span><span class="o">.</span><span class="n">secondary</span>
	<span class="o">.</span><span class="nf">aspectRatio</span><span class="p">(</span><span class="mi">4</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="nv">contentMode</span><span class="p">:</span> <span class="o">.</span><span class="n">fit</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/3/Untitled 7.png" alt="Untitled" /></p>

<p>aspectRatio의 일반적으로 이미지에 사용합니다. 이미지에 .resizable() 을 붙이면 사이즈에 맞게 이미지가 늘어나거나 줄어드는데, 이미지가 깨지지 않도록 aspectRatio 를 사용해 화면 사이즈에 맞춰 이미지 사이즈를 조절할 수 있습니다.</p>

<p><strong>만약, 비율을 적용하지 않은 경우 어떻게 될까?</strong></p>

<p>aspectRatio modifier는 하위 뷰의 이상적인 크기를 제안을 통해 조사하고, 비율을 적용합니다.</p>

<p>만약, 이미지를 사용했을 때 이미지의 사이즈가 100:30 이라고 가정하고, 전체 사이즈가 200:200 이면, 아래와 같은 절차를 따라 사이즈를 설정합니다.</p>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/3/Untitled 8.png" alt="Untitled" /></p>

<ol>
  <li>
    <p>AspectRatio의 크기는 200x200으로 제안을 내려보냅니다.</p>
  </li>
  <li>
    <p>AspectRatio는 이미지에 nil x nil로 제안합니다.(사이즈 제한 없이)</p>
  </li>
  <li>
    <p>이미지의 이상적인 크기는 100x30으로 제안을 올려보냅니다.</p>
  </li>
  <li>
    <p>가로 세로 비율이 100/30인 직사각형을 200 200에 맞춥니다.</p>
  </li>
</ol>

<ul>
  <li>200 60이며 이 크기를 이미지에 제안합니다.</li>
</ul>

<ol>
  <li>이미지의 크기는 200 60으로 보고됩니다.</li>
  <li>AspectRatio는 하위 뷰의 크기인 200 60을 자체 크기로 보고합니다.</li>
</ol>

<blockquote>
  <p>AspectRatio를 적용한다고 반드시 비율에 맞게 조정되는건 아닙니다. 하위뷰가 유연하지 않을 경우 적용되지 않을 수 있습니다.</p>

</blockquote>

<h3 id="overlay-and-background"><strong>Overlay and Background</strong></h3>

<p>Overlay와 Background는 SwiftUI에서 가장 유용한 수정자 중 하나입니다. 레이아웃 측면에서는 정확히 동일한 방식으로 작동합니다. 유일한 차이점은 Overlay는 기본 View 위에 보조 View를 그리는 반면, Background는 기본 View 뒤에 보조 View를 그리는 것입니다. 예를 들어, 일부 텍스트 뒤에 배경을 그리려면 다음과 같이 할 수 있습니다.</p>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/3/Untitled 9.png" alt="Untitled" /></p>

<p>Background와 overlay는 기본 하위 View의 레이아웃에 영향을 미치지 않습니다. 보고된 overlay 또는 background의 크기는 항상 기본 하위 View의 보고된 크기입니다.</p>

<h2 id="container-view">Container View</h2>

<hr />

<p>HStack과 VStack은 단순해보이지만, 결과를 파악하는데 복잡할 수 있다.</p>

<p>만약 아래와 같이 사이즈를 지정하지 않은 경우 제안된 크기에 따라서 다른 결과가 나온다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">HStack</span><span class="p">(</span><span class="nv">spacing</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> 
	<span class="kt">Color</span><span class="o">.</span><span class="n">cyan</span> 
	<span class="kt">Text</span><span class="p">(</span><span class="s">"Hello, World!"</span><span class="p">)</span> 
	<span class="kt">Color</span><span class="o">.</span><span class="n">teal</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/3/Untitled 10.png" alt="Untitled" /></p>

<ol>
  <li>큰 크기를 제공한 케이스 (150x50)
    <ol>
      <li>모두 충분한 크기를 제공받았지만, Text의 경우에는 텍스트가 들어간 경우의 사이즈가 이상적인 상한선 크기로 잡을 수 있다.</li>
      <li>그에 비해서 Color는 유연하기 때문에 채울 수 있는 만큼 Text를 채우고 남은 공간을 Color가 나눠 가지게 된다.</li>
    </ol>
  </li>
  <li>작은 크기를 제공한 케이스 (100x50)
    <ol>
      <li>3개 모두 표현하기에 충분하지 않은 사이즈가 나온 경우 3등분하게 된다. 필요에 따라서 텍스트가 줄바꿈되거나 잘리게 된다.</li>
    </ol>
  </li>
  <li>만약 극단적으로 작은 사이즈를 준다면 (40x40)
    <ol>
      <li>이 경우 사이즈를 설정할 수 없기 때문에, Text가 Container의 제안을 무시하고 이상적인 사이즈로 표시해버립니다.</li>
      <li>
        <p>대안은 .layoutPriority modifier를 적용해 내부 View 사이에 우선순위를 제공하는 것 입니다.</p>

        <p><img src="/assets/images/swiftui/thinking-in-swiftui/3/Untitled 11.png" alt="Untitled" /></p>
      </li>
    </ol>
  </li>
</ol>

<h3 id="zstack">ZStack</h3>

<p>ZStack은 얼핏보면 overlay나 background와 동일한 역할을 할 것 같지만, overlay와 background는 ViewModifier기 때문에 하위뷰의 사이즈에 영향을 받는다. 그에 비해서 ZStack은 컨테이너기 때문에 내부의 View의 크기와 상관없이 Size를 잡게된다.</p>

<p>만약, 아래 코드를 root 에서 실행하게되면, 화면 전체를 다 가리게 된다.</p>

<h3 id="scrollview">ScrollView</h3>

<p>제안된 화면을 가득 채우게 되고, 내부 View는 contents의 사이즈에 맞춰진다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">ScrollView</span> <span class="p">{</span> 
	<span class="kt">Image</span><span class="p">(</span><span class="s">"logo"</span><span class="p">)</span>
		<span class="o">.</span><span class="nf">resizable</span><span class="p">()</span>
		<span class="o">.</span><span class="nf">aspectRatio</span><span class="p">(</span><span class="o">.</span><span class="n">fit</span><span class="p">)</span> 
	<span class="kt">Text</span><span class="p">(</span><span class="s">"This is a longer text"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>scrollView에 Shape 의 서브 뷰를 넣으면 10x10으로 표시되는 것을 볼 수 있다. 이는 Shape의 ProposedView의 기본값이 10, 10 이기 때문이다.</p>

</blockquote>

<h3 id="geometryreader"><strong>GeometryReader</strong></h3>

<p>제안받은 크기에 접근하는데 사용합니다. GeometryProxy 를 통해 제안받은 크기에 접근 할 수 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">GeometryReader</span> <span class="p">{</span> <span class="n">proxy</span> <span class="k">in</span> 
	<span class="kt">Text</span><span class="p">(</span><span class="nv">verbatim</span><span class="p">:</span> <span class="s">"</span><span class="se">\(</span><span class="n">proxy</span><span class="o">.</span><span class="n">size</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>그러나 스택 오버플로우나 다른 사이트를 볼 때 GeometryReader에서 이슈가 생겨 고통받는 경우가 많습니다. 예를 들어서 GeometryReader 를 주위에 배치하고, Text의 사이즈를 측정하려고 하는 경우 Text 주변의 레이아웃이 잘못 나오는 경우가 많이 보고됩니다.</p>

<p>GeometryReader는 꼭 필요한 경우에만 써야 하고, 다음과 같은 경우에 유용하게 사용할 수 있습니다.</p>

<ul>
  <li>GeometryReader 내부에 유연한 View를 넣는 경우 레이아웃 사이즈를 체크할 수 있습니다.
    <ul>
      <li>예를 들어서 ScrollView 안에 GeometryReader를 넣는 경우 ScrollView의 내부 View 사이즈를 알 수 있습니다.</li>
    </ul>
  </li>
  <li>background나 overlay 안에 GeometryReader를 넣으면 기본 View 크기에는 영향을 미치지 않지만 관련된 다양한 값을 읽을 수 있습니다. (고급 레이아웃 장에서 더 자세한 예를 살펴보겠습니다.)</li>
</ul>

<h3 id="list">List</h3>

<hr />

<p>List는 UIkit에서 UITableView와 동일합니다. List 자체는 제안받은 크기를 가지며, ScrollView와 유사하게 View 자체는 너비와 높이를 제안하지 않습니다.</p>

<p>행의 높이가 고정되지 않은 UITableView와 비슷하고 내부에 배치된 항목을 기준으로 내부 View의 높이를 추정합니다.</p>

<h3 id="lazyhstack-lazyvstack">LazyHStack, LazyVStack</h3>

<p>List와 동일하게 View가 보여질 때 업데이트 한다.</p>

<h3 id="lazyvgrid-lazyhgrid">LazyVGrid, LazyHGrid</h3>

<p>LazyVGrid와 LazyHGrid는 모두 동일한 기본 알고리즘을 사용하여 열이나 행의 크기를 계산하므로 이 섹션 에서는 LazyVGrid에 중점을 둘 것입니다.</p>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/3/Untitled 12.png" alt="Untitled" /></p>

<p>그리드는 iOS 16에서 추가되었고, 17 이상에서도 아직 버그가 많기 때문에 짧게 다루고 넘어간다.</p>

<p>(가급적 쓰지 말것)</p>

<h3 id="viewthatfits"><strong>ViewThatFits</strong></h3>

<p>제안된 크기에 따라 다른 보기를 표시하려면 ViewThatFits를 사용하면 됩니다. 여러 개의 하위 뷰가 필요한 경우, 제안된 크기에 맞는 첫 번째 하위 뷰를 표시합니다. 이는 각 하위 뷰의 이상적인 크기를 파악하기 위해 nil을 제안하고, 이상적인 크기가 제안된 크기 내에 맞는 첫 번째 하위 뷰(코드에 하위 뷰가 나타나는 순서대로)를 표시합니다. 적합한 하위 뷰가 없으면 마지막 하위 뷰를 선택합니다.</p>

<h3 id="rendering-modiers"><strong>Rendering Modi!ers</strong></h3>

<p>SwiftUI에는 offset, RotationEffect, scaleEffect 등과 같이 뷰의 렌더링 방식에는 영향을 주지만 레이아웃 자체에는 영향을 미치지 않는 여러 뷰 수정자가 있습니다. 이러한 수정자는 CGContext.translate와 같은 작업을 수행한다고 생각할 수 있습니다. 이는 뷰가 그려지는 위치를 변경하지만, 레이아웃 시스템에서 보면 뷰는 여전히 원래 위치에 있습니다.</p>

<h2 id="alignment"><strong>Alignment</strong></h2>

<p>기본적으로 거의 모든 뷰는 하위 뷰의 중앙에 배치됩니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Text</span><span class="p">(</span><span class="s">"Hello"</span><span class="p">)</span>
	<span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">width</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="nv">height</span><span class="p">:</span> <span class="mi">100</span><span class="p">)</span> <span class="c1">// 기본값이 .center</span>
</code></pre></div></div>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/3/Untitled 13.png" alt="Untitled" /></p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Text</span><span class="p">(</span><span class="s">"Hello"</span><span class="p">)</span>
	<span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">width</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="nv">height</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="nv">alignment</span><span class="p">:</span> <span class="o">.</span><span class="n">bottomTrailing</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/3/Untitled 14.png" alt="Untitled" /></p>

<p>정렬 가이드</p>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/3/Untitled 15.png" alt="Untitled" /></p>

<p>ZStack 역시 기본값은 .center라 아래의 경우 가운데에 쌓이게 된다.</p>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/3/Untitled 16.png" alt="Untitled" /></p>

<h3 id="정렬-가이드-수정">정렬 가이드 수정</h3>

<p>center, bottom같은 기본 정렬 가이드라인을 수정할 수 있다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">image</span> <span class="o">=</span> <span class="kt">Image</span><span class="p">(</span><span class="nv">systemName</span><span class="p">:</span> <span class="s">"pencil.circle.!ll"</span><span class="p">)</span> 
	<span class="o">.</span><span class="nf">alignmentGuide</span><span class="p">(</span><span class="o">.</span><span class="n">firstTextBaseline</span><span class="p">,</span> <span class="nv">computeValue</span><span class="p">:</span> <span class="p">{</span> <span class="n">dimension</span> <span class="k">in</span>
		<span class="n">dimension</span><span class="o">.</span><span class="n">height</span><span class="o">/</span><span class="mi">2</span> 
	<span class="p">}</span>
<span class="p">)</span>
</code></pre></div></div>

<p>image의 .firstTextBaseline을 줄여서 Image 가 firstTextBaseline으로 정렬했더니 아래로 밀리게 된다.</p>

<p>이렇게 수정한 이미지를 적용하면 다음과 같이 가이드라인이 변경된다.</p>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/3/Untitled 17.png" alt="Untitled" /></p>

<p>하지만 firstTextBaseline 을 수정했기 때문에 center로 설정하면 바뀌는게 없다.</p>

<p>이를 사용해 다음과 같이 범용적으로 적용 가능한 뱃지 아이콘을 만들수도 있다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="n">badge</span><span class="o">&lt;</span><span class="kt">B</span><span class="p">:</span> <span class="kt">View</span><span class="o">&gt;</span><span class="p">(</span><span class="kd">@ViewBuilder</span> <span class="n">_</span> <span class="nv">badge</span><span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">B</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="nf">overlay</span><span class="p">(</span><span class="nv">alignment</span><span class="p">:</span> <span class="o">.</span><span class="n">topTrailing</span><span class="p">)</span> <span class="p">{</span> <span class="nf">badge</span><span class="p">()</span>
                <span class="o">.</span><span class="nf">alignmentGuide</span><span class="p">(</span><span class="o">.</span><span class="n">top</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">height</span><span class="o">/</span><span class="mi">2</span> <span class="p">}</span>
		            <span class="o">.</span><span class="nf">alignmentGuide</span><span class="p">(</span><span class="o">.</span><span class="n">trailing</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span> <span class="p">}</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/3/Untitled 18.png" alt="Untitled" /></p>]]></content><author><name>jglee</name></author><category term="swiftui" /><category term="ios" /><summary type="html"><![CDATA[Thinking in SwiftUI - 3장 Layout]]></summary></entry><entry><title type="html">[클린 소프트웨어] 단일책임원칙(SRP)</title><link href="https://leejigun.github.io/CleanSoftware_SRP" rel="alternate" type="text/html" title="[클린 소프트웨어] 단일책임원칙(SRP)" /><published>2023-07-20T09:00:02+09:00</published><updated>2023-07-20T09:00:02+09:00</updated><id>https://leejigun.github.io/CleanSoftware_SRP</id><content type="html" xml:base="https://leejigun.github.io/CleanSoftware_SRP"><![CDATA[<h1 id="클린-소프트웨어-단일책임원칙srp">[클린 소프트웨어] 단일책임원칙(SRP)</h1>

<blockquote>
  <p>클린 소프트웨어 책의 단일책임원칙 파트를 읽고 정리한 내용입니다.</p>

</blockquote>

<p>이번 장에서는 모듈이나 클래스의 변경을 야기하는 응집력에 대해서 언급하려 한다.</p>

<h2 id="단일-책임-원칙">단일 책임 원칙</h2>

<blockquote>
  <p>한 클래스는 단 한 가지의 변경 이유만을 가져야 한다.</p>

</blockquote>

<p>보통 단일 책임 원칙에 대해서 검색해보면 하나의 클래스는 하나의 책임만을 가져야 한다고 설명하고 있습니다. 하지만, 이 책에서는 다르게 설명하고 있습니다. 한 클래스는 단 한 가지의 변경 이유만을 가져야 한다는 것입니다.</p>

<p>이는 SOLID 원칙이 소프트웨어 설계 단에서 발생하는 문제를 해결하는 데 있습니다. SOLID 원칙을 지키는 것에만 집중하면서 생기는 변화를 잊지 말아야 합니다. 앞서 배운 대로 애자일 설계는 문제를 해결하는 과정을 의미합니다. 단일 책임 원칙 역시 소프트웨어 변경에 있어서 발생하는 문제를 해결하는 데 사용하는 원칙입니다. 클래스는 하나의 책임을 가져야 한다는 원칙보다는 한 가지의 변경 이유만을 가져야 한다는 목적을 명확하게 이해해야 합니다.</p>

<p>예를 들어, 게임을 만들 때 현재 프레임을 기억하는 것과 스코어를 계산하는 두 가지 책임이 있을 때, 소프트웨어를 설계할 때 2개의 클래스로 분리할 것입니다. 이는 하나의 클래스가 하나의 책임만 가져야 하기 때문이 아니라 변경점이 생겼을 때 하나의 클래스를 변경할 때 그 클래스가 가진 하나의 책임에 의해서만 변경되어야 하기 때문에 미리 유지보수를 고려하여 2개의 클래스로 분리한 것입니다.</p>

<h2 id="책임이란-무엇인가">책임이란 무엇인가?</h2>

<p>그렇다면 책임이란 무엇일까요? 만약 한 클래스를 변경하기 위해 한 가지 이상의 이유가 있다면, 그 클래스는 한 가지 이상의 책임을 맡고 있다는 것입니다. 그런데 사람들은 여러 책임을 묶어서 하나의 기능으로 생각하기 때문에 클래스를 분리하기 어렵습니다.</p>

<p>만약 클래스를 과도하게 쪼개면 불필요한 복잡성을 가지게 되고, 단순히 기능 단위로 묶어두면 변경이 힘들어지는 경직성의 악취를 풍기게 됩니다.</p>

<p>대부분의 경우 테스트 주도 개발 방식으로 개발하면 설계 단계에서 악취가 나기 한참 전에 테스트 코드를 작성하는 과정에서 책임이 분리되도록 만들 수 있습니다. 그러나 테스트 코드가 분리를 강제하지 않았고, 경직성과 취약성의 악취가 강해진 경우에는 퍼사드나 프록시 패턴을 사용해 두 책임이 분리되도록 리팩토링해야 합니다.</p>

<p>단일 책임 원칙은 가장 간단한 원칙 중 하나이면서도 제대로 적용하기 가장 어려운 원칙 중 하나입니다. 책임들을 구분해 분리하기는 익숙하지 않고, 우리가 실제로 소프트웨어를 설계할 때 이런 책임들을 하나 하나 찾고 분리하는 것이 대부분의 일입니다.</p>

<p>추가로 단일책임원칙과는 상관 없지만, 클린 소프트웨어에서 결합된 책임을 분리하기 위해서 퍼사드 패턴과 프록시 패턴을 사용 할 수 있다고 언급하고 있어 해당 패턴에 대해서 간단하게 정리하려 합니다.</p>

<h3 id="퍼사드-패턴">퍼사드 패턴</h3>

<p>퍼사드 패턴은 복잡하고 일반적인 인터페이스를 가진 객체 그룹에 간단하고 구체적인 인터페이스를 제공하고자 할 때 사용합니다. 예를 들어, 어떤 함수나 클래스가 어떤 동작인지 이해하기 어려운 매우 복잡한 동작이나 다양하고 많은 인터페이스를 가지고 있을 때, 새로운 인터페이스를 만들어 이해하기 쉽게 만들 수 있습니다.</p>

<p>소프트웨어가 점차 고도화되면서 인터페이스가 다양해지고 복잡해질 수 있습니다. 만약 하나의 클래스가 다수의 책임을 가지게 된다면, 해당 클래스를 한 가지 책임만을 가진 다수의 클래스로 리팩토링하고 해당 클래스를 모아서 사용하는 퍼사드를 만들어 인터페이스를 제공할 수 있습니다.</p>

<p>덕분에 복잡한 기능이라도 다수의 부담 없이 다수의 클래스로 분리하고 사용하는 입장에서 퍼사드를 통해 간단하게 다수의 클래스가 결합된 하나의 인터페이스를 사용할 수 있습니다.</p>

<h3 id="프록시-패턴">프록시 패턴</h3>

<p>프록시는 사전적인 의미로 대리인을 뜻한다. 클라이언트가 원본 객체에 접근하기 전 프록시를 통해 로직을 수행 한 후 원본 객체에 접근하는 형태를 취하고 있다.</p>

<p>다음과 같은 이유가 있을 때 일반적으로 프록시 패턴을 사용한다.</p>

<ul>
  <li>보안: 클라이언트가 원본 객체에 접근할 권한이 있는 지 체크 후 권한이 있는 경우에만 전달한다.</li>
  <li>캐싱: 프록시가 내부 데이터를 캐싱하고 캐싱 데이터가 없는 경우에만 원본 데이터에 접근한다.</li>
  <li>데이터 유효성 검사: 원본 객체에 전달하는 데이터가 원본 객체가 다룰 수 있는 범위의 데이터인지 사전에 검증한다.</li>
  <li>지연 초기화: 만약, 리소스가 부족하다면, 여유가 있을 때 까지 대기할 수 있다.</li>
  <li>로깅: 원본 객체와의 인터렉션을 인터셉트해 기록한다.</li>
  <li>원격 객체: 원격에 있는 객체를 로컬에 있는 객체처럼 보이도록 할 수 있다.</li>
</ul>

<p>클린 소프트웨어에서는 프록시는 사용하기 까다롭다고 언급하고 있다. 하지만 그 모든 까다로운 특성에도 불구하고 매우 강력한 이점이 한 가지 있는데, 바로 관심사의 분리이다. 프록시의 기능과 원본 객체의 기능을 분리해 생각 할 수 있다.</p>

<p>원본 객체는 자신의 책임만 집중하고 다른 책임을 프록시에 위임할 수 있다.</p>

<p>하지만, 클린 소프트웨어에서는 시간을 아끼기 위해 일단 파사드 패턴으로 시작하고 필요하면 리팩토링 할 것을 권하고 있다.</p>

<p>참고</p>

<p>퍼사드 패턴: <a href="https://inpa.tistory.com/entry/GOF-%F0%9F%92%A0-%ED%8D%BC%EC%82%AC%EB%93%9CFacade-%ED%8C%A8%ED%84%B4-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EB%B0%B0%EC%9B%8C%EB%B3%B4%EC%9E%90">https://inpa.tistory.com/entry/GOF-💠-퍼사드Facade-패턴-제대로-배워보자</a></p>

<p>프록시 패턴: <a href="https://inpa.tistory.com/entry/GOF-%F0%9F%92%A0-%ED%94%84%EB%A1%9D%EC%8B%9CProxy-%ED%8C%A8%ED%84%B4-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EB%B0%B0%EC%9B%8C%EB%B3%B4%EC%9E%90">https://inpa.tistory.com/entry/GOF-💠-프록시Proxy-패턴-제대로-배워보자</a></p>]]></content><author><name>jglee</name></author><category term="cs" /><summary type="html"><![CDATA[[클린 소프트웨어] 단일책임원칙(SRP)]]></summary></entry><entry><title type="html">[클린 소프트웨어] 애자일 설계</title><link href="https://leejigun.github.io/CleanSoftware_agile" rel="alternate" type="text/html" title="[클린 소프트웨어] 애자일 설계" /><published>2023-07-20T09:00:01+09:00</published><updated>2023-07-20T09:00:01+09:00</updated><id>https://leejigun.github.io/CleanSoftware_agile</id><content type="html" xml:base="https://leejigun.github.io/CleanSoftware_agile"><![CDATA[<h1 id="애자일-설계">애자일 설계</h1>

<blockquote>
  <p>해당 포스트는 클린 소프트웨어를 읽고 정리한 내용입니다.</p>

</blockquote>

<p>좋은 소프트웨어를 만들기 위해서는 몇 가지 요소가 필요합니다.</p>

<p>(유연하고 유지보수 가능하며 재사용 가능한 좋은 구조)</p>

<h3 id="잘못된-설계의-증상">잘못된 설계의 증상</h3>

<p>해당 책에서는 잘못된 구조로 설계된 소프트웨어의 경우 다음과 같은 증상이 보여진다고 합니다.</p>

<ol>
  <li>경직성: 설계를 변경하기 어려움</li>
  <li>취약성: 설계가 망가지기 쉬움</li>
  <li>부동성: 설계를 재사용하기 어려움</li>
  <li>점착성: 제대로 동작하기 어려움</li>
  <li>불필요한 복잡성: 과도한 설계</li>
  <li>불필요한 반복: 마우스 남용</li>
  <li>불투명성: 혼란스러운 표현</li>
</ol>

<p>이러한 증상들은 클린 코드에서의 code smell과 비슷하지만, 좀 더 높은 설계 단계에서 보여지는 증상입니다.</p>

<h3 id="악취와-원칙">악취와 원칙</h3>

<p>앞서 소개한 잘못된 설계의 증상들을 제거하기 위해 SOLID 원칙을 소개하고 있습니다. 예를 들어 경직성의 악취는 대부분 개방 폐쇄 원칙(OCP)에 충분한 주의를 기울이지 않았기 때문에 발생합니다.</p>

<p>다만, 여기서 주의해야 할 점은 악취를 제거하기 위해 원칙을 적용하지만, 아무 악취가 없을 땐 어떠한 원칙도 적용하지 않는 것입니다. 원칙에 대한 맹종은 불필요한 복잡성이란 설계의 다른 악취로 이어질 수 있습니다.</p>

<h2 id="악취">악취</h2>

<p>앞서 언급한 설계에서 발생하는 악취에 대해 좀 더 자세히 설명합니다.</p>

<ol>
  <li>경직성</li>
</ol>

<p>경직성은 소프트웨어를 변경하기 어려운 경향을 말합니다. 한 군데의 변경이 다른 모듈에 의존적이라 연쇄적으로 변경을 일으킬 때, 해당 설계는 융통성이 없는 설계로 볼 수 있습니다.</p>

<p>간단한 것처럼 보이는 변경을 요청받아 필요한 작업량을 추정하지만, 실제로 그 작업을 진행하면서 예상치 못한 곳에서 간접적으로 영향이 있다는 사실을 깨닫게 됩니다.</p>

<ol>
  <li>취약성</li>
</ol>

<p>취약성은 한 군데를 변경했을 때 프로그램의 많은 부분이 잘못되는 경향을 말합니다. 대부분의 경우 새로운 이슈는 변경한 영역과 개념적으로 아무런 관계가 없는 곳에서 발생합니다.</p>

<p>앞서 경직성과 마찬가지로 어느 한 부분의 수정이 전체에 영향을 미친다는 부분과 동일하지만, 경직성은 해당 부분을 수정하기 위해서 많은 관련 코드를 수정해야 하는 경우이고, 취약성은 어느 한 부분을 수정했는데, 다른 부분의 동작까지 영향을 미치는 경우를 뜻합니다.</p>

<p>쉽게 이해하기로는 경직성은 특정 부분을 수정했을 때 다른 곳에서 빌드 에러가 발생하는 것이고, 취약성은 QA 이슈가 발생하는 것이라 생각할 수 있을 것 같습니다.</p>

<ol>
  <li>부동성</li>
</ol>

<p>A 모듈이 B 시스템에서 유용하게 쓸 수 있는 부분이 있어서 재사용하고 싶지만, 해당 부분이 복잡하게 묶여있어 기존 시스템에서 분리하는데 수고와 위험성이 지나치게 클 때를 뜻합니다. 부동성이라 부르는 이유는 A 모듈을 B 모듈로 움직이게 해야하는데, 이동시킬 수 없기 때문에 움직일 수 없다는 뜻의 부동성을 사용하고 있습니다.</p>

<ol>
  <li>점착성</li>
</ol>

<p>점착성은 소프트웨어의 점착성과 환경의 점착성이라는 두 가지 형태로 나타납니다.</p>

<p>소프트웨어의 점착성은 무언가 변경사항이 있고, 설계를 유지하는 방법과 설계를 뜯어 고치는 방법이 있을 때 설계를 변경 사항을 적용하기 위해서 설계를 뜯어고치는게 더 쉽다면, 해당 소프트웨어의 구조는 점착성의 악취를 가지고 있다고 볼 수 있습니다. 점착성은 말 그대로 착 달라 붙어 있는 것으로 설계가 모든 부분에 착 달라붙어 무언가 수정이 필요할 때마다 설계를 뜯어 고치는게 쉬운 경우를 말합니다.</p>

<p>환경의 점착성은 이와 다르게 개발 환경이 느리고 비효율적일 때 발생합니다. 예를 들어서 컴파일 시간이 아주 길다면, 재컴파일이 적은 방법으로 변경하고 싶을 것입니다. 만약, 코드 관리 시스템에서 체크인하는데, 아주 많은 시간이 필요하다면, 적은 부분만 체크인 하고 싶을 것입니다.</p>

<p>양쪽 모두 소프트웨어의 설계를 유지하기 어려운 프로젝트입니다.</p>

<ol>
  <li>불필요한 복잡성</li>
</ol>

<p>현재 시점에 불필요한 요소가 포함된 설계를 뜻합니다. 흔히 요구사항에 대한 변경을 미리 예상하고, 잠재적인 변경을 처리하기 위해서 많은 기능을 집어넣을 때 자주 발생합니다.</p>

<p>처음에는 바람직해 보일 수 있지만, 필요없는 과도한 기능으로 구성 요소들이 어지러워 질 수 있고, 그로 인해 소프트웨어는 복잡하고 이해하기 어려워집니다.</p>

<ol>
  <li>불필요한 반복</li>
</ol>

<p>잘라내기와 붙여넣기는 작업 속도를 올려주는 아주 편리한 기능이지만, 자칫 몇십, 몇백 개의 반복된 코드 요소가 될 수 있습니다. 예를 들어서 A 코드를 복사해 B에서 조금 수정해 사용하고, B 코드를 복사해 C 에서 조금 수정해 사용하고를 반복하면 자칫 반복되는 코드가 엄청나게 쌓일 수 있고, A 부분의 수정을 위해서 B 부분 C 부분 수정이 필요 할 수 있고, 이 경우 유지보수하기 힘들게 됩니다.</p>

<p>2번 이상 사용할 시 공통화 하는 정책을 가져가도 좋습니다. 추상화를 통한 공통화를 통해서 해당 기능을 재사용하기 쉽게 할 수 있고, 테스트 코드 작성에도 쉽습니다.</p>

<ol>
  <li>불투명성</li>
</ol>

<p>모듈을 이해하기 어려운 경향을 말합니다. 시간이 지날수록 점점 더 코드가 이해하기 어렵고 불명료해지는 경향이 있습니다. 코드를 투명하게 유지하기 위해서는 지속적인 노력이 필요합니다.</p>

<p>따라서 개발자는 읽는 사람의 입장에서 생각하고 자신의 코드를 리팩토링하는 데 노력을 기울여 읽는 사람이 그것을 이해할 수 있도록 해야 합니다.</p>

<h2 id="애자일-설계란">애자일 설계란?</h2>

<p>결국 애자일 설계란 과정을 의미하는 것이지 결과를 의미하는 것은 아닙니다. 이것은 원칙, 패턴, 소프트웨어의 구조와 가독성을 향상하기 위한 방식의 연속적인 적용입니다. 모든 시점에서 시스템의 설계를 가능한 간단하고 명료하고 표현적으로 유지하려는 노력을 의미합니다.</p>

<p>매 순간 순간 악취를 캐치하고 원칙에 따라서 수정해 나가면, 클린 소프트웨어를 유지할 수 있습니다.</p>]]></content><author><name>jglee</name></author><category term="cs" /><summary type="html"><![CDATA[[클린 소프트웨어] 애자일 설계]]></summary></entry></feed>