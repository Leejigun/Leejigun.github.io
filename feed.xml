<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://leejigun.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://leejigun.github.io/" rel="alternate" type="text/html" /><updated>2025-07-27T21:50:10+09:00</updated><id>https://leejigun.github.io/feed.xml</id><title type="html">iOS 삽질 블로그</title><subtitle>iOS developer.</subtitle><entry><title type="html">Apple Foundation Models 활용기 - 주차장 태그 생성</title><link href="https://leejigun.github.io/Apple-Foundation-Models-%ED%99%9C%EC%9A%A9%EA%B8%B0%EC%A3%BC%EC%B0%A8%EC%9E%A5-%ED%83%9C%EA%B7%B8-%EC%83%9D%EC%84%B1" rel="alternate" type="text/html" title="Apple Foundation Models 활용기 - 주차장 태그 생성" /><published>2025-07-26T09:00:00+09:00</published><updated>2025-07-26T09:00:00+09:00</updated><id>https://leejigun.github.io/Apple-Foundation-Models-%ED%99%9C%EC%9A%A9%EA%B8%B0%EC%A3%BC%EC%B0%A8%EC%9E%A5-%ED%83%9C%EA%B7%B8-%EC%83%9D%EC%84%B1</id><content type="html" xml:base="https://leejigun.github.io/Apple-Foundation-Models-%ED%99%9C%EC%9A%A9%EA%B8%B0%EC%A3%BC%EC%B0%A8%EC%9E%A5-%ED%83%9C%EA%B7%B8-%EC%83%9D%EC%84%B1"><![CDATA[<h2 id="온디바이스-ai-새로운-가능성의-문을-열다-apple-foundation-models-활용기">온디바이스 AI, 새로운 가능성의 문을 열다: Apple Foundation Models 활용기</h2>

<p>WWDC25에서 공개된 <strong>Apple Foundation Models</strong>는 클라이언트 개발자들에게 혁신적인 온디바이스(On-device) AI의 시대를 예고했습니다. 클라우드 기반 AI 서비스가 범람하는 가운데, 기기 자체에서 AI 모델 추론이 이뤄진다는 것은 <strong>강력한 개인 정보 보호, 지연 없는 실시간 응답, 그리고 안정적인 오프라인 기능</strong>이라는 새로운 가능성을 제시합니다.</p>

<p>저 또한 이러한 새로운 패러다임에 대한 기대를 안고, Foundation Models를 직접 테스트해보기 위해 간단한 토이 프로젝트를 만들었습니다.</p>

<p><img src="/assets/images/ios/2025-07-26-Apple-Foundation-Models-활용기주차장-태그-생성/Jul-26-2025_20-01-18.gif" alt="Jul-26-2025 20-01-18.gif" /></p>

<h3 id="-테스트-환경-및-프로젝트-개요">🧪 테스트 환경 및 프로젝트 개요</h3>

<ul>
  <li><strong>하드웨어:</strong> Apple M1 16GB</li>
  <li><strong>운영체제:</strong> macOS 16.0 베타 (25A5316i)</li>
</ul>

<blockquote>
  <p>이 프로젝트는 <strong>MapKit</strong>을 활용하여 사용자 주변의 주차장 정보를 조회하고, 지도에 핀을 표시하는 기본적인 앱으로 시작했습니다. 기능 구현의 많은 부분은 <strong>Gemini</strong>의 도움을 받아 빠르게 진행할 수 있었습니다. 여기에 핵심적으로 <strong>Foundation Models</strong>를 적용하여 각 주차장의 특징을 나타내는 <strong>태그를 자동으로 생성</strong>하는 기능을 추가했습니다.</p>

</blockquote>

<h2 id="-foundation-models-적용-주차장-태그-자동-생성">💡 Foundation Models 적용: 주차장 태그 자동 생성</h2>

<p>태그 생성은 <code class="language-plaintext highlighter-rouge">LanguageModelSession</code>을 통해 이뤄집니다. 특정 주차장의 이름, 카테고리, 주소 등의 정보를 프롬프트로 구성하여 모델에 전달하고, 핵심 특징을 담은 태그를 요청하는 방식입니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">session</span> <span class="o">=</span> <span class="nx">LanguageModelSession</span><span class="p">(</span><span class="nx">instructions</span><span class="p">:</span> <span class="dl">"</span><span class="s2">MKMapItem 정보로 주차장 태그를 생성</span><span class="dl">"</span><span class="p">)</span>

<span class="kd">let</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">mapItem</span><span class="p">.</span><span class="nx">name</span> <span class="o">??</span> <span class="dl">"</span><span class="s2">정보 없음</span><span class="dl">"</span>
<span class="kd">let</span> <span class="nx">category</span> <span class="o">=</span> <span class="nx">mapItem</span><span class="p">.</span><span class="nx">pointOfInterestCategory</span><span class="p">?.</span><span class="nx">rawValue</span> <span class="o">??</span> <span class="dl">"</span><span class="s2">정보 없음</span><span class="dl">"</span>
<span class="kd">let</span> <span class="nx">address</span> <span class="o">=</span> <span class="nx">mapItem</span><span class="p">.</span><span class="nx">address</span><span class="p">?.</span><span class="nx">fullAddress</span> <span class="o">??</span> <span class="dl">"</span><span class="s2">정보 없음</span><span class="dl">"</span>

<span class="kd">let</span> <span class="nx">prompt</span> <span class="o">=</span> <span class="dl">"""</span><span class="s2">
    다음 주차장 정보에서 가장 핵심적인 특징을 나타내는 태그를 5개 이내로 생성해줘.
    예시 태그: #24시간, #공영, #무료, #넓은, #지하주차장, #야외주차장, #마트주차장, #병원주차장, #쇼핑몰주차장, #식당주차장, #공항주차장, #역주차장, #환승주차장, #전기차충전

    ---
    [주차장 정보]
    이름: </span><span class="se">\</span><span class="s2">(name)
    카테고리: </span><span class="se">\</span><span class="s2">(category)
    주소: </span><span class="se">\</span><span class="s2">(address)
    </span><span class="dl">"""</span>
    
<span class="k">do</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">response</span> <span class="o">=</span> <span class="k">try</span> <span class="k">await</span> <span class="nx">session</span><span class="p">.</span><span class="nx">respond</span><span class="p">(</span><span class="na">to</span><span class="p">:</span> <span class="nx">prompt</span><span class="p">,</span> <span class="na">generating</span><span class="p">:</span> <span class="nx">Tags</span><span class="p">.</span><span class="nb">self</span><span class="p">)</span>
    <span class="c1">// ... 시간 로깅 및 결과 반환 ...</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
    <span class="c1">// ... 에러 처리 ...</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="겪었던-도전과-해결-과정">겪었던 도전과 해결 과정</h3>

<p>새로운 기술을 도입하는 과정은 언제나 예측하지 못한 난관과 마주하게 됩니다. Foundation Models도 예외는 아니었습니다.</p>

<h3 id="1languagemodelsession의-동시성-제약respondto중복-호출-문제">1. <code class="language-plaintext highlighter-rouge">LanguageModelSession</code>의 동시성 제약: <code class="language-plaintext highlighter-rouge">respond(to:)</code> 중복 호출 문제</h3>

<p>가장 먼저 맞닥뜨린 문제는 모델 파싱과 함께 태그를 생성하려고 했을 때 발생한 에러였습니다. 여러 주차장에 대해 동시에 태그 생성을 요청하자 다음과 같은 메시지가 콘솔을 가득 채웠습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Attempted</span> <span class="nx">to</span> <span class="nx">call</span> <span class="nx">respond</span><span class="p">(</span><span class="nx">to</span><span class="p">:)</span> <span class="nx">a</span> <span class="nx">second</span> <span class="nx">time</span> <span class="nx">before</span> <span class="nx">the</span> <span class="nx">model</span> <span class="nx">finished</span> <span class="nx">responding</span> <span class="nx">to</span> <span class="nx">the</span> <span class="nx">previous</span> <span class="nx">prompt</span><span class="p">.</span> 
<span class="nx">You</span> <span class="nx">should</span> <span class="nx">observe</span> <span class="nx">the</span> <span class="nx">isResponding</span> <span class="nx">property</span> <span class="nx">on</span> <span class="nx">LanguageModelSession</span> <span class="nx">and</span> <span class="nx">wait</span> <span class="nx">until</span> <span class="nx">it</span> <span class="nx">becomes</span> <span class="kc">false</span> <span class="nx">before</span> <span class="nx">submitting</span> <span class="nx">another</span> <span class="nx">prompt</span><span class="p">.</span>
</code></pre></div></div>

<p>이는 <code class="language-plaintext highlighter-rouge">LanguageModelSession</code>이 한 번에 하나의 프롬프트 요청만 처리할 수 있다는 명확한 경고였습니다. 모델이 이전 응답을 완료하기 전에 다음 요청을 보내려 했기 때문에 발생한 문제였습니다.</p>

<p><strong>해결:</strong> 이 문제를 해결하기 위해, 태그 생성 로직을 담당하는 UseCase인 <code class="language-plaintext highlighter-rouge">DefaultGenerateParkingTagsUseCase</code>를 <code class="language-plaintext highlighter-rouge">actor</code>로 변경했습니다. <code class="language-plaintext highlighter-rouge">actor</code>는 Swift Concurrency에서 동시성 문제를 안전하게 다룰 수 있도록 돕는 구조입니다. 또한, <code class="language-plaintext highlighter-rouge">session.isResponding</code> 속성을 주기적으로 확인하여 모델이 이전 응답을 완료할 때까지 기다리는 방어적인 로직을 추가했습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">actor</span> <span class="nx">DefaultGenerateParkingTagsUseCase</span><span class="p">:</span> <span class="nx">GenerateParkingTagsUseCase</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="nx">func</span> <span class="nx">execute</span><span class="p">(</span><span class="nx">mapItem</span><span class="p">:</span> <span class="nx">MKMapItem</span><span class="p">)</span> <span class="k">async</span> <span class="nx">throws</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="nb">String</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">while</span> <span class="nx">session</span><span class="p">.</span><span class="nx">isResponding</span> <span class="p">{</span>
            <span class="k">try</span> <span class="k">await</span> <span class="nx">Task</span><span class="p">.</span><span class="nx">sleep</span><span class="p">(</span><span class="nx">nanoseconds</span><span class="p">:</span> <span class="mi">100</span><span class="nx">_000_000</span><span class="p">)</span>  <span class="c1">// 100ms 대기 (안정성 강화)</span>
        <span class="p">}</span>
        <span class="c1">// ... 프롬프트 전송 ...</span>
    <span class="p">}</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이제 <code class="language-plaintext highlighter-rouge">actor</code>의 직렬화된 실행과 <code class="language-plaintext highlighter-rouge">isResponding</code>을 통한 명시적인 대기 덕분에, <code class="language-plaintext highlighter-rouge">LanguageModelSession</code>은 안전하게 한 번에 하나의 요청만 처리하게 되었습니다.</p>

<h2 id="2-컨텍스트-윈도우-초과-에러exceededcontextwindowsize">2. 컨텍스트 윈도우 초과 에러: <code class="language-plaintext highlighter-rouge">exceededContextWindowSize</code></h2>

<p>동시성 문제를 해결한 후에도 <code class="language-plaintext highlighter-rouge">Fatal error</code>와 함께 <strong><code class="language-plaintext highlighter-rouge">exceededContextWindowSize</code></strong> 에러가 간헐적으로 발생했습니다. 이는 모델에게 전달하는 프롬프트의 길이가 모델이 한 번에 처리할 수 있는 최대 <strong>컨텍스트 윈도우</strong>를 초과했음을 의미합니다. 특히 한국어 텍스트는 영어에 비해 동일한 문자열 길이라도 더 많은 토큰을 차지하는 경향이 있어, 컨텍스트 윈도우 한계에 더 빨리 도달할 수 있습니다.</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">LanguageModelSession.GenerationError.exceededContextWindowSize</code></strong></li>
</ul>

<p><strong>해결:</strong> 다행히 이 에러는 WWDC 영상에서도 언급되었던 부분이었습니다. 이 에러가 발생했을 때 <strong><code class="language-plaintext highlighter-rouge">LanguageModelSession</code>을 새롭게 초기화</strong>하고 프롬프트 요청을 재시도하는 로직을 추가했습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ...</span>
<span class="k">catch</span> <span class="nx">LanguageModelSession</span><span class="p">.</span><span class="nx">GenerationError</span><span class="p">.</span><span class="nx">exceededContextWindowSize</span> <span class="p">{</span>
    <span class="c1">// ... 로깅 ...</span>
    <span class="nx">session</span> <span class="o">=</span> <span class="nx">newSession</span><span class="p">(</span><span class="nx">previousSession</span><span class="p">:</span> <span class="nx">session</span><span class="p">)</span> <span class="c1">// 새 세션 생성</span>
    <span class="k">return</span> <span class="p">(</span><span class="k">try</span><span class="p">?</span> <span class="k">await</span> <span class="nx">response</span><span class="p">(</span><span class="nx">to</span><span class="p">:</span> <span class="nx">prompt</span><span class="p">))</span> <span class="o">??</span> <span class="p">[]</span> <span class="c1">// 재시도</span>
<span class="p">}</span>
<span class="c1">// ...</span>

<span class="kr">private</span> <span class="nx">func</span> <span class="nx">newSession</span><span class="p">(</span><span class="nx">previousSession</span><span class="p">:</span> <span class="nx">LanguageModelSession</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nx">LanguageModelSession</span> <span class="p">{</span>
    <span class="c1">// 트랜스크립트의 첫/마지막만 보존하여 컨텍스트 압축 (예시)</span>
    <span class="kd">let</span> <span class="nx">entries</span> <span class="o">=</span> <span class="p">[</span>
        <span class="nx">previousSession</span><span class="p">.</span><span class="nx">transcript</span><span class="p">.</span><span class="nx">first</span><span class="p">,</span> <span class="nx">previousSession</span><span class="p">.</span><span class="nx">transcript</span><span class="p">.</span><span class="nx">last</span><span class="p">,</span>
    <span class="p">].</span><span class="nx">compactMap</span> <span class="p">{</span> <span class="nx">$0</span> <span class="p">}</span>
    <span class="kd">let</span> <span class="nx">condensedTranscript</span> <span class="o">=</span> <span class="nx">Transcript</span><span class="p">(</span><span class="nx">entries</span><span class="p">:</span> <span class="nx">entries</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">LanguageModelSession</span><span class="p">(</span><span class="nx">transcript</span><span class="p">:</span> <span class="nx">condensedTranscript</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>WWDC 영상에서도 첫번째(프롬프트)와 마지막(가장 최근 답변) 을 압축</li>
</ul>

<p>프롬프트 내용을 최대한 간결하게 줄이는 노력과 함께 이 재시도 로직을 적용하자, 해당 에러는 더 이상 발생하지 않았습니다. 이는 <strong>프롬프트 최적화</strong>와 <strong>적절한 에러 핸들링</strong>이 Foundation Models 사용에 있어 필수적임을 보여줍니다.</p>

<h3 id="3-성능-최적화-병렬-태그-생성의-필요성">3. 성능 최적화: 병렬 태그 생성의 필요성</h3>

<p>앞선 과정을 통해 기능은 안정화되었지만, 성능 문제가 대두되었습니다. 14개의 주차장 항목에 대한 태그 생성을 직렬로 처리했을 때, <strong>평균 5.56초</strong> (로그 기준)라는 시간이 소요되었습니다. 이는 모바일 앱의 사용자 경험 관점에서 매우 긴 시간입니다.</p>

<p><code class="language-plaintext highlighter-rouge">LanguageModelSession</code>이 마치 거대한 DB 모델처럼 느껴져 단일 인스턴스로 직렬 처리해야 한다고 생각했으나, 그보다는 <strong>OS의 AI 엔진에 대한 질의 세션</strong>에 가깝다는 결론에 도달했습니다. 즉, <code class="language-plaintext highlighter-rouge">LanguageModelSession</code> 인스턴스 자체가 무거운 리소스가 아니며, 여러 인스턴스를 생성하여 병렬로 사용하는 것이 가능하다는 의미였습니다.</p>

<p><strong>해결:</strong> 각 태그 생성을 <strong>독립적인 <code class="language-plaintext highlighter-rouge">Task</code>로 분리하고, 각 <code class="language-plaintext highlighter-rouge">Task</code>에서 고유한 <code class="language-plaintext highlighter-rouge">DefaultGenerateParkingTagsUseCase</code> 인스턴스를 생성하여 사용</strong>하도록 구조를 변경했습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// MARK: Tag 조회</span>
<span class="nx">func</span> <span class="nx">getTagByParkingInfo</span><span class="p">(</span><span class="nx">_</span> <span class="nx">parkingInfo</span><span class="p">:</span> <span class="nx">ParkingInfo</span><span class="p">)</span> <span class="k">async</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="nb">String</span><span class="p">]</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">useCase</span> <span class="o">=</span> <span class="nx">DefaultGenerateParkingTagsUseCase</span><span class="p">()</span>
  <span class="k">return</span> <span class="p">(</span><span class="k">try</span><span class="p">?</span> <span class="k">await</span> <span class="nx">useCase</span><span class="p">.</span><span class="nx">execute</span><span class="p">(</span><span class="nx">parkingInfo</span><span class="p">:</span> <span class="nx">parkingInfo</span><span class="p">))</span> <span class="o">??</span> <span class="p">[]</span>
<span class="p">}</span>
</code></pre></div></div>

<p>놀랍게도, 이 접근 방식을 적용하자 <strong>명시적인 에러 메시지 없이</strong> 태그 생성이 훨씬 빠르게 진행되기 시작했습니다. 이는 여러 <code class="language-plaintext highlighter-rouge">LanguageModelSession</code> 인스턴스가 각자의 스레드 또는 Concurrency 환경에서 병렬적으로 모델 추론을 요청할 수 있음을 시사합니다.</p>

<h3 id="맺음말-온디바이스-ai의-현재와-미래">맺음말: 온디바이스 AI의 현재와 미래</h3>

<p>Apple Foundation Models는 온디바이스 AI의 강력한 가능성을 제시하지만, 현재 베타 단계에서는 몇 가지 주의사항을 요구합니다.</p>

<ul>
  <li><strong>동시성 관리:</strong> <code class="language-plaintext highlighter-rouge">LanguageModelSession</code>의 직렬 처리 제약을 이해하고 <code class="language-plaintext highlighter-rouge">actor</code>와 <code class="language-plaintext highlighter-rouge">isResponding</code> 폴링으로 안전하게 다루는 것이 중요합니다.</li>
  <li><strong>프롬프트 최적화:</strong> 컨텍스트 윈도우 한계를 고려하여 프롬프트를 간결하게 유지해야 합니다.</li>
  <li><strong>성능 최적화:</strong> 필요하다면 여러 <code class="language-plaintext highlighter-rouge">LanguageModelSession</code> 인스턴스를 병렬로 사용하여 사용자 경험을 개선할 수 있습니다.</li>
  <li><strong>디버깅 및 피드백:</strong> 상세한 로깅과 Apple Feedback Assistant를 통한 피드백은 개발 과정에서 큰 도움이 됩니다.</li>
</ul>

<p>제가 경험한 것처럼, 온디바이스 AI는 여전히 발전 중인 분야이며, 그 활용에는 섬세한 접근이 필요합니다. 하지만 기기 자체에서 강력한 AI 기능을 구현할 수 있다는 점은 분명 모바일 앱 개발에 새로운 혁신을 가져올 것입니다. 앞으로 Foundation Models가 더욱 성숙해져, 개발자들이 더 쉽고 강력하게 온디바이스 AI를 활용할 수 있기를 기대합니다.</p>

<p><img src="/assets/images/ios/2025-07-26-Apple-Foundation-Models-활용기주차장-태그-생성/image.png" alt="image.png" /></p>

<p>Git: https://github.com/Leejigun/FoundationModels_ParkingLot</p>

<h2 id="관련-코드">관련 코드</h2>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">protocol</span> <span class="nx">GenerateParkingTagsUseCase</span> <span class="p">{</span>
    <span class="nx">func</span> <span class="nx">execute</span><span class="p">(</span><span class="nx">mapItem</span><span class="p">:</span> <span class="nx">MKMapItem</span><span class="p">)</span> <span class="k">async</span> <span class="nx">throws</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="nb">String</span><span class="p">]</span>
    <span class="nx">func</span> <span class="nx">execute</span><span class="p">(</span><span class="nx">parkingInfo</span><span class="p">:</span> <span class="nx">ParkingInfo</span><span class="p">)</span> <span class="k">async</span> <span class="nx">throws</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="nb">String</span><span class="p">]</span>
<span class="p">}</span>

<span class="p">@</span><span class="nd">Generable</span><span class="p">(</span><span class="nx">description</span><span class="p">:</span> <span class="dl">"</span><span class="s2">주차장 특성 태그</span><span class="dl">"</span><span class="p">)</span>
<span class="nx">struct</span> <span class="nx">Tags</span> <span class="p">{</span>
    <span class="p">@</span><span class="nd">Guide</span><span class="p">(</span><span class="nx">description</span><span class="p">:</span> <span class="dl">"</span><span class="s2">MKMapItem 기반으로 주차장의 특징을 태그로 생성</span><span class="dl">"</span><span class="p">)</span>
    <span class="kr">public</span> <span class="kd">let</span> <span class="nx">tags</span><span class="p">:</span> <span class="p">[</span><span class="nb">String</span><span class="p">]</span>
<span class="p">}</span>

<span class="nx">actor</span> <span class="nx">DefaultGenerateParkingTagsUseCase</span><span class="p">:</span> <span class="nx">GenerateParkingTagsUseCase</span> <span class="p">{</span>

    <span class="kd">var</span> <span class="nx">session</span> <span class="o">=</span> <span class="nx">LanguageModelSession</span><span class="p">(</span><span class="nx">instructions</span><span class="p">:</span> <span class="dl">"</span><span class="s2">MKMapItem 정보로 주차장 태그를 생성</span><span class="dl">"</span><span class="p">)</span>

    <span class="nx">func</span> <span class="nx">execute</span><span class="p">(</span><span class="nx">mapItem</span><span class="p">:</span> <span class="nx">MKMapItem</span><span class="p">)</span> <span class="k">async</span> <span class="nx">throws</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="nb">String</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">while</span> <span class="nx">session</span><span class="p">.</span><span class="nx">isResponding</span> <span class="p">{</span>
            <span class="k">try</span> <span class="k">await</span> <span class="nx">Task</span><span class="p">.</span><span class="nx">sleep</span><span class="p">(</span><span class="nx">nanoseconds</span><span class="p">:</span> <span class="mi">100</span><span class="nx">_000_000</span><span class="p">)</span>  <span class="c1">// 대기 시간 100ms로 늘려 안정성 강화</span>
        <span class="p">}</span>

        <span class="kd">let</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">mapItem</span><span class="p">.</span><span class="nx">name</span> <span class="o">??</span> <span class="dl">"</span><span class="s2">정보 없음</span><span class="dl">"</span>
        <span class="kd">let</span> <span class="nx">category</span> <span class="o">=</span> <span class="nx">mapItem</span><span class="p">.</span><span class="nx">pointOfInterestCategory</span><span class="p">?.</span><span class="nx">rawValue</span> <span class="o">??</span> <span class="dl">"</span><span class="s2">정보 없음</span><span class="dl">"</span>
        <span class="kd">let</span> <span class="nx">address</span> <span class="o">=</span> <span class="nx">mapItem</span><span class="p">.</span><span class="nx">address</span><span class="p">?.</span><span class="nx">fullAddress</span> <span class="o">??</span> <span class="dl">"</span><span class="s2">정보 없음</span><span class="dl">"</span>

        <span class="kd">let</span> <span class="nx">prompt</span> <span class="o">=</span> <span class="dl">"""</span><span class="s2">
            다음 주차장 정보에서 가장 핵심적인 특징을 나타내는 태그를 5개 이내로 생성해줘.
            예시 태그: #24시간, #공영, #무료, #넓은, #지하주차장, #야외주차장, #마트주차장, #병원주차장, #쇼핑몰주차장, #식당주차장, #공항주차장, #역주차장, #환승주차장, #전기차충전

            ---
            [주차장 정보]
            이름: </span><span class="se">\</span><span class="s2">(name)
            카테고리: </span><span class="se">\</span><span class="s2">(category)
            주소: </span><span class="se">\</span><span class="s2">(address)
            </span><span class="dl">"""</span>
        <span class="k">return</span> <span class="k">try</span> <span class="k">await</span> <span class="nx">response</span><span class="p">(</span><span class="nx">to</span><span class="p">:</span> <span class="nx">prompt</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">func</span> <span class="nx">execute</span><span class="p">(</span><span class="nx">parkingInfo</span><span class="p">:</span> <span class="nx">ParkingInfo</span><span class="p">)</span> <span class="k">async</span> <span class="nx">throws</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="nb">String</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">while</span> <span class="nx">session</span><span class="p">.</span><span class="nx">isResponding</span> <span class="p">{</span>
            <span class="k">try</span> <span class="k">await</span> <span class="nx">Task</span><span class="p">.</span><span class="nx">sleep</span><span class="p">(</span><span class="nx">nanoseconds</span><span class="p">:</span> <span class="mi">100</span><span class="nx">_000_000</span><span class="p">)</span>  <span class="c1">// 대기 시간 100ms로 늘려 안정성 강화</span>
        <span class="p">}</span>

        <span class="kd">let</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">parkingInfo</span><span class="p">.</span><span class="nx">name</span>
        <span class="kd">let</span> <span class="nx">distance</span> <span class="o">=</span> <span class="nx">parkingInfo</span><span class="p">.</span><span class="nx">distance</span> <span class="o">??</span> <span class="dl">"</span><span class="s2">정보없음</span><span class="dl">"</span>
        <span class="kd">let</span> <span class="nx">address</span> <span class="o">=</span> <span class="nx">parkingInfo</span><span class="p">.</span><span class="nx">address</span> <span class="o">??</span> <span class="dl">"</span><span class="s2">정보없음</span><span class="dl">"</span>

        <span class="kd">let</span> <span class="nx">prompt</span> <span class="o">=</span> <span class="dl">"""</span><span class="s2">
            다음 주차장 정보에서 가장 핵심적인 특징을 나타내는 태그를 5개 이내로 생성해줘.
            예시 태그: #24시간, #공영, #무료, #넓은, #지하주차장, #야외주차장, #마트주차장, #병원주차장, #쇼핑몰주차장, #식당주차장, #공항주차장, #역주차장, #환승주차장, #전기차충전, #가까운, #먼

            ---
            [주차장 정보]
            이름: </span><span class="se">\</span><span class="s2">(name)
            거리: </span><span class="se">\</span><span class="s2">(distance)
            주소: </span><span class="se">\</span><span class="s2">(address)
            </span><span class="dl">"""</span>
        <span class="k">return</span> <span class="k">try</span> <span class="k">await</span> <span class="nx">response</span><span class="p">(</span><span class="nx">to</span><span class="p">:</span> <span class="nx">prompt</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kr">private</span> <span class="nx">func</span> <span class="nx">response</span><span class="p">(</span><span class="nx">to</span> <span class="nx">prompt</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="k">async</span> <span class="nx">throws</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="nb">String</span><span class="p">]</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">startTime</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">()</span>
        <span class="k">do</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="nx">response</span> <span class="o">=</span> <span class="k">try</span> <span class="k">await</span> <span class="nx">session</span><span class="p">.</span><span class="nx">respond</span><span class="p">(</span>
                <span class="na">to</span><span class="p">:</span> <span class="nx">prompt</span><span class="p">,</span>
                <span class="na">generating</span><span class="p">:</span> <span class="nx">Tags</span><span class="p">.</span><span class="nb">self</span>
            <span class="p">)</span>
            
            <span class="kd">let</span> <span class="nx">timeElapsed</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">().</span><span class="nx">timeIntervalSince</span><span class="p">(</span><span class="nx">startTime</span><span class="p">)</span>
            <span class="nx">print</span><span class="p">(</span>
                <span class="dl">"</span><span class="s2">DEBUG: Model responded in </span><span class="se">\</span><span class="s2">(String(format: </span><span class="dl">"</span><span class="o">%</span><span class="p">.</span><span class="mi">2</span><span class="nx">f</span><span class="dl">"</span><span class="s2">, timeElapsed)) seconds for prompt:</span><span class="se">\n\</span><span class="s2">(prompt)</span><span class="se">\n</span><span class="s2">- </span><span class="se">\</span><span class="s2">(response.content.tags)</span><span class="se">\n</span><span class="dl">"</span>
            <span class="p">)</span>
            
            <span class="k">return</span> <span class="nx">response</span><span class="p">.</span><span class="nx">content</span><span class="p">.</span><span class="nx">tags</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="nx">LanguageModelSession</span><span class="p">.</span><span class="nx">GenerationError</span><span class="p">.</span><span class="nx">exceededContextWindowSize</span> <span class="p">{</span>
            
            <span class="kd">let</span> <span class="nx">timeElapsed</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">().</span><span class="nx">timeIntervalSince</span><span class="p">(</span><span class="nx">startTime</span><span class="p">)</span>
            <span class="nx">print</span><span class="p">(</span>
                <span class="dl">"</span><span class="s2">DEBUG: Model exceeded context window in </span><span class="se">\</span><span class="s2">(String(format: </span><span class="dl">"</span><span class="o">%</span><span class="p">.</span><span class="mi">2</span><span class="nx">f</span><span class="dl">"</span><span class="s2">, timeElapsed)) seconds for prompt:</span><span class="se">\n\</span><span class="s2">(prompt)</span><span class="se">\n</span><span class="s2">- exceededContextWindowSize</span><span class="se">\n</span><span class="dl">"</span>
            <span class="p">)</span>
            
            <span class="nx">session</span> <span class="o">=</span> <span class="nx">newSession</span><span class="p">(</span><span class="nx">previousSession</span><span class="p">:</span> <span class="nx">session</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="k">try</span><span class="p">?</span> <span class="k">await</span> <span class="nx">response</span><span class="p">(</span><span class="nx">to</span><span class="p">:</span> <span class="nx">prompt</span><span class="p">))</span> <span class="o">??</span> <span class="p">[]</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
            
            <span class="kd">let</span> <span class="nx">timeElapsed</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">().</span><span class="nx">timeIntervalSince</span><span class="p">(</span><span class="nx">startTime</span><span class="p">)</span>
            <span class="nx">print</span><span class="p">(</span>
                <span class="dl">"</span><span class="s2">DEBUG: Model exceeded context window in </span><span class="se">\</span><span class="s2">(String(format: </span><span class="dl">"</span><span class="o">%</span><span class="p">.</span><span class="mi">2</span><span class="nx">f</span><span class="dl">"</span><span class="s2">, timeElapsed)) seconds for prompt:</span><span class="se">\n\</span><span class="s2">(prompt)</span><span class="se">\n</span><span class="s2">- </span><span class="se">\</span><span class="s2">(error.localizedDescription)</span><span class="se">\n</span><span class="dl">"</span>
            <span class="p">)</span>
            
            <span class="k">return</span> <span class="p">[]</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kr">private</span> <span class="nx">func</span> <span class="nx">newSession</span><span class="p">(</span><span class="nx">previousSession</span><span class="p">:</span> <span class="nx">LanguageModelSession</span><span class="p">)</span>
        <span class="o">-&gt;</span> <span class="nx">LanguageModelSession</span>
    <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">entries</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nx">previousSession</span><span class="p">.</span><span class="nx">transcript</span><span class="p">.</span><span class="nx">first</span><span class="p">,</span> <span class="nx">previousSession</span><span class="p">.</span><span class="nx">transcript</span><span class="p">.</span><span class="nx">last</span><span class="p">,</span>
        <span class="p">].</span><span class="nx">compactMap</span> <span class="p">{</span> <span class="nx">$0</span> <span class="p">}</span>
        <span class="kd">let</span> <span class="nx">condensedTranscript</span> <span class="o">=</span> <span class="nx">Transcript</span><span class="p">(</span><span class="nx">entries</span><span class="p">:</span> <span class="nx">entries</span><span class="p">)</span>
        <span class="k">return</span> <span class="nx">LanguageModelSession</span><span class="p">(</span><span class="nx">transcript</span><span class="p">:</span> <span class="nx">condensedTranscript</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="디버그-로그">디버그 로그</h2>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">DEBUG</span><span class="p">:</span> <span class="nx">Model</span> <span class="nx">responded</span> <span class="k">in</span> <span class="mf">3.68</span> <span class="nx">seconds</span> <span class="k">for</span> <span class="nx">prompt</span><span class="p">:</span>
<span class="nx">다음</span> <span class="nx">주차장</span> <span class="nx">정보에서</span> <span class="nx">가장</span> <span class="nx">핵심적인</span> <span class="nx">특징을</span> <span class="nx">나타내는</span> <span class="nx">태그를</span> <span class="mi">5</span><span class="nx">개</span> <span class="nx">이내로</span> <span class="nx">생성해줘</span><span class="p">.</span>
<span class="nx">예시</span> <span class="nx">태그</span><span class="p">:</span> <span class="err">#</span><span class="mi">24</span><span class="nx">시간</span><span class="p">,</span> <span class="err">#</span><span class="nx">공영</span><span class="p">,</span> <span class="err">#</span><span class="nx">무료</span><span class="p">,</span> <span class="err">#</span><span class="nx">넓은</span><span class="p">,</span> <span class="err">#</span><span class="nx">지하주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">야외주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">마트주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">병원주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">쇼핑몰주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">식당주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">공항주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">역주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">환승주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">전기차충전</span><span class="p">,</span> <span class="err">#</span><span class="nx">가까운</span><span class="p">,</span> <span class="err">#</span><span class="nx">먼</span>

<span class="o">---</span>
<span class="p">[</span><span class="nx">주차장</span> <span class="nx">정보</span><span class="p">]</span>
<span class="nx">이름</span><span class="p">:</span> <span class="nx">수양유료주차장</span>
<span class="nx">거리</span><span class="p">:</span> <span class="mf">755.565</span><span class="nx">m</span>
<span class="nx">주소</span><span class="p">:</span> <span class="nx">대한민국</span> <span class="nx">서울특별시</span> <span class="nx">은평구</span> <span class="nx">불광동</span> <span class="mi">13</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">03360</span>
<span class="o">-</span> <span class="p">[</span><span class="dl">"</span><span class="s2">#유료주차장</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">#넓은주차장</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">#서울주차장</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">#은평구주차장</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">#서울특별시주차장</span><span class="dl">"</span><span class="p">]</span>

<span class="nx">DEBUG</span><span class="p">:</span> <span class="nx">Model</span> <span class="nx">responded</span> <span class="k">in</span> <span class="mf">4.63</span> <span class="nx">seconds</span> <span class="k">for</span> <span class="nx">prompt</span><span class="p">:</span>
<span class="nx">다음</span> <span class="nx">주차장</span> <span class="nx">정보에서</span> <span class="nx">가장</span> <span class="nx">핵심적인</span> <span class="nx">특징을</span> <span class="nx">나타내는</span> <span class="nx">태그를</span> <span class="mi">5</span><span class="nx">개</span> <span class="nx">이내로</span> <span class="nx">생성해줘</span><span class="p">.</span>
<span class="nx">예시</span> <span class="nx">태그</span><span class="p">:</span> <span class="err">#</span><span class="mi">24</span><span class="nx">시간</span><span class="p">,</span> <span class="err">#</span><span class="nx">공영</span><span class="p">,</span> <span class="err">#</span><span class="nx">무료</span><span class="p">,</span> <span class="err">#</span><span class="nx">넓은</span><span class="p">,</span> <span class="err">#</span><span class="nx">지하주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">야외주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">마트주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">병원주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">쇼핑몰주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">식당주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">공항주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">역주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">환승주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">전기차충전</span><span class="p">,</span> <span class="err">#</span><span class="nx">가까운</span><span class="p">,</span> <span class="err">#</span><span class="nx">먼</span>

<span class="o">---</span>
<span class="p">[</span><span class="nx">주차장</span> <span class="nx">정보</span><span class="p">]</span>
<span class="nx">이름</span><span class="p">:</span> <span class="nx">연신내유료주차장</span>
<span class="nx">거리</span><span class="p">:</span> <span class="mf">501.125</span><span class="nx">m</span>
<span class="nx">주소</span><span class="p">:</span> <span class="nx">대한민국</span> <span class="nx">서울특별시</span> <span class="nx">은평구</span> <span class="nx">불광동</span> <span class="mi">81</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="mi">03338</span>
<span class="o">-</span> <span class="p">[</span><span class="dl">"</span><span class="s2">#유료</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">#연신내</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">#서울</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">#주차장</span><span class="dl">"</span><span class="p">]</span>

<span class="nx">DEBUG</span><span class="p">:</span> <span class="nx">Model</span> <span class="nx">responded</span> <span class="k">in</span> <span class="mf">5.75</span> <span class="nx">seconds</span> <span class="k">for</span> <span class="nx">prompt</span><span class="p">:</span>
<span class="nx">다음</span> <span class="nx">주차장</span> <span class="nx">정보에서</span> <span class="nx">가장</span> <span class="nx">핵심적인</span> <span class="nx">특징을</span> <span class="nx">나타내는</span> <span class="nx">태그를</span> <span class="mi">5</span><span class="nx">개</span> <span class="nx">이내로</span> <span class="nx">생성해줘</span><span class="p">.</span>
<span class="nx">예시</span> <span class="nx">태그</span><span class="p">:</span> <span class="err">#</span><span class="mi">24</span><span class="nx">시간</span><span class="p">,</span> <span class="err">#</span><span class="nx">공영</span><span class="p">,</span> <span class="err">#</span><span class="nx">무료</span><span class="p">,</span> <span class="err">#</span><span class="nx">넓은</span><span class="p">,</span> <span class="err">#</span><span class="nx">지하주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">야외주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">마트주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">병원주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">쇼핑몰주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">식당주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">공항주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">역주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">환승주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">전기차충전</span><span class="p">,</span> <span class="err">#</span><span class="nx">가까운</span><span class="p">,</span> <span class="err">#</span><span class="nx">먼</span>

<span class="o">---</span>
<span class="p">[</span><span class="nx">주차장</span> <span class="nx">정보</span><span class="p">]</span>
<span class="nx">이름</span><span class="p">:</span> <span class="nx">연광초등학교지하공동주차장</span>
<span class="nx">거리</span><span class="p">:</span> <span class="mf">877.267</span><span class="nx">m</span>
<span class="nx">주소</span><span class="p">:</span> <span class="nx">대한민국</span> <span class="nx">서울특별시</span> <span class="nx">은평구</span> <span class="nx">연서로35길</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">03342</span>
<span class="o">-</span> <span class="p">[</span><span class="dl">"</span><span class="s2">지하주차장</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">공영</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">연광초등학교</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">서울특별시</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">은평구</span><span class="dl">"</span><span class="p">]</span>

<span class="nx">DEBUG</span><span class="p">:</span> <span class="nx">Model</span> <span class="nx">responded</span> <span class="k">in</span> <span class="mf">7.26</span> <span class="nx">seconds</span> <span class="k">for</span> <span class="nx">prompt</span><span class="p">:</span>
<span class="nx">다음</span> <span class="nx">주차장</span> <span class="nx">정보에서</span> <span class="nx">가장</span> <span class="nx">핵심적인</span> <span class="nx">특징을</span> <span class="nx">나타내는</span> <span class="nx">태그를</span> <span class="mi">5</span><span class="nx">개</span> <span class="nx">이내로</span> <span class="nx">생성해줘</span><span class="p">.</span>
<span class="nx">예시</span> <span class="nx">태그</span><span class="p">:</span> <span class="err">#</span><span class="mi">24</span><span class="nx">시간</span><span class="p">,</span> <span class="err">#</span><span class="nx">공영</span><span class="p">,</span> <span class="err">#</span><span class="nx">무료</span><span class="p">,</span> <span class="err">#</span><span class="nx">넓은</span><span class="p">,</span> <span class="err">#</span><span class="nx">지하주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">야외주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">마트주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">병원주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">쇼핑몰주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">식당주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">공항주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">역주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">환승주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">전기차충전</span><span class="p">,</span> <span class="err">#</span><span class="nx">가까운</span><span class="p">,</span> <span class="err">#</span><span class="nx">먼</span>

<span class="o">---</span>
<span class="p">[</span><span class="nx">주차장</span> <span class="nx">정보</span><span class="p">]</span>
<span class="nx">이름</span><span class="p">:</span> <span class="nx">불광2동거주자우선주차장</span>
<span class="nx">거리</span><span class="p">:</span> <span class="mf">725.101</span><span class="nx">m</span>
<span class="nx">주소</span><span class="p">:</span> <span class="nx">대한민국</span> <span class="nx">서울특별시</span> <span class="nx">은평구</span> <span class="nx">불광동</span> <span class="mi">131</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">03347</span>
<span class="o">-</span> <span class="p">[</span><span class="dl">"</span><span class="s2">#지하주차장</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">#공영주차장</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">#서울특별시주차장</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">#은평구주차장</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">#주거지역주차장</span><span class="dl">"</span><span class="p">]</span>

<span class="nx">DEBUG</span><span class="p">:</span> <span class="nx">Model</span> <span class="nx">responded</span> <span class="k">in</span> <span class="mf">8.03</span> <span class="nx">seconds</span> <span class="k">for</span> <span class="nx">prompt</span><span class="p">:</span>
<span class="nx">다음</span> <span class="nx">주차장</span> <span class="nx">정보에서</span> <span class="nx">가장</span> <span class="nx">핵심적인</span> <span class="nx">특징을</span> <span class="nx">나타내는</span> <span class="nx">태그를</span> <span class="mi">5</span><span class="nx">개</span> <span class="nx">이내로</span> <span class="nx">생성해줘</span><span class="p">.</span>
<span class="nx">예시</span> <span class="nx">태그</span><span class="p">:</span> <span class="err">#</span><span class="mi">24</span><span class="nx">시간</span><span class="p">,</span> <span class="err">#</span><span class="nx">공영</span><span class="p">,</span> <span class="err">#</span><span class="nx">무료</span><span class="p">,</span> <span class="err">#</span><span class="nx">넓은</span><span class="p">,</span> <span class="err">#</span><span class="nx">지하주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">야외주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">마트주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">병원주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">쇼핑몰주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">식당주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">공항주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">역주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">환승주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">전기차충전</span><span class="p">,</span> <span class="err">#</span><span class="nx">가까운</span><span class="p">,</span> <span class="err">#</span><span class="nx">먼</span>

<span class="o">---</span>
<span class="p">[</span><span class="nx">주차장</span> <span class="nx">정보</span><span class="p">]</span>
<span class="nx">이름</span><span class="p">:</span> <span class="nx">연신중학교</span>
<span class="nx">거리</span><span class="p">:</span> <span class="mf">754.294</span><span class="nx">m</span>
<span class="nx">주소</span><span class="p">:</span> <span class="nx">대한민국</span> <span class="nx">서울특별시</span> <span class="nx">은평구</span> <span class="nx">연서로33길</span> <span class="mi">16</span><span class="o">-</span><span class="mi">32</span><span class="p">,</span> <span class="mi">03342</span>
<span class="o">-</span> <span class="p">[</span><span class="dl">"</span><span class="s2">#학교주차장</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">#서울특별시</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">#은평구</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">#연신중학교</span><span class="dl">"</span><span class="p">]</span>

<span class="nx">DEBUG</span><span class="p">:</span> <span class="nx">Model</span> <span class="nx">responded</span> <span class="k">in</span> <span class="mf">1.60</span> <span class="nx">seconds</span> <span class="k">for</span> <span class="nx">prompt</span><span class="p">:</span>
<span class="nx">다음</span> <span class="nx">주차장</span> <span class="nx">정보에서</span> <span class="nx">가장</span> <span class="nx">핵심적인</span> <span class="nx">특징을</span> <span class="nx">나타내는</span> <span class="nx">태그를</span> <span class="mi">5</span><span class="nx">개</span> <span class="nx">이내로</span> <span class="nx">생성해줘</span><span class="p">.</span>
<span class="nx">예시</span> <span class="nx">태그</span><span class="p">:</span> <span class="err">#</span><span class="mi">24</span><span class="nx">시간</span><span class="p">,</span> <span class="err">#</span><span class="nx">공영</span><span class="p">,</span> <span class="err">#</span><span class="nx">무료</span><span class="p">,</span> <span class="err">#</span><span class="nx">넓은</span><span class="p">,</span> <span class="err">#</span><span class="nx">지하주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">야외주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">마트주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">병원주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">쇼핑몰주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">식당주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">공항주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">역주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">환승주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">전기차충전</span><span class="p">,</span> <span class="err">#</span><span class="nx">가까운</span><span class="p">,</span> <span class="err">#</span><span class="nx">먼</span>

<span class="o">---</span>
<span class="p">[</span><span class="nx">주차장</span> <span class="nx">정보</span><span class="p">]</span>
<span class="nx">이름</span><span class="p">:</span> <span class="nx">새장골공영주차장</span>
<span class="nx">거리</span><span class="p">:</span> <span class="mf">883.138</span><span class="nx">m</span>
<span class="nx">주소</span><span class="p">:</span> <span class="nx">대한민국</span> <span class="nx">서울특별시</span> <span class="nx">은평구</span> <span class="nx">불광동</span> <span class="mi">480</span><span class="o">-</span><span class="mi">352</span><span class="p">,</span> <span class="mi">03340</span>
<span class="o">-</span> <span class="p">[</span><span class="dl">"</span><span class="s2">#공영</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">#무료</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">#넓은</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">#지하주차장</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">#서울특별시</span><span class="dl">"</span><span class="p">]</span>

<span class="nx">DEBUG</span><span class="p">:</span> <span class="nx">Model</span> <span class="nx">responded</span> <span class="k">in</span> <span class="mf">3.48</span> <span class="nx">seconds</span> <span class="k">for</span> <span class="nx">prompt</span><span class="p">:</span>
<span class="nx">다음</span> <span class="nx">주차장</span> <span class="nx">정보에서</span> <span class="nx">가장</span> <span class="nx">핵심적인</span> <span class="nx">특징을</span> <span class="nx">나타내는</span> <span class="nx">태그를</span> <span class="mi">5</span><span class="nx">개</span> <span class="nx">이내로</span> <span class="nx">생성해줘</span><span class="p">.</span>
<span class="nx">예시</span> <span class="nx">태그</span><span class="p">:</span> <span class="err">#</span><span class="mi">24</span><span class="nx">시간</span><span class="p">,</span> <span class="err">#</span><span class="nx">공영</span><span class="p">,</span> <span class="err">#</span><span class="nx">무료</span><span class="p">,</span> <span class="err">#</span><span class="nx">넓은</span><span class="p">,</span> <span class="err">#</span><span class="nx">지하주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">야외주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">마트주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">병원주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">쇼핑몰주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">식당주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">공항주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">역주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">환승주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">전기차충전</span><span class="p">,</span> <span class="err">#</span><span class="nx">가까운</span><span class="p">,</span> <span class="err">#</span><span class="nx">먼</span>

<span class="o">---</span>
<span class="p">[</span><span class="nx">주차장</span> <span class="nx">정보</span><span class="p">]</span>
<span class="nx">이름</span><span class="p">:</span> <span class="nx">불광2동거주자우선주차장</span>
<span class="nx">거리</span><span class="p">:</span> <span class="mf">725.101</span><span class="nx">m</span>
<span class="nx">주소</span><span class="p">:</span> <span class="nx">대한민국</span> <span class="nx">서울특별시</span> <span class="nx">은평구</span> <span class="nx">불광동</span> <span class="mi">131</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">03347</span>
<span class="o">-</span> <span class="p">[</span><span class="dl">"</span><span class="s2">#주거지우선주차장</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">#지하주차장</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">#서울특별시</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">#은평구</span><span class="dl">"</span><span class="p">]</span>

<span class="nx">DEBUG</span><span class="p">:</span> <span class="nx">Model</span> <span class="nx">responded</span> <span class="k">in</span> <span class="mf">4.63</span> <span class="nx">seconds</span> <span class="k">for</span> <span class="nx">prompt</span><span class="p">:</span>
<span class="nx">다음</span> <span class="nx">주차장</span> <span class="nx">정보에서</span> <span class="nx">가장</span> <span class="nx">핵심적인</span> <span class="nx">특징을</span> <span class="nx">나타내는</span> <span class="nx">태그를</span> <span class="mi">5</span><span class="nx">개</span> <span class="nx">이내로</span> <span class="nx">생성해줘</span><span class="p">.</span>
<span class="nx">예시</span> <span class="nx">태그</span><span class="p">:</span> <span class="err">#</span><span class="mi">24</span><span class="nx">시간</span><span class="p">,</span> <span class="err">#</span><span class="nx">공영</span><span class="p">,</span> <span class="err">#</span><span class="nx">무료</span><span class="p">,</span> <span class="err">#</span><span class="nx">넓은</span><span class="p">,</span> <span class="err">#</span><span class="nx">지하주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">야외주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">마트주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">병원주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">쇼핑몰주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">식당주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">공항주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">역주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">환승주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">전기차충전</span><span class="p">,</span> <span class="err">#</span><span class="nx">가까운</span><span class="p">,</span> <span class="err">#</span><span class="nx">먼</span>

<span class="o">---</span>
<span class="p">[</span><span class="nx">주차장</span> <span class="nx">정보</span><span class="p">]</span>
<span class="nx">이름</span><span class="p">:</span> <span class="nx">수양유료주차장</span>
<span class="nx">거리</span><span class="p">:</span> <span class="mf">755.565</span><span class="nx">m</span>
<span class="nx">주소</span><span class="p">:</span> <span class="nx">대한민국</span> <span class="nx">서울특별시</span> <span class="nx">은평구</span> <span class="nx">불광동</span> <span class="mi">13</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">03360</span>
<span class="o">-</span> <span class="p">[</span><span class="dl">"</span><span class="s2">유료</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">넓은</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">서울</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">주차장</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">주차</span><span class="dl">"</span><span class="p">]</span>

<span class="nx">DEBUG</span><span class="p">:</span> <span class="nx">Model</span> <span class="nx">responded</span> <span class="k">in</span> <span class="mf">5.68</span> <span class="nx">seconds</span> <span class="k">for</span> <span class="nx">prompt</span><span class="p">:</span>
<span class="nx">다음</span> <span class="nx">주차장</span> <span class="nx">정보에서</span> <span class="nx">가장</span> <span class="nx">핵심적인</span> <span class="nx">특징을</span> <span class="nx">나타내는</span> <span class="nx">태그를</span> <span class="mi">5</span><span class="nx">개</span> <span class="nx">이내로</span> <span class="nx">생성해줘</span><span class="p">.</span>
<span class="nx">예시</span> <span class="nx">태그</span><span class="p">:</span> <span class="err">#</span><span class="mi">24</span><span class="nx">시간</span><span class="p">,</span> <span class="err">#</span><span class="nx">공영</span><span class="p">,</span> <span class="err">#</span><span class="nx">무료</span><span class="p">,</span> <span class="err">#</span><span class="nx">넓은</span><span class="p">,</span> <span class="err">#</span><span class="nx">지하주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">야외주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">마트주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">병원주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">쇼핑몰주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">식당주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">공항주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">역주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">환승주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">전기차충전</span><span class="p">,</span> <span class="err">#</span><span class="nx">가까운</span><span class="p">,</span> <span class="err">#</span><span class="nx">먼</span>

<span class="o">---</span>
<span class="p">[</span><span class="nx">주차장</span> <span class="nx">정보</span><span class="p">]</span>
<span class="nx">이름</span><span class="p">:</span> <span class="nx">연신중학교</span>
<span class="nx">거리</span><span class="p">:</span> <span class="mf">754.294</span><span class="nx">m</span>
<span class="nx">주소</span><span class="p">:</span> <span class="nx">대한민국</span> <span class="nx">서울특별시</span> <span class="nx">은평구</span> <span class="nx">연서로33길</span> <span class="mi">16</span><span class="o">-</span><span class="mi">32</span><span class="p">,</span> <span class="mi">03342</span>
<span class="o">-</span> <span class="p">[</span><span class="dl">"</span><span class="s2">#근처</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">#연신중학교</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">#서울특별시</span><span class="dl">"</span><span class="p">]</span>

<span class="nx">DEBUG</span><span class="p">:</span> <span class="nx">Model</span> <span class="nx">responded</span> <span class="k">in</span> <span class="mf">6.71</span> <span class="nx">seconds</span> <span class="k">for</span> <span class="nx">prompt</span><span class="p">:</span>
<span class="nx">다음</span> <span class="nx">주차장</span> <span class="nx">정보에서</span> <span class="nx">가장</span> <span class="nx">핵심적인</span> <span class="nx">특징을</span> <span class="nx">나타내는</span> <span class="nx">태그를</span> <span class="mi">5</span><span class="nx">개</span> <span class="nx">이내로</span> <span class="nx">생성해줘</span><span class="p">.</span>
<span class="nx">예시</span> <span class="nx">태그</span><span class="p">:</span> <span class="err">#</span><span class="mi">24</span><span class="nx">시간</span><span class="p">,</span> <span class="err">#</span><span class="nx">공영</span><span class="p">,</span> <span class="err">#</span><span class="nx">무료</span><span class="p">,</span> <span class="err">#</span><span class="nx">넓은</span><span class="p">,</span> <span class="err">#</span><span class="nx">지하주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">야외주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">마트주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">병원주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">쇼핑몰주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">식당주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">공항주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">역주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">환승주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">전기차충전</span><span class="p">,</span> <span class="err">#</span><span class="nx">가까운</span><span class="p">,</span> <span class="err">#</span><span class="nx">먼</span>

<span class="o">---</span>
<span class="p">[</span><span class="nx">주차장</span> <span class="nx">정보</span><span class="p">]</span>
<span class="nx">이름</span><span class="p">:</span> <span class="nx">연신내유료주차장</span>
<span class="nx">거리</span><span class="p">:</span> <span class="mf">501.125</span><span class="nx">m</span>
<span class="nx">주소</span><span class="p">:</span> <span class="nx">대한민국</span> <span class="nx">서울특별시</span> <span class="nx">은평구</span> <span class="nx">불광동</span> <span class="mi">81</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="mi">03338</span>
<span class="o">-</span> <span class="p">[</span><span class="dl">"</span><span class="s2">#유료</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">#넓은</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">#지하주차장</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">#서울</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">#은평</span><span class="dl">"</span><span class="p">]</span>

<span class="nx">DEBUG</span><span class="p">:</span> <span class="nx">Model</span> <span class="nx">responded</span> <span class="k">in</span> <span class="mf">8.22</span> <span class="nx">seconds</span> <span class="k">for</span> <span class="nx">prompt</span><span class="p">:</span>
<span class="nx">다음</span> <span class="nx">주차장</span> <span class="nx">정보에서</span> <span class="nx">가장</span> <span class="nx">핵심적인</span> <span class="nx">특징을</span> <span class="nx">나타내는</span> <span class="nx">태그를</span> <span class="mi">5</span><span class="nx">개</span> <span class="nx">이내로</span> <span class="nx">생성해줘</span><span class="p">.</span>
<span class="nx">예시</span> <span class="nx">태그</span><span class="p">:</span> <span class="err">#</span><span class="mi">24</span><span class="nx">시간</span><span class="p">,</span> <span class="err">#</span><span class="nx">공영</span><span class="p">,</span> <span class="err">#</span><span class="nx">무료</span><span class="p">,</span> <span class="err">#</span><span class="nx">넓은</span><span class="p">,</span> <span class="err">#</span><span class="nx">지하주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">야외주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">마트주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">병원주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">쇼핑몰주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">식당주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">공항주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">역주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">환승주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">전기차충전</span><span class="p">,</span> <span class="err">#</span><span class="nx">가까운</span><span class="p">,</span> <span class="err">#</span><span class="nx">먼</span>

<span class="o">---</span>
<span class="p">[</span><span class="nx">주차장</span> <span class="nx">정보</span><span class="p">]</span>
<span class="nx">이름</span><span class="p">:</span> <span class="nx">연광초등학교지하공동주차장</span>
<span class="nx">거리</span><span class="p">:</span> <span class="mf">877.267</span><span class="nx">m</span>
<span class="nx">주소</span><span class="p">:</span> <span class="nx">대한민국</span> <span class="nx">서울특별시</span> <span class="nx">은평구</span> <span class="nx">연서로35길</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">03342</span>
<span class="o">-</span> <span class="p">[</span><span class="dl">"</span><span class="s2">지하주차장</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">학교주차장</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">서울주차장</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">근처주차장</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">공영주차장</span><span class="dl">"</span><span class="p">]</span>

<span class="nx">DEBUG</span><span class="p">:</span> <span class="nx">Model</span> <span class="nx">responded</span> <span class="k">in</span> <span class="mf">7.21</span> <span class="nx">seconds</span> <span class="k">for</span> <span class="nx">prompt</span><span class="p">:</span>
<span class="nx">다음</span> <span class="nx">주차장</span> <span class="nx">정보에서</span> <span class="nx">가장</span> <span class="nx">핵심적인</span> <span class="nx">특징을</span> <span class="nx">나타내는</span> <span class="nx">태그를</span> <span class="mi">5</span><span class="nx">개</span> <span class="nx">이내로</span> <span class="nx">생성해줘</span><span class="p">.</span>
<span class="nx">예시</span> <span class="nx">태그</span><span class="p">:</span> <span class="err">#</span><span class="mi">24</span><span class="nx">시간</span><span class="p">,</span> <span class="err">#</span><span class="nx">공영</span><span class="p">,</span> <span class="err">#</span><span class="nx">무료</span><span class="p">,</span> <span class="err">#</span><span class="nx">넓은</span><span class="p">,</span> <span class="err">#</span><span class="nx">지하주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">야외주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">마트주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">병원주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">쇼핑몰주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">식당주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">공항주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">역주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">환승주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">전기차충전</span><span class="p">,</span> <span class="err">#</span><span class="nx">가까운</span><span class="p">,</span> <span class="err">#</span><span class="nx">먼</span>

<span class="o">---</span>
<span class="p">[</span><span class="nx">주차장</span> <span class="nx">정보</span><span class="p">]</span>
<span class="nx">이름</span><span class="p">:</span> <span class="nx">새장골공영주차장</span>
<span class="nx">거리</span><span class="p">:</span> <span class="mf">883.138</span><span class="nx">m</span>
<span class="nx">주소</span><span class="p">:</span> <span class="nx">대한민국</span> <span class="nx">서울특별시</span> <span class="nx">은평구</span> <span class="nx">불광동</span> <span class="mi">480</span><span class="o">-</span><span class="mi">352</span><span class="p">,</span> <span class="mi">03340</span>
<span class="o">-</span> <span class="p">[</span><span class="dl">"</span><span class="s2">#공영</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">#무료</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">#지하주차장</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">#서울특별시</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">#은평구</span><span class="dl">"</span><span class="p">]</span>

<span class="nx">DEBUG</span><span class="p">:</span> <span class="nx">Model</span> <span class="nx">responded</span> <span class="k">in</span> <span class="mf">7.19</span> <span class="nx">seconds</span> <span class="k">for</span> <span class="nx">prompt</span><span class="p">:</span>
<span class="nx">다음</span> <span class="nx">주차장</span> <span class="nx">정보에서</span> <span class="nx">가장</span> <span class="nx">핵심적인</span> <span class="nx">특징을</span> <span class="nx">나타내는</span> <span class="nx">태그를</span> <span class="mi">5</span><span class="nx">개</span> <span class="nx">이내로</span> <span class="nx">생성해줘</span><span class="p">.</span>
<span class="nx">예시</span> <span class="nx">태그</span><span class="p">:</span> <span class="err">#</span><span class="mi">24</span><span class="nx">시간</span><span class="p">,</span> <span class="err">#</span><span class="nx">공영</span><span class="p">,</span> <span class="err">#</span><span class="nx">무료</span><span class="p">,</span> <span class="err">#</span><span class="nx">넓은</span><span class="p">,</span> <span class="err">#</span><span class="nx">지하주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">야외주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">마트주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">병원주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">쇼핑몰주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">식당주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">공항주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">역주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">환승주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">전기차충전</span><span class="p">,</span> <span class="err">#</span><span class="nx">가까운</span><span class="p">,</span> <span class="err">#</span><span class="nx">먼</span>

<span class="o">---</span>
<span class="p">[</span><span class="nx">주차장</span> <span class="nx">정보</span><span class="p">]</span>
<span class="nx">이름</span><span class="p">:</span> <span class="nx">연신내유료주차장</span>
<span class="nx">거리</span><span class="p">:</span> <span class="mf">501.125</span><span class="nx">m</span>
<span class="nx">주소</span><span class="p">:</span> <span class="nx">대한민국</span> <span class="nx">서울특별시</span> <span class="nx">은평구</span> <span class="nx">불광동</span> <span class="mi">81</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="mi">03338</span>
<span class="o">-</span> <span class="p">[</span><span class="dl">"</span><span class="s2">#유료</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">#공영</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">#넓은</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">#지하주차장</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">#서울특별시</span><span class="dl">"</span><span class="p">]</span>

<span class="nx">DEBUG</span><span class="p">:</span> <span class="nx">Model</span> <span class="nx">responded</span> <span class="k">in</span> <span class="mf">3.75</span> <span class="nx">seconds</span> <span class="k">for</span> <span class="nx">prompt</span><span class="p">:</span>
<span class="nx">다음</span> <span class="nx">주차장</span> <span class="nx">정보에서</span> <span class="nx">가장</span> <span class="nx">핵심적인</span> <span class="nx">특징을</span> <span class="nx">나타내는</span> <span class="nx">태그를</span> <span class="mi">5</span><span class="nx">개</span> <span class="nx">이내로</span> <span class="nx">생성해줘</span><span class="p">.</span>
<span class="nx">예시</span> <span class="nx">태그</span><span class="p">:</span> <span class="err">#</span><span class="mi">24</span><span class="nx">시간</span><span class="p">,</span> <span class="err">#</span><span class="nx">공영</span><span class="p">,</span> <span class="err">#</span><span class="nx">무료</span><span class="p">,</span> <span class="err">#</span><span class="nx">넓은</span><span class="p">,</span> <span class="err">#</span><span class="nx">지하주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">야외주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">마트주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">병원주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">쇼핑몰주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">식당주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">공항주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">역주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">환승주차장</span><span class="p">,</span> <span class="err">#</span><span class="nx">전기차충전</span><span class="p">,</span> <span class="err">#</span><span class="nx">가까운</span><span class="p">,</span> <span class="err">#</span><span class="nx">먼</span>

<span class="o">---</span>
<span class="p">[</span><span class="nx">주차장</span> <span class="nx">정보</span><span class="p">]</span>
<span class="nx">이름</span><span class="p">:</span> <span class="nx">새장골공영주차장</span>
<span class="nx">거리</span><span class="p">:</span> <span class="mf">883.138</span><span class="nx">m</span>
<span class="nx">주소</span><span class="p">:</span> <span class="nx">대한민국</span> <span class="nx">서울특별시</span> <span class="nx">은평구</span> <span class="nx">불광동</span> <span class="mi">480</span><span class="o">-</span><span class="mi">352</span><span class="p">,</span> <span class="mi">03340</span>
<span class="o">-</span> <span class="p">[</span><span class="dl">"</span><span class="s2">#공영</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">#무료</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">#지하주차장</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">#서울특별시</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">#은평구</span><span class="dl">"</span><span class="p">]</span>
</code></pre></div></div>]]></content><author><name>jglee</name></author><category term="ios" /><summary type="html"><![CDATA[온디바이스 AI, 새로운 가능성의 문을 열다: Apple Foundation Models 활용기]]></summary></entry><entry><title type="html">[WWDC25]Swift 성능 최적화: 불필요한 할당 줄이기</title><link href="https://leejigun.github.io/WWDC25Swift-%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94-%EB%B6%88%ED%95%84%EC%9A%94%ED%95%9C-%ED%95%A0%EB%8B%B9-%EC%A4%84%EC%9D%B4%EA%B8%B0" rel="alternate" type="text/html" title="[WWDC25]Swift 성능 최적화: 불필요한 할당 줄이기" /><published>2025-07-21T09:00:00+09:00</published><updated>2025-07-21T09:00:00+09:00</updated><id>https://leejigun.github.io/WWDC25Swift-%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94-%EB%B6%88%ED%95%84%EC%9A%94%ED%95%9C-%ED%95%A0%EB%8B%B9-%EC%A4%84%EC%9D%B4%EA%B8%B0</id><content type="html" xml:base="https://leejigun.github.io/WWDC25Swift-%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94-%EB%B6%88%ED%95%84%EC%9A%94%ED%95%9C-%ED%95%A0%EB%8B%B9-%EC%A4%84%EC%9D%B4%EA%B8%B0"><![CDATA[<ul>
  <li>https://www.youtube.com/watch?v=LzBZjwEY9as&amp;list=TLGGzZB-ElPYOYAyMDA3MjAyNQ</li>
</ul>

<p>이전 편에서 Time Profiler를 통해 불필요한 데이터 복사를 최적화했다. 이번에는 과도한 메모리 할당이라는 또 다른 주요 성능 저하 요인을 해결하여 추가적인 성능 개선을 달성하는 방법을 다룬다.</p>

<h2 id="1-문제-진단-allocations-도구-활용">1. 문제 진단: Allocations 도구 활용</h2>

<p>성능 저하의 주요 원인 중 하나는 빈번하고 불필요한 메모리 할당이다. 특히 <code class="language-plaintext highlighter-rouge">Array</code> 같은 컬렉션 타입의 할당/해제는 비용이 크다. QOI 이미지 파서 앱에서도 이 문제가 확인되었다.</p>

<p>이 문제를 진단하기 위해 <strong>Instruments의 Allocations 도구</strong>를 사용한다. 프로파일링 결과, 한 장의 이미지를 파싱하는 과정에서 <strong>백만 건에 가까운 할당</strong>이 발생했으며, 대부분 “수명이 짧은(short-lived)” 임시 할당으로 나타났다. 이는 명백히 개선이 필요함을 시사한다.</p>

<p><img src="assets/images/ios/2025-07-21-WWDC25Swift-성능-최적화-불필요한-할당-줄이기/image.png" alt="image.png" /></p>

<ul>
  <li>첫째로 이미지 하나를 파싱하는데 메모리 할당이 100만개나 발생할 이유가 없다는 부분에서 의심을 시작한다.</li>
  <li>둘째로 대부분 (91만개)의 할당이 일시적(Transient)  할당이다.</li>
</ul>

<h2 id="2-비효율적인-할당-패턴flatmap체인">2. 비효율적인 할당 패턴: <code class="language-plaintext highlighter-rouge">flatMap</code> 체인</h2>

<p>Allocations 도구의 Call Tree 뷰 분석 결과, <strong><code class="language-plaintext highlighter-rouge">flatMap</code>과 <code class="language-plaintext highlighter-rouge">prefix</code>로 구성된 복잡한 체인</strong>이 문제의 원인으로 지목되었다.</p>

<p><img src="assets/images/ios/2025-07-21-WWDC25Swift-성능-최적화-불필요한-할당-줄이기/image 1.png" alt="image.png" /></p>

<p>특히 <code class="language-plaintext highlighter-rouge">RGBAPixel.data</code> 메서드가 호출될 때마다 3-4개의 요소를 가진 새 배열을 반환하며 할당을 유발하는 것이 확인되었다.</p>

<p>이러한 <code class="language-plaintext highlighter-rouge">flatMap</code> 체인은 코드를 간결하게 만들지만, 내부적으로 여러 단계의 <strong>중간 배열 생성과 병합</strong>을 반복한다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// MARK: - 문제 코드 예시: 비효율적인 할당을 유발하는 flatMap 체인 (영상에서 발췌)</span>

<span class="c1">// QOIParser.swift 파일 내의 parseQOI 함수 일부</span>
<span class="kd">func</span> <span class="nf">parseQOI</span><span class="p">(</span><span class="n">from</span> <span class="nv">input</span><span class="p">:</span> <span class="k">inout</span> <span class="kt">Data</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">QOI</span><span class="p">?</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">let</span> <span class="nv">pixels</span> <span class="o">=</span> <span class="nf">readEncodedPixels</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">input</span><span class="p">)</span>
        <span class="o">.</span><span class="n">flatMap</span> <span class="p">{</span> <span class="nf">decodePixels</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="nv">$0</span><span class="p">)</span> <span class="p">}</span> <span class="c1">// [EncodedPixel] -&gt; [RGBAPixel]</span>
        <span class="o">.</span><span class="nf">prefix</span><span class="p">(</span><span class="n">header</span><span class="o">.</span><span class="n">pixelCount</span><span class="p">)</span>          <span class="c1">// 필요한 픽셀 수만큼 제한</span>
        <span class="o">.</span><span class="n">flatMap</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="nf">data</span><span class="p">(</span><span class="nv">channels</span><span class="p">:</span> <span class="n">header</span><span class="o">.</span><span class="n">channels</span><span class="p">)</span> <span class="p">}</span> <span class="c1">// [RGBAPixel] -&gt; [UInt8] (픽셀 데이터)</span>

    <span class="k">return</span> <span class="kt">QOI</span><span class="p">(</span><span class="nv">header</span><span class="p">:</span> <span class="n">header</span><span class="p">,</span> <span class="nv">data</span><span class="p">:</span> <span class="kt">Data</span><span class="p">(</span><span class="n">pixels</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>위 코드에서 <code class="language-plaintext highlighter-rouge">readEncodedPixels</code>는 인코딩된 픽셀 데이터를 파싱하고, <code class="language-plaintext highlighter-rouge">.flatMap { decodePixels(from: $0) }</code>는 각 인코딩된 픽셀을 RGBA 픽셀 배열로 디코딩합니다.</li>
  <li>이 과정에서 각 픽셀마다 <strong>작은 배열들이 생성</strong>되고, 첫 번째 <code class="language-plaintext highlighter-rouge">flatMap</code>은 이 작은 배열들을 하나의 <strong>더 큰 배열로 병합</strong>합니다.</li>
  <li>이후 <code class="language-plaintext highlighter-rouge">.flatMap { $0.data(channels: header.channels) }</code>는 각 <code class="language-plaintext highlighter-rouge">RGBAPixel</code>을 3-4 바이트의 <strong>또 다른 작은 배열로 변환</strong>하고, 이 배열들이 다시 최종적으로 <strong>가장 큰 새 배열로 평탄화</strong>됩니다.</li>
</ul>

<p>이러한 과정은 코드를 간결하게 보이지만, 내부적으로는 수많은 임시 배열을 생성하고 소멸시키며 과도한 메모리 할당/해제 비용을 발생시킨다.</p>

<hr />

<h2 id="3-해결책-최종-데이터-크기-사전-계산-및-직접-작성">3. 해결책: 최종 데이터 크기 사전 계산 및 직접 작성</h2>

<p>앞서 아래와 같은 분석을 했다.</p>

<ul>
  <li>Instruments의 Allocations 도구로 약 <strong>백만 건에 가까운 임시 할당</strong>을 확인</li>
  <li>특히 <code class="language-plaintext highlighter-rouge">RGBAPixel.data</code> 메서드가 호출될 때마다 작은 배열을 생성하고 반환</li>
  <li>이는 주로 <code class="language-plaintext highlighter-rouge">flatMap</code>과 <code class="language-plaintext highlighter-rouge">prefix</code> 체인에서 작은 배열들을 반복적으로 생성하고 병합하는 비효율적인 패턴</li>
</ul>

<p>비효율적인 중간 할당을 제거하기 위해, 최종 데이터 크기를 미리 계산하고 미리 할당된 공간에 데이터를 직접 작성하는 방식으로 접근한다.</p>

<ol>
  <li><strong>최종 크기 사전 계산</strong>: 결과 데이터의 총 크기(<code class="language-plaintext highlighter-rouge">totalBytes</code>)를 미리 계산한다.
    <ol>
      <li><code class="language-plaintext highlighter-rouge">header.pixelCount</code>와 <code class="language-plaintext highlighter-rouge">header.channels</code>를 사용</li>
    </ol>
  </li>
  <li><strong>메모리 한 번에 할당</strong>: 계산된 <code class="language-plaintext highlighter-rouge">totalBytes</code> 만큼의 <code class="language-plaintext highlighter-rouge">Data</code> 인스턴스를 단 한번만 할당한다.</li>
  <li><strong>데이터 직접 작성</strong>: <code class="language-plaintext highlighter-rouge">offset</code> 변수를 사용하여 기록 위치를 추적하며, 각 픽셀을 디코딩하여 미리 할당된 공간에 직접 데이터를 쓴다.</li>
</ol>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">QOIParser</span> <span class="p">{</span>
  
  <span class="kd">func</span> <span class="nf">parseQOI</span><span class="p">(</span><span class="n">from</span> <span class="nv">input</span><span class="p">:</span> <span class="k">inout</span> <span class="kt">Data</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">QOI</span><span class="p">?</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">var</span> <span class="nv">offset</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="c1">// 'offset'이 'totalBytes'에 도달할 때까지 픽셀 데이터를 계속 파싱하고 작성합니다.</span>
    <span class="k">while</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="n">totalBytes</span> <span class="p">{</span>
      <span class="c1">// 다음 인코딩된 픽셀을 파싱합니다. 파싱에 실패하면 반복을 중단합니다.</span>
      <span class="k">guard</span> <span class="k">let</span> <span class="nv">nextPixel</span> <span class="o">=</span> <span class="nf">parsePixel</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">input</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span> <span class="k">break</span> <span class="p">}</span>
      
      <span class="c1">// 파싱된 픽셀의 유형에 따라 처리합니다.</span>
      <span class="k">switch</span> <span class="n">nextPixel</span> <span class="p">{</span>
      <span class="c1">// 런(Run) 타입 픽셀: 이전 픽셀을 'count'만큼 반복하여 출력합니다.</span>
      <span class="k">case</span> <span class="o">.</span><span class="nf">run</span><span class="p">(</span><span class="k">let</span> <span class="nv">count</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">count</span> <span class="p">{</span>
          <span class="c1">// 'state.previousPixel'의 데이터를 미리 할당된 'pixelData'에</span>
          <span class="c1">// 'offset' 위치부터 직접 작성합니다. 이 과정에서 임시 배열 생성 없이 바로 메모리에 씁니다.</span>
          <span class="n">state</span><span class="o">.</span><span class="n">previousPixel</span>
            <span class="o">.</span><span class="nf">write</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">pixelData</span><span class="p">,</span> <span class="nv">at</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span> <span class="nv">channels</span><span class="p">:</span> <span class="n">header</span><span class="o">.</span><span class="n">channels</span><span class="p">)</span>
        <span class="p">}</span>
      <span class="c1">// 그 외 다른 타입의 픽셀: 단일 픽셀을 디코딩하여 출력합니다.</span>
      <span class="k">default</span><span class="p">:</span>
        <span class="c1">// 디코딩된 단일 픽셀 데이터를 미리 할당된 'pixelData'에</span>
        <span class="c1">// 'offset' 위치부터 직접 작성합니다.</span>
        <span class="nf">decodeSinglePixel</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="n">nextPixel</span><span class="p">)</span>
          <span class="o">.</span><span class="nf">write</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">pixelData</span><span class="p">,</span> <span class="nv">at</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span> <span class="nv">channels</span><span class="p">:</span> <span class="n">header</span><span class="o">.</span><span class="n">channels</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="c1">// 파싱이 완료된 헤더와 최종 픽셀 데이터(pixelData)를 사용하여 QOI 객체를 반환합니다.</span>
    <span class="c1">// 이 최종 'Data' 인스턴스만이 결과 이미지를 저장하기 위한 유일한 할당입니다.</span>
    <span class="k">return</span> <span class="kt">QOI</span><span class="p">(</span><span class="nv">header</span><span class="p">:</span> <span class="n">header</span><span class="p">,</span> <span class="nv">data</span><span class="p">:</span> <span class="n">pixelData</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<h2 id="4-성능-개선-결과">4. 성능 개선 결과</h2>

<p>수정된 코드를 다시 프로파일링하면 <strong>할당 수가 현저히 줄어든 것</strong>을 즉시 확인할 수 있다. <code class="language-plaintext highlighter-rouge">QOI.init</code>과 관련된 호출 필터링 시, 파서 코드가 단 몇 개의 할당만 수행하며 총 2MB 미만의 메모리를 사용함을 볼 수 있다. 결과 이미지를 저장하는 <code class="language-plaintext highlighter-rouge">Data</code> 인스턴스 외에는 거의 할당이 발생하지 않는다.</p>

<p><img src="assets/images/ios/2025-07-21-WWDC25Swift-성능-최적화-불필요한-할당-줄이기/image 2.png" alt="image.png" /></p>

<ul>
  <li>최적화 전의 스크린샷을 보면 약 68MB의 메모리를 사용했었다.</li>
</ul>

<p>벤치마크 결과, 불필요한 할당 제거는 <strong>실행 시간을 절반 이상 단축시키는 놀라운 결과</strong>를 가져왔다.</p>

<p><img src="assets/images/ios/2025-07-21-WWDC25Swift-성능-최적화-불필요한-할당-줄이기/image 3.png" alt="image.png" /></p>

<ul>
  <li>앞서 포스트(Copying fix)랑 이번 포스트(Allocations fix)로 메모리뿐만 아니라 속도도 상당히 개선되었다.</li>
</ul>

<hr />

<h2 id="결론-및-다음-편-예고">결론 및 다음 편 예고</h2>

<p>본 편에서는 Instruments의 Allocations 도구를 활용하여 <code class="language-plaintext highlighter-rouge">flatMap</code> 체인에서 발생하는 과도한 메모리 할당 패턴을 식별하고, 최종 데이터 크기를 사전 계산하여 한 번에 메모리를 할당한 후 데이터를 직접 작성하는 방식으로 최적화했다. 이를 통해 실행 시간을 절반 이상 단축시키는 중요한 성능 개선을 달성했다.</p>

<p>다음 편에서는 Swift 런타임 독점성 검사(<code class="language-plaintext highlighter-rouge">_sanityCheckExclusiveAccess</code> 제거)와 <code class="language-plaintext highlighter-rouge">InlineArray</code>를 통한 고급 메모리 최적화 기법을 탐구할 예정이다.</p>]]></content><author><name>jglee</name></author><category term="ios" /><summary type="html"><![CDATA[https://www.youtube.com/watch?v=LzBZjwEY9as&amp;list=TLGGzZB-ElPYOYAyMDA3MjAyNQ]]></summary></entry><entry><title type="html">[WWDC25] Swift 성능 최적화의 시작-1) Instruments로 코드 병목 찾기</title><link href="https://leejigun.github.io/WWDC25-Swift-%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94%EC%9D%98-%EC%8B%9C%EC%9E%91-1-Instruments%EB%A1%9C-%EC%BD%94%EB%93%9C-%EB%B3%91%EB%AA%A9-%EC%B0%BE%EA%B8%B0" rel="alternate" type="text/html" title="[WWDC25] Swift 성능 최적화의 시작-1) Instruments로 코드 병목 찾기" /><published>2025-07-20T09:00:00+09:00</published><updated>2025-07-20T09:00:00+09:00</updated><id>https://leejigun.github.io/WWDC25-Swift-%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94%EC%9D%98-%EC%8B%9C%EC%9E%91-1-Instruments%EB%A1%9C-%EC%BD%94%EB%93%9C-%EB%B3%91%EB%AA%A9-%EC%B0%BE%EA%B8%B0</id><content type="html" xml:base="https://leejigun.github.io/WWDC25-Swift-%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94%EC%9D%98-%EC%8B%9C%EC%9E%91-1-Instruments%EB%A1%9C-%EC%BD%94%EB%93%9C-%EB%B3%91%EB%AA%A9-%EC%B0%BE%EA%B8%B0"><![CDATA[<ul>
  <li><a href="https://www.youtube.com/watch?v=LzBZjwEY9as&amp;list=TLGGzZB-ElPYOYAyMDA3MjAyNQ">https://www.youtube.com/watch?v=LzBZjwEY9as&amp;list=TLGGzZB-ElPYOYAyMDA3MjAyNQ</a></li>
  <li>https://github.com/apple/swift-binary-parsing</li>
</ul>

<p>iOS 애플리케이션의 성능은 사용자 경험에 직접적인 영향을 미치며, 특히 이미지 처리와 같은 데이터 집약적인 작업에서는 최적화가 필수적이다. 본 블로그 시리즈의 첫 번째 편에서는 Apple의 강력한 성능 분석 도구인 <strong>Instruments</strong>를 활용하여 Swift 코드의 초기 병목 현상을 식별하고 성능 개선을 달성하는 과정을 상세히 다룬다.</p>

<h2 id="1-문제-제기-느린-이미지-로딩과-사용자-경험-저하">1. 문제 제기: 느린 이미지 로딩과 사용자 경험 저하</h2>

<p>WWDC영상에서 새롭게 개발한 QOI 이미지 파서 앱에서 작은 아이콘 파일은 즉시 로드되지만, 고해상도 이미지와 같은 큰 파일은 로딩에 수 초가 소요되는 문제가 발생했다. 이러한 속도 저하는 종종 알고리즘 또는 데이터 구조의 비효율적인 사용을 시사한다.</p>

<p>이 문제를 진단하고 해결하기 위해 <strong>Instruments</strong>를 활용하여 코드의 병목 현상을 분석한다.</p>

<h2 id="2-instruments-성능-분석의-시작점">2. Instruments: 성능 분석의 시작점</h2>

<p>Instruments는 Xcode에 통합된 Apple의 프로파일링 도구이다. 이 도구는 애플리케이션이 시간을 어디에 소비하는지, 메모리를 어떻게 할당하는지 등을 시각적으로 파악할 수 있도록 지원한다.</p>

<h3 id="a-테스트-프로파일링-설정">A. 테스트 프로파일링 설정</h3>

<p>성능 분석의 효율성을 위해 앱 전체를 프로파일링하는 대신, 분석 대상 코드에 대한 <strong>테스트(Test)</strong>를 생성하여 해당 부분만 프로파일링하는 것이 권장된다.</p>

<ol>
  <li>Xcode에서 성능을 분석하고자 하는 <strong>특정 코드에 대한 테스트를 생성</strong>한다.</li>
  <li>
    <p>테스트 실행 버튼을 보조 클릭(우클릭)하여 ‘<strong>Profile Test</strong>’ 옵션을 선택한다.</p>

    <p><img src="assets/images/ios/2025-07-20-WWDC25-Swift-성능-최적화의-시작-1-Instruments로-코드-병목-찾기/image.png" alt="image.png" /></p>
  </li>
  <li>Instruments가 실행되면, ‘<strong>Blank</strong>’ 템플릿을 선택한다.</li>
  <li>좌측 상단의 ‘+’ 버튼을 클릭하여 두 가지 핵심 Instrument를 추가한다:
    <ul>
      <li><strong>Time Profiler</strong>: 애플리케이션이 시간을 어디에 소비하는지 파악하는 데 유용하다.</li>
      <li><strong>Allocations</strong>: 메모리 할당 패턴을 이해하는 데 도움을 준다.</li>
    </ul>
  </li>
</ol>

<p><img src="assets/images/ios/2025-07-20-WWDC25-Swift-성능-최적화의-시작-1-Instruments로-코드-병목-찾기/image%201.png" alt="image.png" /></p>

<h2 id="3-time-profiler로-코드-병목-찾기platform_memmove의-진실">3. Time Profiler로 코드 병목 찾기: <code class="language-plaintext highlighter-rouge">platform_memmove</code>의 진실</h2>

<p>Instruments에서 녹화(Record) 버튼을 눌러 테스트를 실행한다. 결과 창에서 다양한 정보가 표시되는데, 이 중 <strong>Time Profiler</strong> 결과에 집중하여 분석을 시작한다.</p>

<h3 id="a-call-tree-분석">A. Call Tree 분석</h3>

<ul>
  <li>하단 디테일 뷰에서 ‘<strong>Call Tree</strong>’ 버튼을 클릭한 후, ‘<strong>Invert Call Tree</strong>‘를 선택한다. 이 설정은 CPU 사용량이 가장 빈번하게 캡처된 호출을 상단에 표시하여 병목을 신속하게 식별할 수 있도록 한다.</li>
</ul>

<h3 id="b-불꽃-그래프flame-graph-시각화">B. 불꽃 그래프(Flame Graph) 시각화</h3>

<ul>
  <li>디테일 뷰 상단의 버튼을 클릭하여 결과를 <strong>불꽃 그래프(Flame Graph)</strong>로 시각화한다.</li>
</ul>

<p><img src="assets/images/ios/2025-07-20-WWDC25-Swift-성능-최적화의-시작-1-Instruments로-코드-병목-찾기/image%202.png" alt="image.png" /></p>

<ul>
  <li>그래프에서 <strong>“platform_memmove”</strong>라는 거대한 막대가 프로세스를 지배하고 있는 것을 확인할 수 있다. <code class="language-plaintext highlighter-rouge">platform_memmove</code>는 데이터를 복사하는 저수준 시스템 호출이며, 이 거대한 막대는 파서가 데이터를 읽는 대신 대부분의 시간을 데이터 복사에 소비하고 있음을 나타낸다.</li>
</ul>

<h3 id="c-문제의-코드-발견readbyte메서드">C. 문제의 코드 발견: <code class="language-plaintext highlighter-rouge">readByte</code> 메서드</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">platform_memmove</code> 스택 트레이스를 ‘show all frames’로 확장하여 보면, 시스템 호출 아래에 Foundation <strong><code class="language-plaintext highlighter-rouge">Data</code></strong> 타입의 특수화된 메서드들이 확인된다. 그 아래에 개발자가 정의한 메서드인 <code class="language-plaintext highlighter-rouge">readByte</code>가 나타난다.</li>
  <li>Instruments는 <strong><code class="language-plaintext highlighter-rouge">readByte</code></strong> 메서드의 특정 라인(Data 초기화)이 모든 데이터 복사를 유발하고 있음을 지목한다.</li>
</ul>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// MARK: - 문제의 코드 발견: readByte 메서드</span>

<span class="kd">extension</span> <span class="kt">Data</span>

	<span class="c1">// 초기 문제 발생 코드 (수정 전)</span>
	<span class="c1">// 이 메서드는 매번 데이터를 복사하여 비효율적인 성능을 초래한다.</span>
	<span class="k">mutating</span> <span class="kd">func</span> <span class="nf">readByte</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">UInt8</span><span class="p">?</span> <span class="p">{</span>
		<span class="k">guard</span> <span class="o">!</span><span class="n">isEmpty</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>
		<span class="k">let</span> <span class="nv">value</span> <span class="o">=</span> <span class="k">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="c1">// 문제 발생 지점:</span>
		<span class="c1">// 'Data(data.dropFirst())'를 통해 기존 데이터의 나머지 부분을</span>
		<span class="c1">// '새로운 Data 인스턴스'로 통째로 복사한다.</span>
		<span class="c1">// 이 과정이 데이터 크기에 비례하여 기하급수적으로 시간을 소비한다.</span>
		<span class="k">self</span> <span class="o">=</span> <span class="kt">Data</span><span class="p">(</span><span class="k">self</span><span class="o">.</span><span class="nf">dropFirst</span><span class="p">())</span> <span class="c1">// &lt;-- Instruments가 지목한 바로 그 라인</span>
		<span class="k">return</span> <span class="n">value</span>
	<span class="p">}</span>
    <span class="c1">// ... (다른 파싱 메서드들)</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">readByte</code>의 본래 의도는 단순히 데이터의 첫 바이트를 반환하고 데이터의 시작점을 앞으로 이동시키는 것이었다. 그러나 실제로는 매번 바이트를 읽을 때마다 데이터의 전체 내용을 새로운 할당으로 복사하고 있었다.</li>
</ul>

<h2 id="4-해결책popfirst를-활용한-선형-시간-복잡도-달성">4. 해결책: <code class="language-plaintext highlighter-rouge">popFirst()</code>를 활용한 선형 시간 복잡도 달성</h2>

<p><strong><code class="language-plaintext highlighter-rouge">Data</code></strong> 타입은 양쪽 끝에서 효율적으로 축소되도록 설계되었으며, 이를 위한 컬렉션 메서드인 <strong><code class="language-plaintext highlighter-rouge">popFirst()</code></strong>를 제공한다. <strong><code class="language-plaintext highlighter-rouge">popFirst()</code></strong>는 데이터의 첫 바이트를 반환한 다음, 컬렉션의 앞부분을 한 바이트씩 이동시켜 데이터를 효율적으로 축소한다.</p>

<h3 id="a-코드-수정">A. 코드 수정</h3>

<p>문제의 <code class="language-plaintext highlighter-rouge">readByte</code> 메서드를 <code class="language-plaintext highlighter-rouge">popFirst()</code>를 사용하도록 수정한다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// MARK: - 4. 해결책: popFirst()를 활용한 선형 시간 복잡도 달성</span>

<span class="c1">// QOIParser 클래스 내의 readByte 메서드 수정 후 코드</span>
<span class="c1">// Data 타입의 popFirst() 메서드를 사용하여 효율적인 데이터 처리를 구현한다.</span>
<span class="c1">// 이 메서드는 내부적으로 데이터를 복사하지 않고, 컬렉션의 시작점만 이동시켜</span>
<span class="c1">// 상수 시간에 가까운 성능을 제공한다.</span>
<span class="k">mutating</span> <span class="kd">func</span> <span class="nf">readByte</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">UInt8</span><span class="p">?</span> <span class="p">{</span>
		<span class="k">guard</span> <span class="o">!</span><span class="n">isEmpty</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>
		<span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="nf">popFirst</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="b-성능-개선-결과">B. 성능 개선 결과</h3>

<p>코드를 수정한 후, 다시 프로파일링을 실행하면 개선된 결과를 확인할 수 있다.</p>

<p><img src="assets/images/ios/2025-07-20-WWDC25-Swift-성능-최적화의-시작-1-Instruments로-코드-병목-찾기/image%203.png" alt="image.png" /></p>

<p>불꽃 그래프에서 거대한 <code class="language-plaintext highlighter-rouge">platform_memmove</code> 막대가 사라진 것을 확인할 수 있다. 벤치마크 결과, 이 작은 변경 하나로 인해 파싱 성능이 비약적으로 향상되었다.</p>

<p>가장 중요한 점은, 원래 버전에서는 이미지 크기와 파싱 시간의 관계가 <strong>2차(quadratic)</strong>였지만, <code class="language-plaintext highlighter-rouge">popFirst()</code>로 수정한 후에는 이 관계가 <strong>선형(linear)</strong>으로 개선되었다는 점이다. 이는 이미지 크기가 커질수록 파싱 시간이 기하급수적으로 길어지던 문제가 해결되었음을 의미한다.</p>

<p><img src="assets/images/ios/2025-07-20-WWDC25-Swift-성능-최적화의-시작-1-Instruments로-코드-병목-찾기/image%204.png" alt="image.png" /></p>

<hr />

<h2 id="결론">결론</h2>

<p>본 편에서는 Instruments의 <strong>Time Profiler</strong>를 사용하여 코드의 숨겨진 병목 현상, 특히 불필요한 데이터 복사 문제를 식별하고, <strong><code class="language-plaintext highlighter-rouge">Data</code></strong> 타입의 <strong><code class="language-plaintext highlighter-rouge">popFirst()</code></strong> 메서드를 활용하여 알고리즘적 문제를 해결하는 방법을 살펴보았다. 이로써 파싱 성능을 2차 시간 복잡도에서 선형 시간 복잡도로 개선하는 극적인 결과를 얻었다.</p>

<p>다음 편에서는 “불필요한 메모리 할당 줄이기”에 초점을 맞춰, Instruments의 <strong>Allocations</strong> 도구를 사용하여 발생하는 과도한 할당을 진단하고 제거하여 추가적인 성능 개선을 이루는 방법을 탐구할 예정이다.</p>]]></content><author><name>jglee</name></author><category term="ios" /><summary type="html"><![CDATA[https://www.youtube.com/watch?v=LzBZjwEY9as&amp;list=TLGGzZB-ElPYOYAyMDA3MjAyNQ https://github.com/apple/swift-binary-parsing]]></summary></entry><entry><title type="html">[WWDC25] Swift 6.2 InlineArray: iOS 앱 성능 및 메모리 최적화</title><link href="https://leejigun.github.io/WWDC25-Swift-62-InlineArray-iOS-%EC%95%B1-%EC%84%B1%EB%8A%A5-%EB%B0%8F-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%B5%9C%EC%A0%81%ED%99%94" rel="alternate" type="text/html" title="[WWDC25] Swift 6.2 InlineArray: iOS 앱 성능 및 메모리 최적화" /><published>2025-06-15T09:00:00+09:00</published><updated>2025-06-15T09:00:00+09:00</updated><id>https://leejigun.github.io/WWDC25-Swift-62-InlineArray-iOS-%EC%95%B1-%EC%84%B1%EB%8A%A5-%EB%B0%8F-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%B5%9C%EC%A0%81%ED%99%94</id><content type="html" xml:base="https://leejigun.github.io/WWDC25-Swift-62-InlineArray-iOS-%EC%95%B1-%EC%84%B1%EB%8A%A5-%EB%B0%8F-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%B5%9C%EC%A0%81%ED%99%94"><![CDATA[<ul>
  <li><a href="https://developer.apple.com/kr/videos/play/wwdc2025/245">https://developer.apple.com/kr/videos/play/wwdc2025/245</a></li>
</ul>

<h3 id="swift-앱의-성능-최적화와-inlinearray의-등장">Swift 앱의 성능 최적화와 InlineArray의 등장</h3>

<p>Swift 애플리케이션 개발에서 성능 최적화, 특히 메모리 효율성은 중요한 과제입니다. 이번 WWDC25에서 Swift 6.2와 함께 소개된 <strong>InlineArray</strong>는 이러한 메모리 사용량 및 성능 개선을 위한 핵심 도구로 제시되었습니다. 이 글은 InlineArray의 특징과 기존 <code class="language-plaintext highlighter-rouge">Array</code>와의 차이점, 그리고 실제 iOS 앱 개발에서의 활용 방안을 분석합니다.</p>

<blockquote>
  <p>Swift 6.2의 InlineArray는 iOS 앱의 메모리 및 성능 최적화를 위한 새로운 핵심 도구입니다.</p>

</blockquote>

<h3 id="inlinearray의-구조적-차별점">InlineArray의 구조적 차별점</h3>

<p>기존 <code class="language-plaintext highlighter-rouge">Array</code>는 동적 크기 조절과 값 타입 특성 유지를 위해 힙 할당 버퍼 및 Copy-on-Write 최적화를 사용합니다. 반면 <strong>InlineArray</strong>는 컴파일 시점에 크기가 결정되는 고정 크기 배열이며, 요소를 힙 할당 없이 직접 인라인으로 저장합니다. 이는 참조 계산, 고유성/독점성 검사, 그리고 Copy-on-Write 과정에서 발생하는 런타임 오버헤드를 제거하여 성능을 향상시킵니다. 또한, 컴파일 시점에 크기를 알 수 있어 경계 검사 생략 등 추가적인 최적화 가능성을 제공합니다.</p>

<blockquote>
  <p>InlineArray는 고정 크기 인라인 스토리지를 통해 힙 할당 및 런타임 오버헤드를 줄여 성능을 개선합니다.</p>

</blockquote>

<p><img src="assets/images/ios/2025-06-15-WWDC25-Swift-62-InlineArray-iOS-앱-성능-및-메모리-최적화/image.png" alt="image.png" /></p>

<h3 id="inlinearray-사용의-전략적-고려사항">InlineArray 사용의 전략적 고려사항</h3>

<p>InlineArray는 크기가 고정되어 있고, 빈번한 접근이 필요하며, 복사 및 참조 공유가 불필요한 데이터 구조에 적합합니다. WWDC25 세션에서는 이미지 파서의 픽셀 캐시와 같은 예시를 통해 그 효율성을 강조했습니다. 구체적인 활용 사례로는 <strong>SwiftUI View 내부의 고정된 상태 관리</strong>, <strong>데이터 파싱 시의 임시 고정 버퍼</strong>, 그리고 <strong>유틸리티 함수 내부의 고정 크기 계산용 배열</strong> 등이 있습니다. 이러한 시나리오에서 InlineArray는 불필요한 힙 할당 및 해제 비용을 절감하여 앱의 성능을 개선할 수 있습니다.</p>

<blockquote>
  <p>InlineArray는 고정 크기 데이터, 성능에 민감한 코드 경로, 임베디드 시스템 등 특정 시나리오에서 효율적입니다.</p>

</blockquote>

<h3 id="inlinearray-샘플-코드-분석">InlineArray 샘플 코드 분석</h3>

<p>InlineArray의 사용법은 일반 <code class="language-plaintext highlighter-rouge">Array</code>와 유사하나, 타입 선언 시 크기를 명시해야 합니다. 다음 코드는 3개의 <code class="language-plaintext highlighter-rouge">Int</code> 요소를 가지는 <code class="language-plaintext highlighter-rouge">InlineArray</code>의 선언, 초기화 및 요소 변경을 보여줍니다. <code class="language-plaintext highlighter-rouge">append</code>나 <code class="language-plaintext highlighter-rouge">removeFirst</code>와 같은 동적 크기 조절 메서드는 사용할 수 없으며, 할당 시 Copy-on-Write 없이 즉시 요소들을 복사합니다. 또한, 다른 크기의 InlineArray 타입 간에는 직접 할당이 불가능합니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// InlineArray 선언 및 초기화</span>
<span class="c1">// 3개의 Int 요소를 가지는 InlineArray를 선언하고 초기화합니다.</span>
<span class="k">var</span> <span class="nv">array</span><span class="p">:</span> <span class="kt">InlineArray</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span> <span class="kt">Int</span><span class="o">&gt;</span> <span class="o">=</span> <span class="kt">InlineArray</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"초기 InlineArray: </span><span class="se">\(</span><span class="n">array</span><span class="se">)</span><span class="s">"</span><span class="p">)</span> <span class="c1">// 출력 예시: 초기 InlineArray: [1, 2, 3]</span>

<span class="c1">// 요소 변경 (인덱스를 통한 접근)</span>
<span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"요소 변경 후: </span><span class="se">\(</span><span class="n">array</span><span class="se">)</span><span class="s">"</span><span class="p">)</span> <span class="c1">// 출력 예시: 요소 변경 후: [4, 2, 3]</span>

<span class="c1">// InlineArray는 복사 시 즉시 요소들을 복사합니다 (Copy-on-Write가 아님).</span>
<span class="k">var</span> <span class="nv">copy</span> <span class="o">=</span> <span class="n">array</span>
<span class="n">copy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span> <span class="c1">// copy는 변경되지만, 원본 array는 변경되지 않습니다.</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"원본 array: </span><span class="se">\(</span><span class="n">array</span><span class="se">)</span><span class="s">"</span><span class="p">)</span> <span class="c1">// 출력 예시: 원본 array: [4, 2, 3]</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"복사된 copy: </span><span class="se">\(</span><span class="n">copy</span><span class="se">)</span><span class="s">"</span><span class="p">)</span> <span class="c1">// 출력 예시: 복사된 copy: [10, 2, 3]</span>
</code></pre></div></div>

<ul>
  <li>크기가 고정되어 있어 append 또는 removeFirst와 같은 메서드는 사용할 수 없습니다.</li>
  <li>다른 크기의 InlineArray로는 할당할 수 없습니다.</li>
</ul>

<blockquote>
  <p>InlineArray는 고정 크기를 명시하며, 동적 배열 메서드를 지원하지 않고 복사 시 즉시 전체 요소를 복사합니다.</p>

</blockquote>

<h3 id="swift-앱-최적화의-새로운-지평">Swift 앱 최적화의 새로운 지평</h3>

<p><strong>InlineArray</strong>는 Swift 6.2의 주요 성능 개선 사항 중 하나로, 고정 크기 데이터 처리 시 메모리 사용량과 실행 속도를 개선하는 데 기여합니다. 불필요한 힙 할당과 런타임 메모리 관리 오버헤드를 제거함으로써 iOS 앱의 효율성을 증대시킬 수 있습니다. 개발자들은 최신 Xcode를 통해 InlineArray 및 관련 <strong>Span</strong> 타입에 대해 추가 학습하고 실제 프로젝트에 적용하여 앱의 성능을 향상시킬 수 있을 것입니다.</p>

<blockquote>
  <p>InlineArray는 Swift 앱의 메모리 효율성과 실행 속도를 높여 성능 최적화에 기여하는 중요한 도구입니다.</p>

</blockquote>

<p>일반적인 Array</p>

<p><img src="assets/images/ios/2025-06-15-WWDC25-Swift-62-InlineArray-iOS-앱-성능-및-메모리-최적화/image 1.png" alt="image.png" /></p>

<ul>
  <li>Stack에는 해당 변수의 메모리 좌표값만 자지고 Heap 메모리에 실제 저장</li>
</ul>

<p>InlineArray</p>

<p><img src="assets/images/ios/2025-06-15-WWDC25-Swift-62-InlineArray-iOS-앱-성능-및-메모리-최적화/image 2.png" alt="image.png" /></p>

<ul>
  <li>Stack 메모리에 직접 저장</li>
</ul>]]></content><author><name>jglee</name></author><category term="ios" /><summary type="html"><![CDATA[https://developer.apple.com/kr/videos/play/wwdc2025/245]]></summary></entry><entry><title type="html">[WWDC25] Swift 6.2 동시성 개선</title><link href="https://leejigun.github.io/WWDC25-Swift-62-%EB%8F%99%EC%8B%9C%EC%84%B1-%EA%B0%9C%EC%84%A0" rel="alternate" type="text/html" title="[WWDC25] Swift 6.2 동시성 개선" /><published>2025-06-14T09:00:00+09:00</published><updated>2025-06-14T09:00:00+09:00</updated><id>https://leejigun.github.io/WWDC25-Swift-62-%EB%8F%99%EC%8B%9C%EC%84%B1-%EA%B0%9C%EC%84%A0</id><content type="html" xml:base="https://leejigun.github.io/WWDC25-Swift-62-%EB%8F%99%EC%8B%9C%EC%84%B1-%EA%B0%9C%EC%84%A0"><![CDATA[<h3 id="왜-동시성이-어려웠을까요">왜 동시성이 어려웠을까요?</h3>

<p>이전 Swift 6에서는 언어가 특정 작업을 개발자의 명시적 지시 없이 <strong>백그라운드 스레드나 다른 액터로 암시적으로 전환(오프로드)</strong>하는 경향이 있었습니다. 이 때문에 개발자가 의도하지 않더라도 <strong>데이터 경쟁(data race)</strong>에 취약한 코드가 컴파일러 오류를 유발할 수 있었죠. 동시성 프로그래밍은 여러 작업이 메모리를 공유하기 때문에 실수에 취약하며, 예상치 못한 결과로 이어질 수 있어 본질적으로 어렵습니다.
<em>**</em></p>

<blockquote>
  <p><strong>이전 Swift 6은 암시적인 백그라운드 오프로드로 인해 의도치 않은 데이터 경쟁이 발생하기 쉬워 동시성 코딩이 복잡했습니다.</strong></p>

</blockquote>

<hr />

<h3 id="swift-62의-새로운-동시성-접근-방식">Swift 6.2의 새로운 동시성 접근 방식</h3>

<p>Swift 6.2는 이러한 문제를 해결하기 위해 동시성에 대한 근본적인 접근 방식을 변경했습니다. 이제 개발자가 명시적으로 동시성을 도입하기로 결정할 때까지 코드가 기본적으로 <strong>단일 스레드 상태</strong>를 유지합니다. 이는 개발자가 가장 자연스럽게 작성하는 코드가 기본적으로 데이터 경쟁으로부터 자유롭도록 하여, 프로젝트에 동시성을 도입하는 더 쉬운 경로를 제공합니다. 즉, 코드를 병렬로 실행하고자 <strong>동시성을 선택적으로 도입</strong>할 경우에만 데이터 경쟁 안전이 보호됩니다.</p>

<blockquote>
  <p><strong>Swift 6.2는 명시적인 동시성 도입 전까지 코드를 기본적으로 단일 스레드 상태로 유지하여 데이터 경쟁을 사전에 방지합니다.</strong></p>

</blockquote>

<p><img src="/assets/images/ios/2025-06-14-WWDC25-Swift-62-동시성-개선/image.png" alt="image.png" /></p>

<hr />

<h3 id="핵심-동시성-개선-사항">핵심 동시성 개선 사항</h3>

<p><img src="/assets/images/ios/2025-06-14-WWDC25-Swift-62-동시성-개선/image 1.png" alt="image.png" /></p>

<h3 id="1-호출자의-액터에서-비동기-함수-실행-async-functions-run-on-the-callers-actor">1. 호출자의 액터에서 비동기 함수 실행 (Async Functions Run on the Caller’s Actor)</h3>

<p>이전 Swift 6에서는 특정 비동기 함수가 언어에 의해 암시적으로 백그라운드로 오프로드되는 경우가 많았습니다. 이로 인해 개발자가 의도하지 않았음에도 데이터 경쟁에 취약한 코드가 컴파일러 오류를 유발할 수 있었습니다.</p>

<blockquote>
  <p><strong>이전 Swift 6에서는 비동기 함수가 암시적으로 백그라운드에서 실행되어 데이터 경쟁을 유발할 수 있었습니다.</strong></p>

</blockquote>

<p>문제 상황 (Swift 6 이전):</p>

<p>예를 들어, PhotoProcessor 클래스에 extractSticker라는 비동기 메서드가 있고, 이 메서드가 MainActor에 격리된 StickerModel 클래스 내에서 호출될 때 문제가 발생할 수 있었습니다. extractSticker가 내부적으로 MainActor가 아닌 다른 스레드에서 실행되도록 암시적으로 오프로드될 경우, MainActor의 UI 코드와 공유 상태에 접근하려 할 때 데이터 경쟁 위험이 발생하여 컴파일러 오류가 발생할 수 있었습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Swift 6 (이전)</span>
<span class="c1">// 비동기 함수 호출 시 암시적 오프로드로 인한 잠재적 데이터 경쟁 오류</span>
<span class="kd">class</span> <span class="kt">PhotoProcessor</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">extractSticker</span><span class="p">(</span><span class="nv">data</span><span class="p">:</span> <span class="kt">Data</span><span class="p">,</span> <span class="n">with</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">String</span><span class="p">?)</span> <span class="k">async</span> <span class="o">-&gt;</span> <span class="kt">Sticker</span><span class="p">?</span> <span class="p">{</span>
        <span class="c1">// 이미지 처리 로직 (시간이 오래 걸릴 수 있음)</span>
        <span class="c1">// 이 함수가 MainActor에 격리되지 않아 백그라운드로 암시적 오프로드될 가능성</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">@MainActor</span> <span class="kd">final</span> <span class="kd">class</span> <span class="kt">StickerModel</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">photoProcessor</span> <span class="o">=</span> <span class="kt">PhotoProcessor</span><span class="p">()</span>

    <span class="kd">func</span> <span class="nf">extractSticker</span><span class="p">(</span><span class="n">_</span> <span class="nv">item</span><span class="p">:</span> <span class="kt">PhotosPickerItem</span><span class="p">)</span> <span class="k">async</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Sticker</span><span class="p">?</span> <span class="p">{</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">data</span> <span class="o">=</span> <span class="k">try</span> <span class="k">await</span> <span class="n">item</span><span class="o">.</span><span class="nf">loadTransferable</span><span class="p">(</span><span class="nv">type</span><span class="p">:</span> <span class="kt">Data</span><span class="o">.</span><span class="k">self</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="c1">// 여기서 photoProcessor.extractSticker 호출 시 데이터 경쟁 위험이 감지될 수 있음</span>
        <span class="k">return</span> <span class="k">await</span> <span class="n">photoProcessor</span><span class="o">.</span><span class="nf">extractSticker</span><span class="p">(</span><span class="nv">data</span><span class="p">:</span> <span class="n">data</span><span class="p">,</span> <span class="nv">with</span><span class="p">:</span> <span class="n">item</span><span class="o">.</span><span class="n">itemIdentifier</span><span class="p">)</span>
        <span class="c1">// 에러 메시지 예시: "Reference to property 'photoProcessor' in non-isolated actor-relative context cannot be used to satisfy an @MainActor requirement"</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>StickerModel.extractSticker: StickerModel 클래스가 @MainActor 로 정의하고 있기 때문에 MainActor에서 실행</li>
  <li>PhotoProcessor.extractSticker: MainActor에 격리되지 않아 백그라운드로 실행될 가능성 높음</li>
</ul>

<p>Swift 6.2의 개선:</p>

<p>Swift 6.2에서는 특정 액터에 연결되지 않은 비동기 함수(actor-isolated가 아닌 async 함수)는 이제 해당 함수가 호출된 액터에서 계속 실행됩니다. 즉, PhotoProcessor의 extractSticker와 같이 액터가 지정되지 않은 비동기 함수를 MainActor 내에서 호출하면, 해당 함수는 MainActor 컨텍스트 내에서 실행됩니다. 이는 비동기 함수에 전달된 값이 액터 외부로 전송되지 않도록 하여 데이터 경쟁을 방지합니다. 개발자는 비동기 함수가 내부적으로 작업을 오프로드하더라도 가변 상태에 대해 걱정할 필요가 없어집니다. 예를 들어, UI 업데이트 로직에서 MainActor를 잘못 타서 발생할 수 있었던 데이터 경쟁 문제를 예방할 수 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Swift 6.2</span>
<span class="c1">// 호출자의 액터에서 비동기 함수 실행</span>
<span class="kd">class</span> <span class="kt">PhotoProcessor</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">extractSticker</span><span class="p">(</span><span class="nv">data</span><span class="p">:</span> <span class="kt">Data</span><span class="p">,</span> <span class="n">with</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">String</span><span class="p">?)</span> <span class="k">async</span> <span class="o">-&gt;</span> <span class="kt">Sticker</span><span class="p">?</span> <span class="p">{</span>
        <span class="c1">// 이 함수는 여전히 MainActor에 있지 않지만,</span>
        <span class="c1">// MainActor에서 호출되면 MainActor 컨텍스트 내에서 실행됩니다.</span>
        <span class="c1">// 내부적으로 필요한 경우에만 명시적으로 다른 액터로 작업을 오프로드할 수 있습니다.</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">@MainActor</span> <span class="kd">final</span> <span class="kd">class</span> <span class="kt">StickerModel</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">photoProcessor</span> <span class="o">=</span> <span class="kt">PhotoProcessor</span><span class="p">()</span>

    <span class="kd">func</span> <span class="nf">extractSticker</span><span class="p">(</span><span class="n">_</span> <span class="nv">item</span><span class="p">:</span> <span class="kt">PhotosPickerItem</span><span class="p">)</span> <span class="k">async</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Sticker</span><span class="p">?</span> <span class="p">{</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">data</span> <span class="o">=</span> <span class="k">try</span> <span class="k">await</span> <span class="n">item</span><span class="o">.</span><span class="nf">loadTransferable</span><span class="p">(</span><span class="nv">type</span><span class="p">:</span> <span class="kt">Data</span><span class="o">.</span><span class="k">self</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="c1">// 이제 이 호출은 MainActor 컨텍스트 내에서 안전하게 이루어집니다.</span>
        <span class="k">return</span> <span class="k">await</span> <span class="n">photoProcessor</span><span class="o">.</span><span class="nf">extractSticker</span><span class="p">(</span><span class="nv">data</span><span class="p">:</span> <span class="n">data</span><span class="p">,</span> <span class="nv">with</span><span class="p">:</span> <span class="n">item</span><span class="o">.</span><span class="n">itemIdentifier</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p><strong>Swift 6.2에서는 비동기 함수가 호출된 액터에서 계속 실행되도록 변경되어, <code class="language-plaintext highlighter-rouge">MainActor</code> 내에서의 데이터 경쟁 위험을 줄였습니다.</strong></p>

</blockquote>

<h3 id="2-격리된-적합성-isolated-conformances">2. 격리된 적합성 (Isolated Conformances)</h3>

<p>Swift 6.2는 <code class="language-plaintext highlighter-rouge">MainActor</code>와 같은 액터에 격리된 유형(actor-isolated types)이 프로토콜을 준수하는 것을 더 쉽게 만들었습니다.</p>

<blockquote>
  <p><strong>Swift 6.2는 액터에 격리된 타입이 프로토콜을 더 쉽게 준수하도록 개선했습니다.</strong></p>

</blockquote>

<p>문제 상황 (Swift 6 이전):</p>

<p>MainActor에 격리된 StickerModel 클래스가 Exportable이라는 프로토콜을 준수해야 한다고 가정해 봅시다. Exportable 프로토콜은 액터 격리를 요구하지 않습니다. Swift 6에서는 컴파일러가 StickerModel의 export() 메서드가 MainActor 외부에서도 호출될 수 있다고 가정하여, MainActor 상태를 사용하는 것을 막았습니다. 이는 잠재적인 데이터 경쟁 때문입니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Swift 6 (이전)</span>
<span class="kd">protocol</span> <span class="kt">Exportable</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">export</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">StickerModel</span><span class="p">:</span> <span class="kt">Exportable</span> <span class="p">{</span>
    <span class="c1">// error: Conformance of 'StickerModel' to protocol 'Exportable' crosses into main actor-isolated code and can cause data races</span>
    <span class="c1">// StickerModel이 @MainActor로 격리되어 있기 때문에,</span>
    <span class="c1">// export() 메서드가 MainActor 외부에서 호출될 경우 데이터 경쟁이 발생할 수 있다고 컴파일러가 판단합니다.</span>
    <span class="kd">func</span> <span class="nf">export</span><span class="p">()</span> <span class="p">{</span> <span class="n">photoProcessor</span><span class="o">.</span><span class="nf">exportAsPNG</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Swift 6.2의 개선:</p>

<p>MainActor 상태를 필요로 하는 적합성은 이제 @MainActor 속성을 사용하여 <strong>‘격리된 적합성(Isolated Conformance)’</strong>으로 명시할 수 있습니다. 컴파일러는 MainActor 적합성이 MainActor 내에서만 사용되도록 보장하여 안전성을 유지합니다. 개발자는 코드가 동시적으로 적합성을 사용할 때만 데이터 경쟁 안전 문제를 해결하면 됩니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Swift 6.2</span>
<span class="kd">protocol</span> <span class="kt">Exportable</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">export</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// @MainActor 속성을 사용하여 StickerModel의 Exportable 적합성이 MainActor에 격리됨을 명시</span>
<span class="kd">extension</span> <span class="kt">StickerModel</span><span class="p">:</span> <span class="kd">@MainActor</span> <span class="kt">Exportable</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">export</span><span class="p">()</span> <span class="p">{</span> <span class="n">photoProcessor</span><span class="o">.</span><span class="nf">exportAsPNG</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// MainActor 격리된 ImageExporter 구조체 내에서 StickerModel을 사용하는 것은 안전합니다.</span>
<span class="kd">@MainActor</span> <span class="kd">struct</span> <span class="kt">ImageExporter</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">items</span><span class="p">:</span> <span class="p">[</span><span class="n">any</span> <span class="kt">Exportable</span><span class="p">]</span>

    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">add</span><span class="p">(</span><span class="n">_</span> <span class="nv">item</span><span class="p">:</span> <span class="kt">StickerModel</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">items</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">exportAll</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">item</span> <span class="k">in</span> <span class="n">items</span> <span class="p">{</span>
            <span class="n">item</span><span class="o">.</span><span class="nf">export</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 하지만 만약 ImageExporter가 nonisolated로 선언된다면, MainActor에 격리된 StickerModel의 적합성을</span>
<span class="c1">// nonisolated 컨텍스트에서 사용하려 할 때 컴파일러 오류가 발생합니다.</span>
<span class="c1">// 이는 컴파일러가 MainActor의 상태가 안전하게 유지되도록 강제하는 것입니다.</span>
<span class="kd">nonisolated</span> <span class="kd">struct</span> <span class="kt">ImageExporter</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">items</span><span class="p">:</span> <span class="p">[</span><span class="n">any</span> <span class="kt">Exportable</span><span class="p">]</span>

    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">add</span><span class="p">(</span><span class="n">_</span> <span class="nv">item</span><span class="p">:</span> <span class="kt">StickerModel</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">items</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="c1">// error: Main actor-isolated conformance of 'StickerModel' to 'Exportable' cannot be used in nonisolated context</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">exportAll</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">item</span> <span class="k">in</span> <span class="n">items</span> <span class="p">{</span>
            <span class="n">item</span><span class="o">.</span><span class="nf">export</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p><strong>이제 <code class="language-plaintext highlighter-rouge">@MainActor</code> 속성으로 프로토콜 적합성을 명시하여, <code class="language-plaintext highlighter-rouge">MainActor</code> 내에서 프로토콜을 안전하게 사용할 수 있습니다.</strong></p>

</blockquote>

<h3 id="3-기본-추론-모드-opt-in-mode-to-infer-mainactor-by-default">3. 기본 추론 모드 (Opt-in Mode to Infer MainActor by Default)</h3>

<p>이 모드는 프로젝트의 모든 가변 상태를 기본적으로 <code class="language-plaintext highlighter-rouge">MainActor</code>로 보호하여, 안전하지 않은 전역 및 정적 변수 호출과 같은 데이터 경쟁 안전 오류를 제거하는 <strong>선택적(opt-in) 기능</strong>입니다. 이는 대부분 단일 스레드인 코드에서 동시성 관련 주석을 줄이는 데 도움이 되며, 앱, 스크립트 및 기타 실행 대상에 권장됩니다.</p>

<blockquote>
  <p><strong>‘기본 추론 모드’는 프로젝트의 모든 가변 상태를 <code class="language-plaintext highlighter-rouge">MainActor</code>로 자동 보호하여 동시성 관련 주석을 줄여줍니다.</strong></p>

</blockquote>

<p>문제 상황 (Swift 6 이전):</p>

<p>전역 및 정적 변수는 어디서든 접근할 수 있는 가변 상태를 가질 수 있어 데이터 경쟁에 취약합니다. StickerLibrary.shared와 같은 정적 변수는 Sendable 타입이 아닌 경우 동시성 안전하지 않다는 경고 또는 오류를 발생시킬 수 있었습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Swift 6 (이전)</span>
<span class="c1">// 안전하지 않은 정적 변수 사용</span>
<span class="kd">final</span> <span class="kd">class</span> <span class="kt">StickerLibrary</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="k">let</span> <span class="nv">shared</span><span class="p">:</span> <span class="kt">StickerLibrary</span> <span class="o">=</span> <span class="o">.</span><span class="nf">init</span><span class="p">()</span> <span class="c1">// error: Static property 'shared' is not concurrency-safe because non-'Sendable' type 'StickerLibrary' may have shared mutable state</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Swift 6.2의 개선:</p>

<p>이 모드를 활성화하면, 기본적으로 모든 가변 상태가 MainActor로 추론되어 보호됩니다. 따라서 개발자가 PhotoProcessor와 같은 특정 유형이나 파일 내에 캡슐화된 동시성 코드를 제외하고 대부분의 코드를 단일 스레드처럼 작성하더라도, MainActor 주석을 명시적으로 추가할 필요 없이 안전한 코드를 작성할 수 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Swift 6.2 (기본 MainActor 추론 모드 활성화 시)</span>
<span class="c1">// 명시적인 @MainActor 주석 없이도 안전한 코드</span>
<span class="c1">// (프로젝트 설정에서 'Infer Main Actor by Default' 활성화 가정)</span>

<span class="kd">final</span> <span class="kd">class</span> <span class="kt">StickerLibrary</span> <span class="p">{</span>
    <span class="c1">// 이제 이 정적 변수는 자동으로 MainActor에 격리된 것으로 추론됩니다.</span>
    <span class="kd">static</span> <span class="k">let</span> <span class="nv">shared</span><span class="p">:</span> <span class="kt">StickerLibrary</span> <span class="o">=</span> <span class="o">.</span><span class="nf">init</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">final</span> <span class="kd">class</span> <span class="kt">StickerModel</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">photoProcessor</span><span class="p">:</span> <span class="kt">PhotoProcessor</span>
    <span class="k">var</span> <span class="nv">selection</span><span class="p">:</span> <span class="p">[</span><span class="kt">PhotosPickerItem</span><span class="p">]</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">StickerModel</span><span class="p">:</span> <span class="kt">Exportable</span> <span class="p">{</span>
    <span class="c1">// 이 적합성도 MainActor에 격리된 것으로 자동으로 추론됩니다.</span>
    <span class="kd">func</span> <span class="nf">export</span><span class="p">()</span> <span class="p">{</span> <span class="n">photoProcessor</span><span class="o">.</span><span class="nf">exportAsPNG</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>이 모드를 활성화하면 명시적인 <code class="language-plaintext highlighter-rouge">MainActor</code> 주석 없이도 대부분의 코드가 <code class="language-plaintext highlighter-rouge">MainActor</code>로 안전하게 보호됩니다.</strong></p>

<h3 id="4concurrent속성-the-attribute">4. <code class="language-plaintext highlighter-rouge">@concurrent</code> 속성 (The Attribute)</h3>

<p>CPU 집약적인 작업을 백그라운드로 오프로드할 때 앱의 반응성을 유지하기 위해 <strong><code class="language-plaintext highlighter-rouge">@concurrent</code> 속성</strong>이 도입되었습니다.</p>

<p><strong><code class="language-plaintext highlighter-rouge">@concurrent</code> 속성은 CPU 집약적인 작업을 백그라운드 스레드에서 실행하여 앱의 반응성을 유지하는 데 사용됩니다.</strong></p>

<p>사용 목적:</p>

<p>이 속성을 사용하면 함수가 항상 <strong>동시 스레드 풀(concurrent thread pool)</strong>에서 실행되도록 하여, 현재 액터(예: MainActor)가 다른 작업을 동시에 수행할 수 있도록 합니다. 이는 UI 스레드를 차단하지 않고 무거운 작업을 처리할 때 특히 유용합니다.</p>

<p>샘플 코드:</p>

<p>PhotoProcessor 클래스에서 이미지를 분석하여 스티커를 추출하는 extractSubject 메서드가 CPU 집약적인 작업이라고 가정해 봅시다. 이 작업을 @concurrent로 표시하면, 이 함수가 호출될 때 MainActor와 같은 호출 액터를 차단하지 않고 별도의 동시 스레드 풀에서 실행될 것임을 보장합니다. 실제 CPU 집약적인 작업에는 Core ML 모델 실행, 복잡한 이미지 필터링, 대용량 데이터 처리 등이 포함될 수 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Swift 6.2</span>
<span class="kd">class</span> <span class="kt">PhotoProcessor</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">cachedStickers</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">:</span> <span class="kt">Sticker</span><span class="p">]</span> <span class="o">=</span> <span class="p">[:]</span>

    <span class="kd">func</span> <span class="nf">extractSticker</span><span class="p">(</span><span class="nv">data</span><span class="p">:</span> <span class="kt">Data</span><span class="p">,</span> <span class="n">with</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">async</span> <span class="o">-&gt;</span> <span class="kt">Sticker</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nv">sticker</span> <span class="o">=</span> <span class="n">cachedStickers</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">sticker</span> <span class="c1">// 캐시된 스티커가 있다면 즉시 반환</span>
        <span class="p">}</span>

        <span class="c1">// extractSubject 메서드는 CPU 집약적이므로 @concurrent 속성을 사용하여 백그라운드 스레드에서 실행</span>
        <span class="k">let</span> <span class="nv">sticker</span> <span class="o">=</span> <span class="k">await</span> <span class="k">Self</span><span class="o">.</span><span class="nf">extractSubject</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="n">data</span><span class="p">)</span>
        <span class="n">cachedStickers</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">sticker</span>
        <span class="k">return</span> <span class="n">sticker</span>
    <span class="p">}</span>

    <span class="c1">// @concurrent 속성: 이 함수는 항상 동시 스레드 풀에서 실행됩니다.</span>
    <span class="kd">@concurrent</span> <span class="kd">static</span> <span class="kd">func</span> <span class="nf">extractSubject</span><span class="p">(</span><span class="n">from</span> <span class="nv">data</span><span class="p">:</span> <span class="kt">Data</span><span class="p">)</span> <span class="k">async</span> <span class="o">-&gt;</span> <span class="kt">Sticker</span> <span class="p">{</span>
        <span class="c1">// 실제 CPU 집약적인 이미지 처리 및 피사체 추출 로직</span>
        <span class="c1">// 예: Core ML 모델 실행, 복잡한 이미지 필터링 등</span>
        <span class="c1">// 이 작업은 MainActor를 차단하지 않습니다.</span>
        <span class="k">return</span> <span class="kt">Sticker</span><span class="p">()</span> <span class="c1">// 예시 반환</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p><strong><code class="language-plaintext highlighter-rouge">@concurrent</code>는 <code class="language-plaintext highlighter-rouge">MainActor</code>를 차단하지 않고 무거운 작업을 병렬 스레드에서 효율적으로 처리하도록 보장합니다.</strong></p>

</blockquote>

<hr />

<h3 id="더-쉬워진-동시성-더-강력해진-swift">더 쉬워진 동시성, 더 강력해진 Swift</h3>

<p><img src="/assets/images/ios/2025-06-14-WWDC25-Swift-62-동시성-개선/image 2.png" alt="image.png" /></p>

<p>이러한 언어 변경 사항들은 함께 작동하여 동시성을 더 쉽게 다룰 수 있도록 돕습니다. 개발자는 먼저 데이터 경쟁 위험이 없는 <strong><code class="language-plaintext highlighter-rouge">MainActor</code>에서 기본적으로 실행되는 코드를 작성</strong>하고, 필요할 때 병렬 실행을 위해 특정 코드를 안전하게 오프로드할 수 있습니다. 또한, Swift 6.2는 비동기 코드의 디버깅 경험을 크게 개선하여 LLDB가 스레드 간 전환 시에도 비동기 함수 실행을 추적하고, 작업 이름 지정 및 가시성을 제공합니다.</p>

<p>이러한 개선은 Swift 커뮤니티의 피드백을 통해 이루어졌으며, Swift가 초보자와 전문가 모두에게 더 쉽게 사용될 수 있도록 언어를 발전시키는 데 기여합니다.</p>

<blockquote>
  <p><strong>Swift 6.2의 개선 사항들은 동시성 코딩을 단순화하고 디버깅 경험을 향상시켜 Swift를 더욱 강력하게 만듭니다.</strong></p>

</blockquote>

<hr />

<h3 id="어떻게-적용할-수-있나요">어떻게 적용할 수 있나요?</h3>

<p>이러한 동시성 관련 언어 변경 사항들은 선택 사항으로 구성되었으며, Xcode 빌드 설정의 <strong>Swift 컴파일러 - 동시성 섹션</strong>에서 활성화할 수 있습니다. SwiftSettings API를 사용하여 Swift 패키지 매니페스트 파일에서도 이 기능을 활성화할 수 있습니다.</p>

<p>Xcode 빌드 설정에서 활성화:</p>

<p>Swift Compiler - Concurrency 섹션에서 “Strict Concurrency Checking”을 Complete로 설정하고 “Infer Main Actor by Default”를 활성화할 수 있습니다.</p>

<p>또한, Swift 6.2에는 필요한 코드 변경 사항을 자동으로 적용할 수 있는 <strong>마이그레이션 도구</strong>가 포함되어 있습니다. 이 도구는 주로 액터 격리 관련 경고 및 오류를 수정하고, <code class="language-plaintext highlighter-rouge">Sendable</code> 준수와 관련된 변경 사항을 제안하여 기존 코드를 새 동시성 모델에 맞게 업데이트하는 데 도움을 줍니다.</p>

<p>Swift 6.2의 동시성 개선은 개발자들이 더욱 안전하고 효율적인 애플리케이션을 만들 수 있도록 돕는 중요한 진전입니다. 지금 바로 Xcode를 업데이트하고 새로운 동시성 기능을 경험해 보세요!</p>

<blockquote>
  <p><strong>Swift 6.2 동시성 기능은 Xcode 빌드 설정이나 Swift Package Manager를 통해 활성화할 수 있으며, 기존 코드 마이그레이션 도구도 제공됩니다.</strong></p>

</blockquote>

<p><strong>참고:</strong> 이 글은 WWDC25 비디오 (“Improve memory usage and performance with Swift”, “What’s new in Swift”) 및 관련 Swift 6.2 발표 자료를 바탕으로 작성되었습니다.</p>

<hr />]]></content><author><name>jglee</name></author><category term="ios" /><summary type="html"><![CDATA[왜 동시성이 어려웠을까요?]]></summary></entry><entry><title type="html">Thinking in SwiftUI - 3장 Layout</title><link href="https://leejigun.github.io/Thinking-in-SwiftUI-3%EC%9E%A5-Layout" rel="alternate" type="text/html" title="Thinking in SwiftUI - 3장 Layout" /><published>2025-06-05T03:16:50+09:00</published><updated>2025-06-05T03:16:50+09:00</updated><id>https://leejigun.github.io/Thinking-in-SwiftUI---3%EC%9E%A5-Layout</id><content type="html" xml:base="https://leejigun.github.io/Thinking-in-SwiftUI-3%EC%9E%A5-Layout"><![CDATA[<h3 id="text">Text</h3>

<p>기본적으로 Text 뷰는 제안된 크기에 맞게 조정됩니다. 텍스트는 이 작업을 수행하기 위해 다음 순서로 여러 전략을 사용합니다: 텍스트를 여러 줄로 나누기(단어 줄 바꿈), 단어를 나누기(줄 바꿈), 자르기, 마지막으로 텍스트를 조정하기.</p>

<p>텍스트는 항상 콘텐츠를 렌더링하는데 필요한 정확한 크기를 반환합니다. 이 크기는 제안된 너비보다 작거나 같고 최소한 한 줄의 높이입니다(0 제안 제외). 즉, 텍스트는 0부터 콘텐츠 전체를 렌더링하는데 필요한 크기까지 임의의 너비를 가질 수 있습니다.</p>

<p>다음은 Text(“Hello, World!”)가 제안된 크기에 따라 어떻게 렌더링되는지에 대한 몇 가지 예입니다. 점선 사각형은 제안된 크기를 나타내고, 실선 사각형은 반환된 크기를 나타냅니다.</p>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 2.png" alt="Untitled" /></p>

<p>→ <code class="language-plaintext highlighter-rouge">.lineLimit(_ number:)</code>를 사용하면 제안된 수직 공간에 관계없이 렌더링할 최대 라인 수를 지정할 수 있습니다. nil을 지정하면 줄 제한이 없음을 의미합니다.</p>

<p>→ <code class="language-plaintext highlighter-rouge">.lineLimit(_limit:reservesSpace:)</code>를 사용하면 렌더링할 최대 줄 수를 지정하고, 비어 있는지 여부에 관계없이 보고된 크기에 이러한 줄의 공간을 항상 포함하는 옵션을 제공합니다.</p>

<p>→ <code class="language-plaintext highlighter-rouge">.truncationMode(_ mode:)</code>를 사용하면 잘림을 적용할 위치를 지정할 수 있습니다.</p>

<p>→ <code class="language-plaintext highlighter-rouge">.minimumScaleFactor(_ Factor:)</code>를 사용하면 제안된 크기에 맞도록 글꼴 크기를 축소할 수 있는 텍스트의 양을 지정할 수 있습니다.</p>

<p>만약, fixedSize()를 Text에 적용시키면, 제안과 다른 결과를 보여준다.</p>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 3.png" alt="Untitled" /></p>

<h3 id="shapes"><strong>Shapes</strong></h3>

<p>대부분의 기본 제공 모양(<strong>Rectangle</strong>, <strong>RoundedRectangle</strong>, <strong>Capsule</strong> 및 <strong>Ellipse</strong>)은 0부터 무한대까지 제안된 크기를 수용하고 사용 가능한 공간을 채웁 니다. <strong>원은 예외입니다.</strong> 제안된 크기에 맞춰지고 원의 실제 크기를 다시 보고합니다. 모양에 nil을 제안하는 경우(즉, .fixedSize로 래핑하는 경우) 기본 크기는 10 10입니다.</p>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 4.png" alt="Untitled" /></p>

<h2 id="colors"><strong>Colors</strong></h2>

<p><code class="language-plaintext highlighter-rouge">Color.red</code>와 같이 색상을 뷰로 직접 사용하는 경우, 레이아웃 관점에서는 <code class="language-plaintext highlighter-rouge">Rectangle().fill(⋯)</code>처럼 동작합니다.</p>

<p>그러나 특별한 경우가 있습니다. ignoresSafeAreaEdges에 색상을 넣으면, 해당 색상이 마법처럼 ignoresSafeAreaEdges으로 확장됩니다. 이 동작은 레이아웃에 영향을 주지 않지만, 우리 모두가 어느 시점에서 이 문제를 겪게 될 것이므로, 이를 언급하고자 했습니다. 이를 방지하기 위해서는, .background에서 ignoresSafeAreaEdges 매개변수를 사용하거나, Color 대신 Rectangle().fill(⋯)을 사용할 수 있습니다.</p>

<h3 id="image"><strong>Image</strong></h3>

<p>기본적으로 이미지 보기는 정적 값, 즉 기본 이미지의 크기를 보고합니다. 이미지에 대해 <code class="language-plaintext highlighter-rouge">.resizeable()</code>을 호출하면 보기가 완전히 유연해집니다. 그런 다음 이미지는 제안된 크기를 수락하고 이를 다시 보고하며 이미지를 해당 크기로 압축합니다. 실제로 크기 조 정이 가능한 거의 모든 이미지는 다음과 결합됩니다.</p>

<p>이미지가 왜곡되는 것을 방지하기 위한 <code class="language-plaintext highlighter-rouge">.aspectRatio(contentMode:)</code> 또는 <code class="language-plaintext highlighter-rouge">.scaleToFit()</code> modifier를 사용합니다.</p>

<h3 id="divider"><strong>Divider</strong></h3>

<p>구분선이 수평 스택 외부에서 사용되는 경우 제안된 너비를 수락하고 구분선의 높이를 보고합니다. 수평 스택 내에서 구분 선은 제안된 높이를 승인하고 구분선의 너비를 보고합니다. <strong>nil을 제안하면 상황에 따라 가변 축의 기본 크기가 10이 됩 니다.</strong></p>

<h3 id="spacer"><strong>Spacer</strong></h3>

<p>수평 또는 수직 스택 외부에서 Spacer는 <strong>최소 길이부터 무한대까지 제안된 크기를 허용</strong>합니다.</p>

<p>수직 스택 내에서 Spacer는 최소 길이에서 무한대까지의 높이를 허용하지만 <strong>너비 는 0으로 보고됩니다.</strong></p>

<p>스페이서의 최소 길이는 minLength를 사용하여 길이를 지정하지 않는 한 기본 패딩의 길이입니다.</p>

<h2 id="modifier-view">Modifier View</h2>

<hr />

<p>ViewModifier는 항상 다른 레이어 내부에 기존 뷰를 래핑합니다. <strong>수정자는 적용된 뷰의 상위가 됩니다.</strong> SwiftUI에는 ViewModifier 프로토콜을 준수하는 값을 적용하기 위한 .modifier API가 있지만 SwiftUI의 내장 수정자는 모두 View의 확장으로 노출됩니다(이는 자체 뷰 수정자에도 좋은 방법입니다). 이 섹션에서는 레이아웃에 영향을 미치는 뷰 수정자를 설명합니다.</p>

<h3 id="frame">Frame</h3>

<ul>
  <li>고정값 지정</li>
  <li>유연하게 지정
    <ul>
      <li>유연하게 frame 값을 설정한 경우 2번 범위를 정하게 됩니다.</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 5.png" alt="Untitled" /></p>

<p>만약 다음과 같이 설정한 경우 320 480 화면에서 렌더링될 때</p>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 6.png" alt="Untitled" /></p>

<ol>
  <li>
    <p>시스템은 패딩을 320, 480으로 제안합니다.</p>
  </li>
  <li>
    <p>패딩은 배경에 300 460을 제안합니다.</p>
  </li>
  <li>
    <p>배경은 기본 하위 뷰에 동일한 300 460을 제안합니다. (frame).</p>
  </li>
</ol>

<ul>
  <li>일단 가능한 최대값을 제안</li>
</ul>

<ol>
  <li>
    <p>프레임은 하위 뷰(텍스트)에 동일한 300 460을 제안합니다.</p>
  </li>
  <li>
    <p>텍스트에서는 크기가 76 17이라고 보고합니다.</p>
  </li>
  <li>
    <p>프레임의 너비는 max(0, min( .infinity, 300)) = 300이 됩니다.</p>
  </li>
</ol>

<ul>
  <li>0 및 .infinity 값은 유연한 프레임에 대해 지정된 인수입니다.</li>
</ul>

<ol>
  <li>
    <p>배경은 유연한 프레임의 크기(300 17)를 제안합니다.</p>
  </li>
  <li>
    <p>색상은 제안된 크기를 수락하고 보고합니다. (300 17)</p>
  </li>
  <li>
    <p>배경은 기본 하위 뷰의 크기(300 17)를 보고합니다.</p>
  </li>
  <li>
    <p>패딩은 각 측면에 10포인트를 추가하고 크기를 320 37로 보고합니다.</p>
  </li>
</ol>

<h2 id="aspectratio">AspectRatio</h2>

<p>AspectRatio 유연한 frame 사이즈로 작업할 때 유용하게 사용할 수 있습니다. 예를 들어 아래 코드는 4:3 인 직사각형을 그릴 수 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Color</span><span class="o">.</span><span class="n">secondary</span>
	<span class="o">.</span><span class="nf">aspectRatio</span><span class="p">(</span><span class="mi">4</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="nv">contentMode</span><span class="p">:</span> <span class="o">.</span><span class="n">fit</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 7.png" alt="Untitled" /></p>

<p>aspectRatio의 일반적으로 이미지에 사용합니다. 이미지에 .resizable() 을 붙이면 사이즈에 맞게 이미지가 늘어나거나 줄어드는데, 이미지가 깨지지 않도록 aspectRatio 를 사용해 화면 사이즈에 맞춰 이미지 사이즈를 조절할 수 있습니다.</p>

<p><strong>만약, 비율을 적용하지 않은 경우 어떻게 될까?</strong></p>

<p>aspectRatio modifier는 하위 뷰의 이상적인 크기를 제안을 통해 조사하고, 비율을 적용합니다.</p>

<p>만약, 이미지를 사용했을 때 이미지의 사이즈가 100:30 이라고 가정하고, 전체 사이즈가 200:200 이면, 아래와 같은 절차를 따라 사이즈를 설정합니다.</p>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 8.png" alt="Untitled" /></p>

<ol>
  <li>
    <p>AspectRatio의 크기는 200x200으로 제안을 내려보냅니다.</p>
  </li>
  <li>
    <p>AspectRatio는 이미지에 nil x nil로 제안합니다.(사이즈 제한 없이)</p>
  </li>
  <li>
    <p>이미지의 이상적인 크기는 100x30으로 제안을 올려보냅니다.</p>
  </li>
  <li>
    <p>가로 세로 비율이 100/30인 직사각형을 200 200에 맞춥니다.</p>
  </li>
</ol>

<ul>
  <li>200 60이며 이 크기를 이미지에 제안합니다.</li>
</ul>

<ol>
  <li>이미지의 크기는 200 60으로 보고됩니다.</li>
  <li>AspectRatio는 하위 뷰의 크기인 200 60을 자체 크기로 보고합니다.</li>
</ol>

<blockquote>
  <p>AspectRatio를 적용한다고 반드시 비율에 맞게 조정되는건 아닙니다. 하위뷰가 유연하지 않을 경우 적용되지 않을 수 있습니다.</p>

</blockquote>

<h3 id="overlay-and-background"><strong>Overlay and Background</strong></h3>

<p>Overlay와 Background는 SwiftUI에서 가장 유용한 수정자 중 하나입니다. 레이아웃 측면에서는 정확히 동일한 방식으로 작동합니다. 유일한 차이점은 Overlay는 기본 View 위에 보조 View를 그리는 반면, Background는 기본 View 뒤에 보조 View를 그리는 것입니다. 예를 들어, 일부 텍스트 뒤에 배경을 그리려면 다음과 같이 할 수 있습니다.</p>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 9.png" alt="Untitled" /></p>

<p>Background와 overlay는 기본 하위 View의 레이아웃에 영향을 미치지 않습니다. 보고된 overlay 또는 background의 크기는 항상 기본 하위 View의 보고된 크기입니다.</p>

<h2 id="container-view">Container View</h2>

<hr />

<p>HStack과 VStack은 단순해보이지만, 결과를 파악하는데 복잡할 수 있다.</p>

<p>만약 아래와 같이 사이즈를 지정하지 않은 경우 제안된 크기에 따라서 다른 결과가 나온다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">HStack</span><span class="p">(</span><span class="nv">spacing</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> 
	<span class="kt">Color</span><span class="o">.</span><span class="n">cyan</span> 
	<span class="kt">Text</span><span class="p">(</span><span class="s">"Hello, World!"</span><span class="p">)</span> 
	<span class="kt">Color</span><span class="o">.</span><span class="n">teal</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 10.png" alt="Untitled" /></p>

<ol>
  <li>큰 크기를 제공한 케이스 (150x50)
    <ol>
      <li>모두 충분한 크기를 제공받았지만, Text의 경우에는 텍스트가 들어간 경우의 사이즈가 이상적인 상한선 크기로 잡을 수 있다.</li>
      <li>그에 비해서 Color는 유연하기 때문에 채울 수 있는 만큼 Text를 채우고 남은 공간을 Color가 나눠 가지게 된다.</li>
    </ol>
  </li>
  <li>작은 크기를 제공한 케이스 (100x50)
    <ol>
      <li>3개 모두 표현하기에 충분하지 않은 사이즈가 나온 경우 3등분하게 된다. 필요에 따라서 텍스트가 줄바꿈되거나 잘리게 된다.</li>
    </ol>
  </li>
  <li>만약 극단적으로 작은 사이즈를 준다면 (40x40)
    <ol>
      <li>이 경우 사이즈를 설정할 수 없기 때문에, Text가 Container의 제안을 무시하고 이상적인 사이즈로 표시해버립니다.</li>
      <li>
        <p>대안은 .layoutPriority modifier를 적용해 내부 View 사이에 우선순위를 제공하는 것 입니다.</p>

        <p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 11.png" alt="Untitled" /></p>
      </li>
    </ol>
  </li>
</ol>

<h3 id="zstack">ZStack</h3>

<p>ZStack은 얼핏보면 overlay나 background와 동일한 역할을 할 것 같지만, overlay와 background는 ViewModifier기 때문에 하위뷰의 사이즈에 영향을 받는다. 그에 비해서 ZStack은 컨테이너기 때문에 내부의 View의 크기와 상관없이 Size를 잡게된다.</p>

<p>만약, 아래 코드를 root 에서 실행하게되면, 화면 전체를 다 가리게 된다.</p>

<h3 id="scrollview">ScrollView</h3>

<p>제안된 화면을 가득 채우게 되고, 내부 View는 contents의 사이즈에 맞춰진다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">ScrollView</span> <span class="p">{</span> 
	<span class="kt">Image</span><span class="p">(</span><span class="s">"logo"</span><span class="p">)</span>
		<span class="o">.</span><span class="nf">resizable</span><span class="p">()</span>
		<span class="o">.</span><span class="nf">aspectRatio</span><span class="p">(</span><span class="o">.</span><span class="n">fit</span><span class="p">)</span> 
	<span class="kt">Text</span><span class="p">(</span><span class="s">"This is a longer text"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>scrollView에 Shape 의 서브 뷰를 넣으면 10x10으로 표시되는 것을 볼 수 있다. 이는 Shape의 ProposedView의 기본값이 10, 10 이기 때문이다.</p>

</blockquote>

<h3 id="geometryreader"><strong>GeometryReader</strong></h3>

<p>제안받은 크기에 접근하는데 사용합니다. GeometryProxy 를 통해 제안받은 크기에 접근 할 수 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">GeometryReader</span> <span class="p">{</span> <span class="n">proxy</span> <span class="k">in</span> 
	<span class="kt">Text</span><span class="p">(</span><span class="nv">verbatim</span><span class="p">:</span> <span class="s">"</span><span class="se">\(</span><span class="n">proxy</span><span class="o">.</span><span class="n">size</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>그러나 스택 오버플로우나 다른 사이트를 볼 때 GeometryReader에서 이슈가 생겨 고통받는 경우가 많습니다. 예를 들어서 GeometryReader 를 주위에 배치하고, Text의 사이즈를 측정하려고 하는 경우 Text 주변의 레이아웃이 잘못 나오는 경우가 많이 보고됩니다.</p>

<p>GeometryReader는 꼭 필요한 경우에만 써야 하고, 다음과 같은 경우에 유용하게 사용할 수 있습니다.</p>

<ul>
  <li>GeometryReader 내부에 유연한 View를 넣는 경우 레이아웃 사이즈를 체크할 수 있습니다.
    <ul>
      <li>예를 들어서 ScrollView 안에 GeometryReader를 넣는 경우 ScrollView의 내부 View 사이즈를 알 수 있습니다.</li>
    </ul>
  </li>
  <li>background나 overlay 안에 GeometryReader를 넣으면 기본 View 크기에는 영향을 미치지 않지만 관련된 다양한 값을 읽을 수 있습니다. (고급 레이아웃 장에서 더 자세한 예를 살펴보겠습니다.)</li>
</ul>

<h3 id="list">List</h3>

<hr />

<p>List는 UIkit에서 UITableView와 동일합니다. List 자체는 제안받은 크기를 가지며, ScrollView와 유사하게 View 자체는 너비와 높이를 제안하지 않습니다.</p>

<p>행의 높이가 고정되지 않은 UITableView와 비슷하고 내부에 배치된 항목을 기준으로 내부 View의 높이를 추정합니다.</p>

<h3 id="lazyhstack-lazyvstack">LazyHStack, LazyVStack</h3>

<p>List와 동일하게 View가 보여질 때 업데이트 한다.</p>

<h3 id="lazyvgrid-lazyhgrid">LazyVGrid, LazyHGrid</h3>

<p>LazyVGrid와 LazyHGrid는 모두 동일한 기본 알고리즘을 사용하여 열이나 행의 크기를 계산하므로 이 섹션 에서는 LazyVGrid에 중점을 둘 것입니다.</p>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 12.png" alt="Untitled" /></p>

<p>그리드는 iOS 16에서 추가되었고, 17 이상에서도 아직 버그가 많기 때문에 짧게 다루고 넘어간다.</p>

<p>(가급적 쓰지 말것)</p>

<h3 id="viewthatfits"><strong>ViewThatFits</strong></h3>

<p>제안된 크기에 따라 다른 보기를 표시하려면 ViewThatFits를 사용하면 됩니다. 여러 개의 하위 뷰가 필요한 경우, 제안된 크기에 맞는 첫 번째 하위 뷰를 표시합니다. 이는 각 하위 뷰의 이상적인 크기를 파악하기 위해 nil을 제안하고, 이상적인 크기가 제안된 크기 내에 맞는 첫 번째 하위 뷰(코드에 하위 뷰가 나타나는 순서대로)를 표시합니다. 적합한 하위 뷰가 없으면 마지막 하위 뷰를 선택합니다.</p>

<h3 id="rendering-modiers"><strong>Rendering Modi!ers</strong></h3>

<p>SwiftUI에는 offset, RotationEffect, scaleEffect 등과 같이 뷰의 렌더링 방식에는 영향을 주지만 레이아웃 자체에는 영향을 미치지 않는 여러 뷰 수정자가 있습니다. 이러한 수정자는 CGContext.translate와 같은 작업을 수행한다고 생각할 수 있습니다. 이는 뷰가 그려지는 위치를 변경하지만, 레이아웃 시스템에서 보면 뷰는 여전히 원래 위치에 있습니다.</p>

<h2 id="alignment"><strong>Alignment</strong></h2>

<p>기본적으로 거의 모든 뷰는 하위 뷰의 중앙에 배치됩니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Text</span><span class="p">(</span><span class="s">"Hello"</span><span class="p">)</span>
	<span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">width</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="nv">height</span><span class="p">:</span> <span class="mi">100</span><span class="p">)</span> <span class="c1">// 기본값이 .center</span>
</code></pre></div></div>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 13.png" alt="Untitled" /></p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Text</span><span class="p">(</span><span class="s">"Hello"</span><span class="p">)</span>
	<span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">width</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="nv">height</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="nv">alignment</span><span class="p">:</span> <span class="o">.</span><span class="n">bottomTrailing</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 14.png" alt="Untitled" /></p>

<p>정렬 가이드</p>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 15.png" alt="Untitled" /></p>

<p>ZStack 역시 기본값은 .center라 아래의 경우 가운데에 쌓이게 된다.</p>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 16.png" alt="Untitled" /></p>

<h3 id="정렬-가이드-수정">정렬 가이드 수정</h3>

<p>center, bottom같은 기본 정렬 가이드라인을 수정할 수 있다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">image</span> <span class="o">=</span> <span class="kt">Image</span><span class="p">(</span><span class="nv">systemName</span><span class="p">:</span> <span class="s">"pencil.circle.!ll"</span><span class="p">)</span> 
	<span class="o">.</span><span class="nf">alignmentGuide</span><span class="p">(</span><span class="o">.</span><span class="n">firstTextBaseline</span><span class="p">,</span> <span class="nv">computeValue</span><span class="p">:</span> <span class="p">{</span> <span class="n">dimension</span> <span class="k">in</span>
		<span class="n">dimension</span><span class="o">.</span><span class="n">height</span><span class="o">/</span><span class="mi">2</span> 
	<span class="p">}</span>
<span class="p">)</span>
</code></pre></div></div>

<p>image의 .firstTextBaseline을 줄여서 Image 가 firstTextBaseline으로 정렬했더니 아래로 밀리게 된다.</p>

<p>이렇게 수정한 이미지를 적용하면 다음과 같이 가이드라인이 변경된다.</p>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 17.png" alt="Untitled" /></p>

<p>하지만 firstTextBaseline 을 수정했기 때문에 center로 설정하면 바뀌는게 없다.</p>

<p>이를 사용해 다음과 같이 범용적으로 적용 가능한 뱃지 아이콘을 만들수도 있다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="n">badge</span><span class="o">&lt;</span><span class="kt">B</span><span class="p">:</span> <span class="kt">View</span><span class="o">&gt;</span><span class="p">(</span><span class="kd">@ViewBuilder</span> <span class="n">_</span> <span class="nv">badge</span><span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">B</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="nf">overlay</span><span class="p">(</span><span class="nv">alignment</span><span class="p">:</span> <span class="o">.</span><span class="n">topTrailing</span><span class="p">)</span> <span class="p">{</span> <span class="nf">badge</span><span class="p">()</span>
                <span class="o">.</span><span class="nf">alignmentGuide</span><span class="p">(</span><span class="o">.</span><span class="n">top</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">height</span><span class="o">/</span><span class="mi">2</span> <span class="p">}</span>
		            <span class="o">.</span><span class="nf">alignmentGuide</span><span class="p">(</span><span class="o">.</span><span class="n">trailing</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span> <span class="p">}</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="/assets/images/uncategorized/2025-07-19-Thinking-in-SwiftUI---3장-Layout/Untitled 18.png" alt="Untitled" /></p>]]></content><author><name>jglee</name></author><category term="uncategorized" /><summary type="html"><![CDATA[Text]]></summary></entry><entry><title type="html">Thinking in SwiftUI - 2장 State and Binding</title><link href="https://leejigun.github.io/Thinking-in-SwiftUI-2%EC%9E%A5-State-and-Binding" rel="alternate" type="text/html" title="Thinking in SwiftUI - 2장 State and Binding" /><published>2025-06-05T03:16:40+09:00</published><updated>2025-06-05T03:16:40+09:00</updated><id>https://leejigun.github.io/Thinking-in-SwiftUI---2%EC%9E%A5-State-and-Binding</id><content type="html" xml:base="https://leejigun.github.io/Thinking-in-SwiftUI-2%EC%9E%A5-State-and-Binding"><![CDATA[<ul>
  <li><a href="https://wlaxhrl.tistory.com/91">https://wlaxhrl.tistory.com/91</a></li>
</ul>

<p>(Data Flow Through SwiftUI)</p>

<p><strong>(여기서 중요한건 SSOT !!)</strong></p>

<h3 id="state"><strong>@State</strong></h3>

<hr />

<p><strong>뷰의 상태를 관리하기 위한 프로퍼티 래퍼.</strong></p>

<ul>
  <li>Value Type</li>
  <li>뷰의 로컬 데이터 (내부 프로퍼티)</li>
  <li>뷰에서 소유되고 관리되어야 하는 데이터 (ex. 텍스트필드, 토글버튼 등)</li>
</ul>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---2장-State-and-Binding/Untitled.png" alt="Untitled" /></p>

<p>Counter 예시를 살펴보면, 버튼을 누를 때마다 상태값이 변경되고 화면이 다시 그려집니다. 만약 버튼의 라벨에 상태값을 바인딩하지 않았다면, SwiftUI는 업데이트할 필요가 없다는 것을 인지하고 화면을 다시 그리지 않습니다.</p>

<h2 id="view의-생성-4단계">View의 생성 4단계</h2>

<hr />

<ol>
  <li>Counter 구조체가 처음 생성되면, View tree는 만들어지지만 아직 Render tree에 노드가 존재하지 않습니다. State라는 PropertyWrapper 역시 초기값을 할당하고 있지만, 아직 아무것도 바인딩하지 않았기 떄문에 View는 비어있습니다.</li>
</ol>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---2장-State-and-Binding/Untitled 1.png" alt="Untitled" /></p>

<ol>
  <li>SwiftUI는 Render tree에 노드를 생성하면서 State를 할당합니다. 이제 PropertyWrapper 의 메모리는 랜더 노드를 가리키게 됩니다.</li>
</ol>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---2장-State-and-Binding/Untitled 2.png" alt="Untitled" /></p>

<ol>
  <li>View의 body 부분이 실행되고, <code class="language-plaintext highlighter-rouge">Button</code>이 생성됩니다. 이제 state 값은 랜더 노드를 가리키고 있기 때문에 <code class="language-plaintext highlighter-rouge">Button</code> 의 label 값은 랜더 노드에 저장된 값을 사용합니다.</li>
</ol>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---2장-State-and-Binding/Untitled 3.png" alt="Untitled" /></p>

<ol>
  <li>마지막으로 노드의 값을 읽어 값이 설정된 view body 부분을 랜더링해 실제 UI를 만듭니다.</li>
</ol>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---2장-State-and-Binding/Untitled 4.png" alt="Untitled" /></p>

<h2 id="이벤트-발생-3단계">이벤트 발생 3단계</h2>

<hr />

<ol>
  <li>View에 이벤트가 발생하면 뷰와 연결된 랜더 트리에 전달되고, 랜더 트리를 지켜보고 있던 PropertyWrapper 쪽에 메모리가 증가합니다.</li>
  <li>State가 변경되었기 때문에 body가 다시 실행되고, View tree 가 구성됩니다.</li>
  <li>다시 구성된 View tree를 기반으로 랜더트리의 값이 변경되고, UI가 다시 랜더링됩니다.</li>
</ol>

<p>(ex) <strong>SwiftUI 프레임워크의 Button의 highlight 상태는 Button 내부에서 @State로 관리된다.</strong> 이는 터치 중일 때는 highlighted 상태로, 터치가 끝났을 때는 highlighted가 아닌 상태로 관리될 수 있기 때문에, <strong>외부에서 관리할 필요 없이 Button 내부에서만 관리</strong>하면 된다.</p>

<blockquote>
  <p>원래 @State property wrapper는 value type에만 사용했지만, iOS 17에서 Observable 매크로가 도입되면서 변경되었다. 하지만, 17 이전 OS에서는 value 타입에만 사용해야 합니다.</p>

</blockquote>

<h2 id="state-and-observable"><strong>State and Observable</strong></h2>

<hr />

<p>@State를 사용할 때 2가지 실수를 저지를 수 있습니다.</p>

<ol>
  <li>외부에서 전달받은 객체를 사용하는 경우</li>
  <li>View 전용 객체인데, @State를 사용하지 않는 경우</li>
</ol>

<p>둘 다 객체의 수명과 관련이 있습니다. 외부에서 수명이 관리되는 객체의 경우 @State를 사용하지 않는다는 것 입니다.</p>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---2장-State-and-Binding/Untitled 5.png" alt="Untitled" /></p>

<p>만약, 위와 같이 모델을 외부에서 전달받는 경우 초기값은 Button에 잘 셋팅되겠지만, 이미 View가 만들어진 상태에서 외부에서 Model의 값을 변경해도 상태 변화에 영향을 주지 못합니다.</p>

<h2 id="observableobject-protocol"><strong>ObservableObject Protocol</strong></h2>

<hr />

<p>iOS 17 이후에는 @Obserable 매크로를 사용해 편하게 사용할 수 있지만, 17 이전에는 다양안 <strong>ObservableObject Protocol</strong> 의 속성 래퍼는 사용할 수 있습니다.</p>

<ol>
  <li>@StateObject
    <ol>
      <li>@State와 거의 동일한 방식으로 동작</li>
      <li>랜더 트리에 노드가 생성될 때 초기값을 지정합니다.</li>
      <li>@State와 동일하게 private하게 사용해야 합니다. (외부에서  전답하거나, 조작하지 말것)</li>
    </ol>
  </li>
  <li>@ObservableObject
    <ol>
      <li>@StateObject 보다 간단한 구조로 초기값을 할당하지 않고 구독한 하는 관계</li>
    </ol>
  </li>
</ol>

<h2 id="observableobject"><strong>@ObservableObject</strong></h2>

<hr />

<ul>
  <li>Reference Type</li>
  <li>이미 관리(소유)하고 있는 데이터에 적용하면 좋음</li>
  <li>외부로부터의 데이터를 표현할 때</li>
</ul>

<p>case 1 : State 로 int 값을 표현할 때</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">ContentView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@State</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">rootCount</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">CountView</span><span class="p">(</span><span class="nv">rootCount</span><span class="p">:</span> <span class="n">rootCount</span><span class="p">)</span>
        <span class="kt">Button</span><span class="p">(</span><span class="nv">action</span><span class="p">:</span> <span class="p">{</span><span class="n">rootCount</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">},</span> <span class="nv">label</span><span class="p">:</span> <span class="p">{</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"Root Add"</span><span class="p">)</span>
        <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>case 2 : ObservedObject 로 모델을 표현할 때</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">CountView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@ObservedObject</span> <span class="k">var</span> <span class="nv">viewModel</span> <span class="o">=</span> <span class="kt">CountViewModel</span><span class="p">()</span>
    <span class="k">let</span> <span class="nv">rootCount</span><span class="p">:</span> <span class="kt">Int</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">VStack</span> <span class="p">{</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"Root: </span><span class="se">\(</span><span class="n">rootCount</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"Count: </span><span class="se">\(</span><span class="n">viewModel</span><span class="o">.</span><span class="n">count</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
            <span class="kt">Button</span><span class="p">(</span><span class="nv">action</span><span class="p">:</span> <span class="p">{</span><span class="n">viewModel</span><span class="o">.</span><span class="nf">addCount</span><span class="p">()},</span> <span class="nv">label</span><span class="p">:</span> <span class="p">{</span>
                <span class="kt">Text</span><span class="p">(</span><span class="s">"Counter Add"</span><span class="p">)</span>
            <span class="p">})</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="https://miro.medium.com/v2/resize:fit:302/1*6QE-DMrqDVycvuFBx0sp4g.gif" alt="" /></p>

<p>Root Add 버튼을 누를 때마다 ViewModel이 초기화되고 있었다. 그러니까 Count가 0부터 새롭게 시작하게 된다.</p>

<blockquote>
  <p>ViewModel이 View에 붙어있기 때문에 root add 버튼을 누르면 뷰가 새로 만들어지면서 ViewModel 도 교체된다.</p>

</blockquote>

<h3 id="stateobject"><strong>@StateObject</strong></h3>

<blockquote>
  <p>A state object behaves like an observed object, except that SwiftUI knows to create and manage a single object instance for a given view instance, regardless of how many times it recreates the view.</p>

</blockquote>

<p>StateObject는 ObservedObject와 거의 똑같으나, 이 StateObject는 하나의 객체로 만들어지고, View가 얼마나 초기화되든지 상관없이 별개의 객체로 관리된다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">CountView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@StateObject</span> <span class="k">var</span> <span class="nv">viewModel</span> <span class="o">=</span> <span class="kt">CountViewModel</span><span class="p">()</span>
    <span class="k">let</span> <span class="nv">rootCount</span><span class="p">:</span> <span class="kt">Int</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">VStack</span> <span class="p">{</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"Root: </span><span class="se">\(</span><span class="n">rootCount</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"Count: </span><span class="se">\(</span><span class="n">viewModel</span><span class="o">.</span><span class="n">count</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
            <span class="kt">Button</span><span class="p">(</span><span class="nv">action</span><span class="p">:</span> <span class="p">{</span><span class="n">viewModel</span><span class="o">.</span><span class="nf">addCount</span><span class="p">()},</span> <span class="nv">label</span><span class="p">:</span> <span class="p">{</span>
                <span class="kt">Text</span><span class="p">(</span><span class="s">"Counter Add"</span><span class="p">)</span>
            <span class="p">})</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="https://miro.medium.com/v2/resize:fit:302/1*8Kw64zPUp4mu4KmVMzo6fg.gif" alt="" /></p>

<p>Root Add를 눌러도 Count가 초기화되지 않는다! 기존의 데이터가 보존되는 것을 확인할 수 있다.</p>

<h3 id="stateobject-vs-observedobject">StateObject vs ObservedObject</h3>

<p>애플이 추천하는 StateObject와 ObservedObject의 사용법은 Observable Object를 처음 초기화할 때는 StateObject를 사용하고, 이미 객체화된 것을 넘겨 받을 때 ObservedObject의 사용을 추천하고 있다. </p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 직접 View에서 만들 때</span>
<span class="kd">struct</span> <span class="kt">UpperView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
  <span class="kd">@StateObject</span> <span class="k">var</span> <span class="nv">viewModel</span><span class="p">:</span> <span class="kt">ViewModel</span> <span class="o">=</span> <span class="kt">ViewModel</span><span class="p">()</span>
  <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kt">LowerView</span><span class="p">(</span><span class="nv">viewModel</span><span class="p">:</span> <span class="n">viewModel</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 외부에서 넘겨받을 때</span>
<span class="kd">struct</span> <span class="kt">LowerView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
  <span class="kd">@ObservedObject</span> <span class="k">var</span> <span class="nv">viewModel</span><span class="p">:</span> <span class="kt">ViewModel</span>
  <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kt">Text</span><span class="p">(</span><span class="s">"Hello"</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>@StateObject</strong>와 <strong>@ObservedObject</strong>는 각각의 생명주기와 사용법을 살펴보자.</p>

<ol>
  <li><strong>@StateObject</strong>:
    <ul>
      <li><strong>생명주기</strong>: <strong>@StateObject</strong>는 뷰가 생성될 때 인스턴스를 만들고, 뷰가 소멸될 때 인스턴스를 해제합니다. 뷰의 생명주기와 일치하며, 뷰가 인스턴스를 소유하고 관리합니다.</li>
      <li><strong>사용법</strong>: 주로 뷰 내에서 상태를 유지해야 하는 경우에 사용됩니다. 예를 들어, 뷰 내에서 데이터를 수정하고 해당 변경 사항을 추적해야 할 때 유용합니다.</li>
    </ul>
  </li>
  <li><strong>@ObservedObject</strong>:
    <ul>
      <li><strong>생명주기</strong>: <strong>@ObservedObject</strong>는 뷰가 생성될 때마다 새로운 인스턴스를 만듭니다. 뷰의 생명주기와는 독립적으로 동작하며, 뷰가 인스턴스를 소유하지 않습니다. 따라서 뷰가 인스턴스를 생성하고 해제하지 않습니다.</li>
      <li><strong>사용법</strong>: 다른 뷰에서 관찰하고 싶은 객체의 변경 사항을 감지할 때 사용됩니다. 주로 다른 뷰에서 생성한 인스턴스를 참조하고 싶을 때 유용합니다.</li>
    </ul>
  </li>
</ol>

<p>간단히 말하면, <strong>@StateObject</strong>는 뷰가 인스턴스를 소유하고 관리하며, <strong>@ObservedObject</strong>는 뷰가 인스턴스를 생성하지 않고 변경 사항을 감지할 때 사용됩니다. 이를 이해하면 SwiftUI에서 상태 관리를 더 효율적으로 할 수 있습니다!</p>

<h2 id="update-view-performance">Update, View Performance</h2>

<hr />

<p>앞서 본 것과 같이 State와 UI가 연결되어 자동으로 업데이트 된다. 상태가 변경된다고 전체 UI를 다시 그리는게 아니라, 특정 State와 View 사이에 종속성을 설정해 그 부분만 업데이트 되게 된다.</p>

<p>SwiftUI는 일부 State가 변경 될 때 View Tree에서 꼭 필요한 부분만 다시 랜더링되도록 많은 노력을 기울인다. 그러니 이런 노력을 방해하지 않는 방식으로 코드를 작성하는 것도 중요하다.</p>

<ol>
  <li>예를 들어 모든 State를 하나의 큰 객체 안에 넣는다면, 특정 변경으로 모든 하위의 작은 뷰를 업데이트 할 수 있다. 따라서 State를 작은 단위로 나눠서 뷰를 업데이트 하는게 성능적으로 더 도움이됩니다.</li>
  <li>실제로 필요한 값만 하위 View로 전달하는게 중요합니다. 많은 데이터를 가진 큰 객체가 있고, 이 객체를 통으로 넘겨주게 되면, 객체가 업데이트 될 때 마다 객체가 업데이트 될 수 있습니다.</li>
</ol>

<p>성능 이슈가 발생할 때 어떤 뷰의 body가 실행되는지 판단하는 몇가지 방법이 있습니다.</p>

<h3 id="1-print-삽입">1. print 삽입</h3>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---2장-State-and-Binding/Untitled 6.png" alt="Untitled" /></p>

<h3 id="2-selfprintcahnges">2. Self.printCahnges()</h3>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---2장-State-and-Binding/Untitled 7.png" alt="Untitled" /></p>

<p>print문과 다르게 재실행된 이유를 같이 호출해줍니다.</p>

<ul>
  <li>상태 변경으로 다시 호출되는 경우 ⇒ 상태 이름, 속성 표시</li>
  <li>뷰 값 자체가 변경된 경우 ⇒ 속성이 변경된 경우 @self가 기록됩니다.</li>
  <li>View의 ID 값이 변경된 경우 ⇒ @identity가 기록됩니다. (일반적으로 새로 삽입된 경우)</li>
</ul>

<h3 id="3-instruments">3. instruments</h3>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---2장-State-and-Binding/Untitled 8.png" alt="Untitled" /></p>

<h3 id="observable-매크로"><strong>Observable 매크로</strong></h3>

<hr />

<p><a href="https://developer.apple.com/documentation/Observation">Observation</a>을 통해 SwiftUI는 observable data model 에 의존성을 형성하고 data 가 변할때마다 UI 를 업데이트 합니다.</p>

<h3 id="기존-observableobject-와-달라지는-것들"><strong>기존 ObservableObject 와 달라지는 것들</strong></h3>

<p><strong>첫번째: 코드가 간결해짐</strong></p>

<p>| <strong>AS-IS</strong> | <strong>TO-BE</strong> |
| — | — |
| final class Book: ObservableObject {
    @Published var title = “Sample Book Title”
    var isAvailable = true
}</p>

<p>struct BookView: View {
    @ObservedObject var book: Book
    
    var body: some View {
        Text(book.title)
    }
} | @Observable final class Book {
    var title = “Sample Book Title”
    var isAvailable = true
}</p>

<p>struct BookView: View {
    var book: Book
    
    var body: some View {
        Text(book.title)
    }
} |</p>

<p><strong>두번째: 뷰 업데이트 매커니즘이 좀 더 효율적으로 바뀜</strong></p>

<p>@Observable 매크로를 쓰면</p>

<p>뷰의 body 에서 프로퍼티를 직접 읽어야지만 뷰 업데이트가 된다.</p>

<p>ObservableObject에서는 published 프로퍼티가 변하면 뷰가 해당 프로퍼티를 읽고 있지 않아도 다시 그려진다.</p>

<p><strong>세번째: data model object 를 optional로 들고 있을 수 있다.</strong></p>

<p><strong>네번째: data model objects를 collection으로도 가능하다.</strong></p>

<p><a href="https://eunjin3786.tistory.com/580"><strong>https://eunjin3786.tistory.com/580</strong></a></p>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---2장-State-and-Binding/Untitled 9.png" alt="Untitled" /></p>

<ul>
  <li>매크로 기능은 iOS 17 이상</li>
</ul>

<p>새로운 매크로 기반 객체 관찰 모델은 <strong>편리한 구문</strong>을 도입하고, 뷰와 관찰 가능한 객체 간의 종속성이 형성되는 방식을 변경합니다. 이전 속성 래퍼를 사용할 때, SwiftUI는 <code class="language-plaintext highlighter-rouge">@StateObject</code>의 <code class="language-plaintext highlighter-rouge">objectWillChange</code> 게시자를 맹목적으로 구독하거나, <code class="language-plaintext highlighter-rouge">@ObservedObject</code>를 뷰에서 선언했습니다.</p>

<p>새로운 <code class="language-plaintext highlighter-rouge">Observable</code> 매크로를 사용하면, <code class="language-plaintext highlighter-rouge">Observable</code>의 모든 속성이 뷰 본문에서 접근하는 객체는 객체가 어디에서 왔는지에 관계없이 이 뷰에 대한 종속성을 형성합니다.</p>

<p><strong>이 새로운 모델은 훨씬 더 간결하고 효율적입니다.</strong> 예를 들어, 뷰 본문에서 전역 <strong>싱글톤(관찰 가능)</strong>에 액세스할 경우, <code class="language-plaintext highlighter-rouge">@ObservedObject</code>를 사용하여 싱글톤을 뷰에 전달할 필요 없이, 액세스된 속성과 뷰 사이에 자동으로 종속성이 형성됩니다. 관찰 가능한 객체는 옵션, 배열 또는 다른 컬렉션에 중첩될 수 있으며, 속성 수준 추적으로 인해 관찰 및 뷰 업데이트가 예상대로 계속 작동합니다.</p>

<p>또한, 뷰 본문에서 객체의 속성 하나만 사용하는 경우, 다른 속성이 변경되어도 이 뷰는 다시 그려지지 않습니다. 모델 객체를 사용하지 않는 경우(예: 코드의 한 분기에만 존재하는 경우), 모델은 전혀 관찰되지 않습니다. 이를 통해 불필요한 뷰 업데이트를 줄여 성능을 향상시킬 수 있습니다. 이전에는 모델 객체를 수동으로 분할하여 더 세분화된 뷰 업데이트를 얻었습니다.</p>]]></content><author><name>jglee</name></author><category term="swiftui" /><category term="ios" /><summary type="html"><![CDATA[https://wlaxhrl.tistory.com/91]]></summary></entry><entry><title type="html">Thinking in SwiftUI - 1장 View Trees</title><link href="https://leejigun.github.io/Thinking-in-SwiftUI-1%EC%9E%A5-View-Trees" rel="alternate" type="text/html" title="Thinking in SwiftUI - 1장 View Trees" /><published>2025-06-05T03:16:30+09:00</published><updated>2025-06-05T03:16:30+09:00</updated><id>https://leejigun.github.io/Thinking-in-SwiftUI---1%EC%9E%A5-View-Trees</id><content type="html" xml:base="https://leejigun.github.io/Thinking-in-SwiftUI-1%EC%9E%A5-View-Trees"><![CDATA[<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---1장-View-Trees/Untitled.png" alt="Untitled" /></p>

<p>위와 같은 코드를 작성하면, 중앙에 일시적인 청사진이 구축되며, 이를 ‘View Tree’라고 합니다. 그 결과, 왼쪽처럼 View가 렌더링되어 보여집니다.</p>

<p>뷰 트리를 살펴보면, 트리는 역순으로 그려집니다. ‘<code class="language-plaintext highlighter-rouge">background</code>‘는 트리의 최상단에 위치하지만, 실제로는 아무것도 그리지 않고, ‘<code class="language-plaintext highlighter-rouge">Text</code>’ 뒤쪽에 위치하게 됩니다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">View Tree</code>: 일시적인 인스턴스로 뷰를 구성하는 청사진</li>
</ul>

<p>만약, 아래와 같이 순서를 변경하게 된다면</p>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---1장-View-Trees/Untitled 1.png" alt="Untitled" /></p>

<p><code class="language-plaintext highlighter-rouge">background</code>는 <code class="language-plaintext highlighter-rouge">padding</code>의 자식이 되며, <code class="language-plaintext highlighter-rouge">Text</code>에 <code class="language-plaintext highlighter-rouge">background</code>이 붙게 됩니다. 그러면 <code class="language-plaintext highlighter-rouge">background</code>에 <code class="language-plaintext highlighter-rouge">padding</code>이 붙어서 다음과 같은 모습이 됩니다.</p>

<h2 id="viewbuilders"><strong>ViewBuilders</strong></h2>

<hr />

<p>SwiftUI는 ‘<strong>뷰 빌더(ViewBuilder)</strong>‘라는 특별한 구문을 이용해 뷰 목록을 구성합니다. 뷰 빌더는 이 목적을 위해 Swift 언어에 추가된 결과 빌더 기능을 기반으로 만들어졌습니다. 예를 들어, 이미지를 텍스트 옆에 표시하는 뷰를 구성하는 방법은 다음과 같습니다.</p>

<p>(뷰 빌더는 <code class="language-plaintext highlighter-rouge">ResultBuilder</code> 피처의 위에 구현되었다)</p>

<ul>
  <li><a href="https://minsone.github.io/swift-resultbuilder">https://minsone.github.io/swift-resultbuilder</a></li>
  <li><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0289-result-builders.md">https://github.com/apple/swift-evolution/blob/main/proposals/0289-result-builders.md</a></li>
</ul>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---1장-View-Trees/Untitled 2.png" alt="Untitled" /></p>

<p><strong><code class="language-plaintext highlighter-rouge">HStack</code></strong>은 클로저를 매개변수로 사용하며, 이 클로저는 <strong><code class="language-plaintext highlighter-rouge">@ViewBuilder</code></strong>로 표시됩니다. 이를 통해 내부에 여러 표현식을 작성할 수 있으며, 각 표현식은 뷰를 나타냅니다. 본질적으로 스택에 전달된 클로저는 이 예제에서 스택의 하위 뷰가 되는 뷰 목록을 생성합니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">ViewBuilder</span> <span class="p">{</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">func</span> <span class="n">buildBlock</span><span class="o">&lt;</span><span class="kt">C0</span><span class="p">,</span> <span class="kt">C1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">c0</span><span class="p">:</span> <span class="kt">C0</span><span class="p">,</span> <span class="n">_</span> <span class="nv">c1</span><span class="p">:</span> <span class="kt">C1</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="kt">TupleView</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">C0</span><span class="p">,</span> <span class="kt">C1</span><span class="p">)</span><span class="o">&gt;</span> <span class="k">where</span> <span class="kt">C0</span> <span class="p">:</span> <span class="kt">View</span><span class="p">,</span> <span class="kt">C1</span> <span class="p">:</span> <span class="kt">View</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위 예제의 스택에는 내부에 <strong>두 개의 뷰 표현식</strong>이 있으므로 두 개의 매개변수가 있는 뷰 빌더의 <strong><code class="language-plaintext highlighter-rouge">buildBlock</code></strong> 메소드가 호 출됩니다. 반환 유형에서 볼 수 있듯이 이는 이미지와 텍스트라는 두 가지 보기를 래핑하는 <strong><code class="language-plaintext highlighter-rouge">TupleView</code></strong>를 구성합니다. 뷰 빌더 를 뷰 목록을 나타내는 <strong><code class="language-plaintext highlighter-rouge">TupleView</code></strong>를 구성하는 메커니즘으로 생각할 수 있습니다.</p>

<p><strong>하위 뷰를 구성하는 뷰 컴포넌트</strong> (암시적으로 <code class="language-plaintext highlighter-rouge">@ViewBuilder</code>로 표시)</p>

<ul>
  <li>스택, 그리드 등과 같은 <strong>모든 컨테이너 뷰</strong></li>
  <li><code class="language-plaintext highlighter-rouge">background</code>, <code class="language-plaintext highlighter-rouge">overlay</code>..</li>
</ul>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---1장-View-Trees/Untitled 3.png" alt="Untitled" /></p>

<ul>
  <li><a href="https://zeddios.tistory.com/m/1366">https://zeddios.tistory.com/m/1366</a></li>
</ul>

<h2 id="dynamic-content-동적-컨텐츠"><strong>Dynamic Content (동적 컨텐츠)</strong></h2>

<hr />

<p>SwiftUI 코드를 작성하고 ViewBuilder를 통해서 View 목록을 작성하는데, 이 때 View 목록도 동적일 수 있습니다. if - else 구문을 통해서 뷰를 동적으로 구성하는 방법은 아래와 같습니다.</p>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---1장-View-Trees/Untitled 4.png" alt="Untitled" /></p>

<p>if 문 대신, if let, switch 문도 사용 가능합니다.</p>

<h2 id="render-trees">Render Trees</h2>

<hr />

<p>View Tree는 일시적으로 만들어지는 청사진의 역할을 하는 반면에, Render Tree는 더 긴 수명으로 계속 머무르다가 상태가 바뀌면 현재 상태를 반영하도록 업데이트 하는 역할을 합니다.</p>

<p>랜더 트리는 SwiftUI 내부에 존재하기 때문에, 직접 다룰일은 없습니다. 하지만, SwiftUI의 동작을 이해하는데 유용한 모델입니다.</p>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---1장-View-Trees/Untitled 5.png" alt="Untitled" /></p>

<p>만약 옵셔널한 View 구조가 있다면, View Tree에서는 다음과 같이 생성됩니다.</p>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---1장-View-Trees/Untitled 6.png" alt="Untitled" /></p>

<p>하지만, Render Tree의 경우에는 다릅니다. Text가 nil일 경우 View Tree가 Render Tree를 만들 땐 실제로 View에 대응되도록 HStack 안에 Image 하나만 존재합니다.</p>

<p>만약에 State가 업데이트되서 View 업데이트가 동작하게 된다면, Render Tree에 Text가 삽입되거나, 제거됩니다. (하지만, Text의 문구가 변경어도 Text View가 새로 만들어지는 건 아닙니다.)</p>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---1장-View-Trees/Untitled 7.png" alt="Untitled" /></p>

<h2 id="lifetime">LifeTime</h2>

<hr />

<p>위에서 언급했듯이 View Tree는 일시적인 청사진의 역할을 합니다. 따라서 View의 수명(Life Time)과는 관계가 없습니다. 하지만 Render Tree는 처음 랜더링 된 시점부터 View가 더 이상 표시되지 않을 때 까지 수명을 가집니다. 다만, Render Treedml 수명은 화면상의 UI와 동일하지 않습니다.</p>

<p>만약, 스크롤 뷰 안에 큰 VStack이 있고 많은 View를 랜더링하는 경우 화면에 View가 보이는 여뷰랑 상관없이 모든 VStack의 하위 뷰 노드가 만들어집니다.</p>

<p>VStack은 LazyStack과 달리 바로 바쁘게 랜더링을 시작합니다. 그렇다고 LazyStack을 사용한다고 바로 바로 화면에서 보이지 않는다고 해제되는 건 아닙니다. 생성되는 시점이 늦어질 뿐 화면을 벗어나도 Render 노드가 유지됩니다.</p>

<p>(자세한 내용은 상태(State)에 대한 파트에서 다룰 예정입니다. 중요한건 렌더 트리의 노드를 통제할 수 없다는 것 입니다.)</p>

<p>SwiftUI에서는 실용적인 사용을 위해서 View의 LifeTime을 체크할 수 있도록 3가지 인터페이스 터널을 제공합니다.</p>

<ol>
  <li>onAppear
    <ol>
      <li>뷰가 화면에 나타날 때마다 실행됩니다. Render Tree의 노드가 생산될 때 호출되는게 아니라, View가 화면에 노출될 때마다 실행되기 때문에 여러번 호출할 수 있습니다. 예를들어서 LazyVStack 또는 List의 뷰가 스크롤을 통해 화면 밖으로 나갔다가 다시 돌아올 경우에도 매번 onAppear가 호출됩니다.</li>
      <li>TabView에서 탭을 전환할 때 역시 매번 호출됩니다.</li>
    </ol>
  </li>
  <li>onDisappear
    <ol>
      <li>화면에서 뷰가 사라질 때 호출됩니다. onAppear와 동일한 규칙으로 여러번 호출될 수 있습니다.</li>
    </ol>
  </li>
  <li>task
    <ol>
      <li>비동기 작업에 사용되는 onAppear와 onDisappear 두가지의 조합입니다. 이 task modifier는 onAppear가 호출되는 시점에 작업을 생성하고, onDisappear가 호출되는 시점에 작업을 취소합니다.</li>
    </ol>
  </li>
</ol>

<p>View의 id가 유지되는 동안은 값이 변경되어도 SwiftUI 관점에서의 View는 동일합니다.</p>

<p>State, ObservedObject는 View의 id와 연결된 저장소입니다. View의 lifetime 동안 body가 재계산되더라도 저장소의 메모리를 유지합니다.</p>

<p>View의 id가 변경되면 새로운 View로 간주되며 이전 View는 메모리에서 해제됩니다.</p>

<p>SwiftUI에서 View의 lifetime과 State의 lifetime은 동일한 의미를 갖습니다.</p>

<h2 id="identity-식별성"><strong>Identity (식별성)</strong></h2>

<hr />

<p>만약 작성한 코드에서 View의 ID값을 할당하지 않는다면, View Tree에서 생성될 View마다 고유 ID 값을 할당합니다. 이렇게 자동으로 할당되는 ID를 암시적 ID라 합니다. 이 ID 값을 통해서 뷰를 식별할 수 있고 ID가 동일할 경우 View를 새로 만드는게 아닌, 상태값을 업데이트 합니다.</p>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---1장-View-Trees/Untitled 8.png" alt="Untitled" /></p>

<p>특이한 부분은 if else  브랜치에서 1이라는 동일한 ID 값 아래에 다른 ID값을 가진다는 것 입니다. 따라서 동일한 양쪽 다 동일한 Text를 사용하고 있지만, 다른 ID값을 가지고 있어 condition이 변경되면 새로 View를 만들어 추가하게 됩니다.</p>

<p>View Tree에서의 암시적인 ID 할당이 아닌, 명시적으로 ID 값을 할당할 수도 있습니다. 주로 ForEach를 통해 반복적인 View를 생성하고 해당 View의 상태를 업데이트 하기 위해서 명시적으로 ID를 지정합니다.</p>

<p>ID는 Hashable 값을 사용할 수 있습니다.</p>

<p>아래의 경우 true, false 값을 ID로 사용해 2개의 Text를 번갈아 추가 삭제 할 수 있습니다.</p>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---1장-View-Trees/Untitled 9.png" alt="Untitled" /></p>

<ul>
  <li>Explicit id는 <strong><code class="language-plaintext highlighter-rouge">.id(_:)</code></strong> 메서드를 사용하여 명시적으로 지정할 수 있습니다.</li>
</ul>

<p>그렇다면, 다음과 같이 하나의 Text를 만들어서 2번 사용하는 경우 ID값이 어떻게 될까?</p>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---1장-View-Trees/Untitled 10.png" alt="Untitled" /></p>

<p>View Tree에 표시된 것 처럼 다른 위치에 있기 때문에 View Tree에서 서로 다른 암시적인 ID값을 할당하고 별도의 뷰로 간주됩니다. 이 부분 때문에 View Tree를 청사진이라 생각할 수 있는 것 입니다.</p>

<p>다음으로 만약에 이런 condition에 따라 분기하는 applayIf 를 만들고 적용하면 어떻게 될까?</p>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---1장-View-Trees/Untitled 11.png" alt="Untitled" /></p>

<p>적용한 코드 샘플을 보면 if else 형태로 하이라이트가 들어가면 background 모디파이어를 추가하는 형태로 구현하고 View Tree 역시 if else 형태와 유사한 모습을 보이고 있다.</p>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---1장-View-Trees/Untitled 12.png" alt="Untitled" /></p>

<p>이 경우 동일하게 Text는 변함이 없지만, 불필요하게 2개의 Text가 condition에 따라서 생성, 제거되는 모습을 볼 수 있다. 이런 패턴이 아닌 아래와 같은 패턴을 사용하는게 좋다.</p>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---1장-View-Trees/Untitled 13.png" alt="Untitled" /></p>

<p>이 경우 if else 의 값에 따라서 상태값을 변경해 랜더 노드를 추가, 삭제하지 않는다.</p>

<h2 id="view의-life-time-단계">View의 Life Time 단계</h2>

<hr />

<h3 id="1-appearing">1. Appearing</h3>

<ol>
  <li>스테이트 구독 (State, <strong>ObservedObject</strong>)</li>
  <li>body 계산, 스테이트 연결</li>
  <li>body 처음 호출</li>
  <li><strong>뷰 그래프</strong> 업데이트, UI 그리기</li>
  <li><strong>onAppear는 top-down으로 실행됨</strong></li>
</ol>

<h3 id="2-updating">2. Updating</h3>

<ol>
  <li>스테이트 변경 또는 publisher 구독으로 유저 액션 발생</li>
  <li>이전 스냅샷과 뷰 계층 비교</li>
  <li>변경된 뷰를 무력화한다</li>
  <li>뷰 그래프 업데이트하고 무력화된 뷰를 그림. 모든 업데이트 플로우는 뷰 계층을 타고 내려옴</li>
</ol>

<h3 id="3-disappearing">3. Disappearing</h3>

<ol>
  <li>뷰 계층에서 제거되고 호출. top-down으로 실행</li>
  <li>View가 화면에서 사라질 때 발생합니다.</li>
  <li>이 단계에서는 View의 정리(clean-up) 작업이 이루어집니다.</li>
  <li>예를 들어, <strong><code class="language-plaintext highlighter-rouge">onDisappear</code></strong> modifier를 사용하여 Disappearing 단계에서 리소스를 해제하거나 데이터를 저장할 수 있습니다.</li>
</ol>

<p><a href="https://www.vadimbulavin.com/swiftui-view-lifecycle/">https://www.vadimbulavin.com/swiftui-view-lifecycle/</a></p>

<p><img src="/assets/images/swiftui/2025-07-19-Thinking-in-SwiftUI---1장-View-Trees/Untitled 14.png" alt="Untitled" /></p>]]></content><author><name>jglee</name></author><category term="swiftui" /><category term="ios" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Thinking in SwiftUI - 3장 Layout</title><link href="https://leejigun.github.io/Thinking-in-SwiftUI-3%EC%9E%A5-Layout" rel="alternate" type="text/html" title="Thinking in SwiftUI - 3장 Layout" /><published>2024-05-27T04:47:00+09:00</published><updated>2024-05-27T04:47:00+09:00</updated><id>https://leejigun.github.io/Thinking-in-SwiftUI---3%EC%9E%A5-Layout</id><content type="html" xml:base="https://leejigun.github.io/Thinking-in-SwiftUI-3%EC%9E%A5-Layout"><![CDATA[<h1 id="thinking-in-swiftui---3장-layout">Thinking in SwiftUI - 3장 Layout</h1>

<p>Created: 2024년 5월 26일 오후 10:51</p>

<p>SwiftUI의 레이아웃 알고리즘은 간단합니다. 상위 뷰는 하위 뷰에 크기를 제안하고, 하위 뷰는 그 제안에 따라 자신의 크기를 결정 후, 이 크기를 상위 뷰에 보고합니다. 그 다음 상위 뷰는 이를 자신의 좌표계 내에 배치합니다. 본질적으로, 레이아웃 프로세스의 목표는 각 뷰에 위치와 크기를 제공하는 것입니다.</p>

<p>가장 먼저 염두에 두어야 할 점은 SwiftUI의 레이아웃 알고리즘이 뷰 트리를 따라 <strong>하향식으로 진행</strong>된다는 것입니다. 그러므로 뷰 빌더 코드에 의해 생성된 뷰 트리를 이해하는 것이 중요합니다</p>

<p>( 이에 대한 자세한 내용은 뷰 트리 장을 참조하세요 ).</p>

<p>실제 뷰 트리에 레이아웃 알고리즘을 적용하는 방법을 더 잘 이해하기 위해 예제를 살펴보겠습니다.</p>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/3/Untitled.png" alt="Untitled" /></p>

<p>이 예에서 VStack은 루트 뷰이므로 안전 화면 영역을 제안된 크기로 받게 됩니다. 자체 크기를 결정하기 위해 스택은 먼저 하위 뷰에 크기를 재귀적으로 제안합니다.</p>

<p>이미지는 지구본 기호의 크기를 기준으로 크기를 보고하고, 텍스트는 제안된 크기와 렌더링해야 하는 문자열을 기준으로 크기를 보고합니다. 이미지와 텍스트가 크기를 정확히 결정하는 방법에 대해 자세히 설명하겠습니다(크기는 나중에).</p>

<p>이제 스택은 두 개의 하위 뷰를 서로 아래에 배치하여 둘 사이에 기본 간격을 삽입합니다. 스택은 하위 뷰 프레임의 합집합 크기로 자체 크기를 계산하고 이를 다시 창에 보고합니다.</p>

<ol>
  <li>상위 뷰는 하위 뷰에 크기를 제안합니다.</li>
  <li>하위 뷰는 이 제안을 기반으로 자신의 크기를 결정하며, 자신의 하위 뷰가 있는 경우 1단계부터 다시 시작합니다.</li>
  <li>하위 뷰는 결정한 크기를 상위 뷰에 보고합니다.</li>
  <li>상위 뷰는 보고받은 크기에 따라 하위 뷰를 배치합니다.</li>
</ol>

<blockquote>
  <p>3단계에서 하위 뷰에 의해 보고된 크기는 하위 뷰의 최종 크기입니다. 상위 뷰는 이 크기를 일방적으로 변경할 수 없습니다. 상위 뷰는 2단계로 돌아가 또 다른 크기 제안을 할 수 있지만, 결국 하위 뷰는 자신에게 적합한 크기를 선택하여 결정합니다.</p>

</blockquote>

<p>자세한 순서를 다시 보면 아래와 같습니다.</p>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/3/Untitled 1.png" alt="Untitled" /></p>

<p>이 예시에서는 safe area 가 320 480인 창이 있다고 가정합니다.</p>

<ol>
  <li>시스템은 배경에 320 480 사이즈를 제안합니다.</li>
  <li>배경은 기본 하위 뷰에 동일한 320 480 사이즈를 제안합니다.</li>
  <li>패딩은 각 가장자리에서 10포인트를 뺀 300 460 사이즈를 텍스트에 제안합니다.</li>
  <li>텍스트는 그 크기를 51 17로 보고합니다.</li>
  <li>패딩은 각 가장자리에 10포인트를 추가하여, 크기를 71 37로 보고합니다.</li>
  <li>배경은 보조 하위 뷰(색상)에 패딩된 텍스트의 크기인 71 37을 제안합니다.</li>
  <li>색상은 제안된 71 37 사이즈를 수용하고 그대로 보고합니다.</li>
  <li>배경은 기본 하위 뷰의 크기인 71 37을 보고합니다.</li>
</ol>

<h2 id="leaf-views"><strong>Leaf Views</strong></h2>

<hr />

<h3 id="text">Text</h3>

<p>기본적으로 Text 뷰는 제안된 크기에 맞게 조정됩니다. 텍스트는 이 작업을 수행하기 위해 다음 순서로 여러 전략을 사용합니다: 텍스트를 여러 줄로 나누기(단어 줄 바꿈), 단어를 나누기(줄 바꿈), 자르기, 마지막으로 텍스트를 조정하기.</p>

<p>텍스트는 항상 콘텐츠를 렌더링하는데 필요한 정확한 크기를 반환합니다. 이 크기는 제안된 너비보다 작거나 같고 최소한 한 줄의 높이입니다(0 제안 제외). 즉, 텍스트는 0부터 콘텐츠 전체를 렌더링하는데 필요한 크기까지 임의의 너비를 가질 수 있습니다.</p>

<p>다음은 Text(“Hello, World!”)가 제안된 크기에 따라 어떻게 렌더링되는지에 대한 몇 가지 예입니다. 점선 사각형은 제안된 크기를 나타내고, 실선 사각형은 반환된 크기를 나타냅니다.</p>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/3/Untitled 2.png" alt="Untitled" /></p>

<p>→ <code class="language-plaintext highlighter-rouge">.lineLimit(_ number:)</code>를 사용하면 제안된 수직 공간에 관계없이 렌더링할 최대 라인 수를 지정할 수 있습니다. nil을 지정하면 줄 제한이 없음을 의미합니다.</p>

<p>→ <code class="language-plaintext highlighter-rouge">.lineLimit(_limit:reservesSpace:)</code>를 사용하면 렌더링할 최대 줄 수를 지정하고, 비어 있는지 여부에 관계없이 보고된 크기에 이러한 줄의 공간을 항상 포함하는 옵션을 제공합니다.</p>

<p>→ <code class="language-plaintext highlighter-rouge">.truncationMode(_ mode:)</code>를 사용하면 잘림을 적용할 위치를 지정할 수 있습니다.</p>

<p>→ <code class="language-plaintext highlighter-rouge">.minimumScaleFactor(_ Factor:)</code>를 사용하면 제안된 크기에 맞도록 글꼴 크기를 축소할 수 있는 텍스트의 양을 지정할 수 있습니다.</p>

<p>만약, fixedSize()를 Text에 적용시키면, 제안과 다른 결과를 보여준다.</p>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/3/Untitled 3.png" alt="Untitled" /></p>

<h3 id="shapes"><strong>Shapes</strong></h3>

<p>대부분의 기본 제공 모양(<strong>Rectangle</strong>, <strong>RoundedRectangle</strong>, <strong>Capsule</strong> 및 <strong>Ellipse</strong>)은 0부터 무한대까지 제안된 크기를 수용하고 사용 가능한 공간을 채웁 니다. <strong>원은 예외입니다.</strong> 제안된 크기에 맞춰지고 원의 실제 크기를 다시 보고합니다. 모양에 nil을 제안하는 경우(즉, .fixedSize로 래핑하는 경우) 기본 크기는 10 10입니다.</p>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/3/Untitled 4.png" alt="Untitled" /></p>

<h2 id="colors"><strong>Colors</strong></h2>

<p><code class="language-plaintext highlighter-rouge">Color.red</code>와 같이 색상을 뷰로 직접 사용하는 경우, 레이아웃 관점에서는 <code class="language-plaintext highlighter-rouge">Rectangle().fill(⋯)</code>처럼 동작합니다.</p>

<p>그러나 특별한 경우가 있습니다. ignoresSafeAreaEdges에 색상을 넣으면, 해당 색상이 마법처럼 ignoresSafeAreaEdges으로 확장됩니다. 이 동작은 레이아웃에 영향을 주지 않지만, 우리 모두가 어느 시점에서 이 문제를 겪게 될 것이므로, 이를 언급하고자 했습니다. 이를 방지하기 위해서는, .background에서 ignoresSafeAreaEdges 매개변수를 사용하거나, Color 대신 Rectangle().fill(⋯)을 사용할 수 있습니다.</p>

<h3 id="image"><strong>Image</strong></h3>

<p>기본적으로 이미지 보기는 정적 값, 즉 기본 이미지의 크기를 보고합니다. 이미지에 대해 <code class="language-plaintext highlighter-rouge">.resizeable()</code>을 호출하면 보기가 완전히 유연해집니다. 그런 다음 이미지는 제안된 크기를 수락하고 이를 다시 보고하며 이미지를 해당 크기로 압축합니다. 실제로 크기 조 정이 가능한 거의 모든 이미지는 다음과 결합됩니다.</p>

<p>이미지가 왜곡되는 것을 방지하기 위한 <code class="language-plaintext highlighter-rouge">.aspectRatio(contentMode:)</code> 또는 <code class="language-plaintext highlighter-rouge">.scaleToFit()</code> modifier를 사용합니다.</p>

<h3 id="divider"><strong>Divider</strong></h3>

<p>구분선이 수평 스택 외부에서 사용되는 경우 제안된 너비를 수락하고 구분선의 높이를 보고합니다. 수평 스택 내에서 구분 선은 제안된 높이를 승인하고 구분선의 너비를 보고합니다. <strong>nil을 제안하면 상황에 따라 가변 축의 기본 크기가 10이 됩 니다.</strong></p>

<h3 id="spacer"><strong>Spacer</strong></h3>

<p>수평 또는 수직 스택 외부에서 Spacer는 <strong>최소 길이부터 무한대까지 제안된 크기를 허용</strong>합니다.</p>

<p>수직 스택 내에서 Spacer는 최소 길이에서 무한대까지의 높이를 허용하지만 <strong>너비 는 0으로 보고됩니다.</strong></p>

<p>스페이서의 최소 길이는 minLength를 사용하여 길이를 지정하지 않는 한 기본 패딩의 길이입니다.</p>

<h2 id="modifier-view">Modifier View</h2>

<hr />

<p>ViewModifier는 항상 다른 레이어 내부에 기존 뷰를 래핑합니다. <strong>수정자는 적용된 뷰의 상위가 됩니다.</strong> SwiftUI에는 ViewModifier 프로토콜을 준수하는 값을 적용하기 위한 .modifier API가 있지만 SwiftUI의 내장 수정자는 모두 View의 확장으로 노출됩니다(이는 자체 뷰 수정자에도 좋은 방법입니다). 이 섹션에서는 레이아웃에 영향을 미치는 뷰 수정자를 설명합니다.</p>

<h3 id="frame">Frame</h3>

<ul>
  <li>고정값 지정</li>
  <li>유연하게 지정
    <ul>
      <li>유연하게 frame 값을 설정한 경우 2번 범위를 정하게 됩니다.</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/3/Untitled 5.png" alt="Untitled" /></p>

<p>만약 다음과 같이 설정한 경우 320 480 화면에서 렌더링될 때</p>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/3/Untitled 6.png" alt="Untitled" /></p>

<ol>
  <li>
    <p>시스템은 패딩을 320, 480으로 제안합니다.</p>
  </li>
  <li>
    <p>패딩은 배경에 300 460을 제안합니다.</p>
  </li>
  <li>
    <p>배경은 기본 하위 뷰에 동일한 300 460을 제안합니다. (frame).</p>
  </li>
</ol>

<ul>
  <li>일단 가능한 최대값을 제안</li>
</ul>

<ol>
  <li>
    <p>프레임은 하위 뷰(텍스트)에 동일한 300 460을 제안합니다.</p>
  </li>
  <li>
    <p>텍스트에서는 크기가 76 17이라고 보고합니다.</p>
  </li>
  <li>
    <p>프레임의 너비는 max(0, min( .infinity, 300)) = 300이 됩니다.</p>
  </li>
</ol>

<ul>
  <li>0 및 .infinity 값은 유연한 프레임에 대해 지정된 인수입니다.</li>
</ul>

<ol>
  <li>
    <p>배경은 유연한 프레임의 크기(300 17)를 제안합니다.</p>
  </li>
  <li>
    <p>색상은 제안된 크기를 수락하고 보고합니다. (300 17)</p>
  </li>
  <li>
    <p>배경은 기본 하위 뷰의 크기(300 17)를 보고합니다.</p>
  </li>
  <li>
    <p>패딩은 각 측면에 10포인트를 추가하고 크기를 320 37로 보고합니다.</p>
  </li>
</ol>

<h2 id="aspectratio">AspectRatio</h2>

<p>AspectRatio 유연한 frame 사이즈로 작업할 때 유용하게 사용할 수 있습니다. 예를 들어 아래 코드는 4:3 인 직사각형을 그릴 수 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Color</span><span class="o">.</span><span class="n">secondary</span>
	<span class="o">.</span><span class="nf">aspectRatio</span><span class="p">(</span><span class="mi">4</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="nv">contentMode</span><span class="p">:</span> <span class="o">.</span><span class="n">fit</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/3/Untitled 7.png" alt="Untitled" /></p>

<p>aspectRatio의 일반적으로 이미지에 사용합니다. 이미지에 .resizable() 을 붙이면 사이즈에 맞게 이미지가 늘어나거나 줄어드는데, 이미지가 깨지지 않도록 aspectRatio 를 사용해 화면 사이즈에 맞춰 이미지 사이즈를 조절할 수 있습니다.</p>

<p><strong>만약, 비율을 적용하지 않은 경우 어떻게 될까?</strong></p>

<p>aspectRatio modifier는 하위 뷰의 이상적인 크기를 제안을 통해 조사하고, 비율을 적용합니다.</p>

<p>만약, 이미지를 사용했을 때 이미지의 사이즈가 100:30 이라고 가정하고, 전체 사이즈가 200:200 이면, 아래와 같은 절차를 따라 사이즈를 설정합니다.</p>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/3/Untitled 8.png" alt="Untitled" /></p>

<ol>
  <li>
    <p>AspectRatio의 크기는 200x200으로 제안을 내려보냅니다.</p>
  </li>
  <li>
    <p>AspectRatio는 이미지에 nil x nil로 제안합니다.(사이즈 제한 없이)</p>
  </li>
  <li>
    <p>이미지의 이상적인 크기는 100x30으로 제안을 올려보냅니다.</p>
  </li>
  <li>
    <p>가로 세로 비율이 100/30인 직사각형을 200 200에 맞춥니다.</p>
  </li>
</ol>

<ul>
  <li>200 60이며 이 크기를 이미지에 제안합니다.</li>
</ul>

<ol>
  <li>이미지의 크기는 200 60으로 보고됩니다.</li>
  <li>AspectRatio는 하위 뷰의 크기인 200 60을 자체 크기로 보고합니다.</li>
</ol>

<blockquote>
  <p>AspectRatio를 적용한다고 반드시 비율에 맞게 조정되는건 아닙니다. 하위뷰가 유연하지 않을 경우 적용되지 않을 수 있습니다.</p>

</blockquote>

<h3 id="overlay-and-background"><strong>Overlay and Background</strong></h3>

<p>Overlay와 Background는 SwiftUI에서 가장 유용한 수정자 중 하나입니다. 레이아웃 측면에서는 정확히 동일한 방식으로 작동합니다. 유일한 차이점은 Overlay는 기본 View 위에 보조 View를 그리는 반면, Background는 기본 View 뒤에 보조 View를 그리는 것입니다. 예를 들어, 일부 텍스트 뒤에 배경을 그리려면 다음과 같이 할 수 있습니다.</p>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/3/Untitled 9.png" alt="Untitled" /></p>

<p>Background와 overlay는 기본 하위 View의 레이아웃에 영향을 미치지 않습니다. 보고된 overlay 또는 background의 크기는 항상 기본 하위 View의 보고된 크기입니다.</p>

<h2 id="container-view">Container View</h2>

<hr />

<p>HStack과 VStack은 단순해보이지만, 결과를 파악하는데 복잡할 수 있다.</p>

<p>만약 아래와 같이 사이즈를 지정하지 않은 경우 제안된 크기에 따라서 다른 결과가 나온다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">HStack</span><span class="p">(</span><span class="nv">spacing</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> 
	<span class="kt">Color</span><span class="o">.</span><span class="n">cyan</span> 
	<span class="kt">Text</span><span class="p">(</span><span class="s">"Hello, World!"</span><span class="p">)</span> 
	<span class="kt">Color</span><span class="o">.</span><span class="n">teal</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/3/Untitled 10.png" alt="Untitled" /></p>

<ol>
  <li>큰 크기를 제공한 케이스 (150x50)
    <ol>
      <li>모두 충분한 크기를 제공받았지만, Text의 경우에는 텍스트가 들어간 경우의 사이즈가 이상적인 상한선 크기로 잡을 수 있다.</li>
      <li>그에 비해서 Color는 유연하기 때문에 채울 수 있는 만큼 Text를 채우고 남은 공간을 Color가 나눠 가지게 된다.</li>
    </ol>
  </li>
  <li>작은 크기를 제공한 케이스 (100x50)
    <ol>
      <li>3개 모두 표현하기에 충분하지 않은 사이즈가 나온 경우 3등분하게 된다. 필요에 따라서 텍스트가 줄바꿈되거나 잘리게 된다.</li>
    </ol>
  </li>
  <li>만약 극단적으로 작은 사이즈를 준다면 (40x40)
    <ol>
      <li>이 경우 사이즈를 설정할 수 없기 때문에, Text가 Container의 제안을 무시하고 이상적인 사이즈로 표시해버립니다.</li>
      <li>
        <p>대안은 .layoutPriority modifier를 적용해 내부 View 사이에 우선순위를 제공하는 것 입니다.</p>

        <p><img src="/assets/images/swiftui/thinking-in-swiftui/3/Untitled 11.png" alt="Untitled" /></p>
      </li>
    </ol>
  </li>
</ol>

<h3 id="zstack">ZStack</h3>

<p>ZStack은 얼핏보면 overlay나 background와 동일한 역할을 할 것 같지만, overlay와 background는 ViewModifier기 때문에 하위뷰의 사이즈에 영향을 받는다. 그에 비해서 ZStack은 컨테이너기 때문에 내부의 View의 크기와 상관없이 Size를 잡게된다.</p>

<p>만약, 아래 코드를 root 에서 실행하게되면, 화면 전체를 다 가리게 된다.</p>

<h3 id="scrollview">ScrollView</h3>

<p>제안된 화면을 가득 채우게 되고, 내부 View는 contents의 사이즈에 맞춰진다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">ScrollView</span> <span class="p">{</span> 
	<span class="kt">Image</span><span class="p">(</span><span class="s">"logo"</span><span class="p">)</span>
		<span class="o">.</span><span class="nf">resizable</span><span class="p">()</span>
		<span class="o">.</span><span class="nf">aspectRatio</span><span class="p">(</span><span class="o">.</span><span class="n">fit</span><span class="p">)</span> 
	<span class="kt">Text</span><span class="p">(</span><span class="s">"This is a longer text"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>scrollView에 Shape 의 서브 뷰를 넣으면 10x10으로 표시되는 것을 볼 수 있다. 이는 Shape의 ProposedView의 기본값이 10, 10 이기 때문이다.</p>

</blockquote>

<h3 id="geometryreader"><strong>GeometryReader</strong></h3>

<p>제안받은 크기에 접근하는데 사용합니다. GeometryProxy 를 통해 제안받은 크기에 접근 할 수 있습니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">GeometryReader</span> <span class="p">{</span> <span class="n">proxy</span> <span class="k">in</span> 
	<span class="kt">Text</span><span class="p">(</span><span class="nv">verbatim</span><span class="p">:</span> <span class="s">"</span><span class="se">\(</span><span class="n">proxy</span><span class="o">.</span><span class="n">size</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>그러나 스택 오버플로우나 다른 사이트를 볼 때 GeometryReader에서 이슈가 생겨 고통받는 경우가 많습니다. 예를 들어서 GeometryReader 를 주위에 배치하고, Text의 사이즈를 측정하려고 하는 경우 Text 주변의 레이아웃이 잘못 나오는 경우가 많이 보고됩니다.</p>

<p>GeometryReader는 꼭 필요한 경우에만 써야 하고, 다음과 같은 경우에 유용하게 사용할 수 있습니다.</p>

<ul>
  <li>GeometryReader 내부에 유연한 View를 넣는 경우 레이아웃 사이즈를 체크할 수 있습니다.
    <ul>
      <li>예를 들어서 ScrollView 안에 GeometryReader를 넣는 경우 ScrollView의 내부 View 사이즈를 알 수 있습니다.</li>
    </ul>
  </li>
  <li>background나 overlay 안에 GeometryReader를 넣으면 기본 View 크기에는 영향을 미치지 않지만 관련된 다양한 값을 읽을 수 있습니다. (고급 레이아웃 장에서 더 자세한 예를 살펴보겠습니다.)</li>
</ul>

<h3 id="list">List</h3>

<hr />

<p>List는 UIkit에서 UITableView와 동일합니다. List 자체는 제안받은 크기를 가지며, ScrollView와 유사하게 View 자체는 너비와 높이를 제안하지 않습니다.</p>

<p>행의 높이가 고정되지 않은 UITableView와 비슷하고 내부에 배치된 항목을 기준으로 내부 View의 높이를 추정합니다.</p>

<h3 id="lazyhstack-lazyvstack">LazyHStack, LazyVStack</h3>

<p>List와 동일하게 View가 보여질 때 업데이트 한다.</p>

<h3 id="lazyvgrid-lazyhgrid">LazyVGrid, LazyHGrid</h3>

<p>LazyVGrid와 LazyHGrid는 모두 동일한 기본 알고리즘을 사용하여 열이나 행의 크기를 계산하므로 이 섹션 에서는 LazyVGrid에 중점을 둘 것입니다.</p>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/3/Untitled 12.png" alt="Untitled" /></p>

<p>그리드는 iOS 16에서 추가되었고, 17 이상에서도 아직 버그가 많기 때문에 짧게 다루고 넘어간다.</p>

<p>(가급적 쓰지 말것)</p>

<h3 id="viewthatfits"><strong>ViewThatFits</strong></h3>

<p>제안된 크기에 따라 다른 보기를 표시하려면 ViewThatFits를 사용하면 됩니다. 여러 개의 하위 뷰가 필요한 경우, 제안된 크기에 맞는 첫 번째 하위 뷰를 표시합니다. 이는 각 하위 뷰의 이상적인 크기를 파악하기 위해 nil을 제안하고, 이상적인 크기가 제안된 크기 내에 맞는 첫 번째 하위 뷰(코드에 하위 뷰가 나타나는 순서대로)를 표시합니다. 적합한 하위 뷰가 없으면 마지막 하위 뷰를 선택합니다.</p>

<h3 id="rendering-modiers"><strong>Rendering Modi!ers</strong></h3>

<p>SwiftUI에는 offset, RotationEffect, scaleEffect 등과 같이 뷰의 렌더링 방식에는 영향을 주지만 레이아웃 자체에는 영향을 미치지 않는 여러 뷰 수정자가 있습니다. 이러한 수정자는 CGContext.translate와 같은 작업을 수행한다고 생각할 수 있습니다. 이는 뷰가 그려지는 위치를 변경하지만, 레이아웃 시스템에서 보면 뷰는 여전히 원래 위치에 있습니다.</p>

<h2 id="alignment"><strong>Alignment</strong></h2>

<p>기본적으로 거의 모든 뷰는 하위 뷰의 중앙에 배치됩니다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Text</span><span class="p">(</span><span class="s">"Hello"</span><span class="p">)</span>
	<span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">width</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="nv">height</span><span class="p">:</span> <span class="mi">100</span><span class="p">)</span> <span class="c1">// 기본값이 .center</span>
</code></pre></div></div>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/3/Untitled 13.png" alt="Untitled" /></p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Text</span><span class="p">(</span><span class="s">"Hello"</span><span class="p">)</span>
	<span class="o">.</span><span class="nf">frame</span><span class="p">(</span><span class="nv">width</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="nv">height</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="nv">alignment</span><span class="p">:</span> <span class="o">.</span><span class="n">bottomTrailing</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/3/Untitled 14.png" alt="Untitled" /></p>

<p>정렬 가이드</p>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/3/Untitled 15.png" alt="Untitled" /></p>

<p>ZStack 역시 기본값은 .center라 아래의 경우 가운데에 쌓이게 된다.</p>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/3/Untitled 16.png" alt="Untitled" /></p>

<h3 id="정렬-가이드-수정">정렬 가이드 수정</h3>

<p>center, bottom같은 기본 정렬 가이드라인을 수정할 수 있다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">image</span> <span class="o">=</span> <span class="kt">Image</span><span class="p">(</span><span class="nv">systemName</span><span class="p">:</span> <span class="s">"pencil.circle.!ll"</span><span class="p">)</span> 
	<span class="o">.</span><span class="nf">alignmentGuide</span><span class="p">(</span><span class="o">.</span><span class="n">firstTextBaseline</span><span class="p">,</span> <span class="nv">computeValue</span><span class="p">:</span> <span class="p">{</span> <span class="n">dimension</span> <span class="k">in</span>
		<span class="n">dimension</span><span class="o">.</span><span class="n">height</span><span class="o">/</span><span class="mi">2</span> 
	<span class="p">}</span>
<span class="p">)</span>
</code></pre></div></div>

<p>image의 .firstTextBaseline을 줄여서 Image 가 firstTextBaseline으로 정렬했더니 아래로 밀리게 된다.</p>

<p>이렇게 수정한 이미지를 적용하면 다음과 같이 가이드라인이 변경된다.</p>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/3/Untitled 17.png" alt="Untitled" /></p>

<p>하지만 firstTextBaseline 을 수정했기 때문에 center로 설정하면 바뀌는게 없다.</p>

<p>이를 사용해 다음과 같이 범용적으로 적용 가능한 뱃지 아이콘을 만들수도 있다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="n">badge</span><span class="o">&lt;</span><span class="kt">B</span><span class="p">:</span> <span class="kt">View</span><span class="o">&gt;</span><span class="p">(</span><span class="kd">@ViewBuilder</span> <span class="n">_</span> <span class="nv">badge</span><span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">B</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="nf">overlay</span><span class="p">(</span><span class="nv">alignment</span><span class="p">:</span> <span class="o">.</span><span class="n">topTrailing</span><span class="p">)</span> <span class="p">{</span> <span class="nf">badge</span><span class="p">()</span>
                <span class="o">.</span><span class="nf">alignmentGuide</span><span class="p">(</span><span class="o">.</span><span class="n">top</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">height</span><span class="o">/</span><span class="mi">2</span> <span class="p">}</span>
		            <span class="o">.</span><span class="nf">alignmentGuide</span><span class="p">(</span><span class="o">.</span><span class="n">trailing</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span> <span class="p">}</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/3/Untitled 18.png" alt="Untitled" /></p>]]></content><author><name>jglee</name></author><category term="swiftui" /><category term="ios" /><summary type="html"><![CDATA[Thinking in SwiftUI - 3장 Layout]]></summary></entry><entry><title type="html">Thinking in SwiftUI - 2장 State and Binding</title><link href="https://leejigun.github.io/Thinking-in-SwiftUI-2%EC%9E%A5-State-and-Binding" rel="alternate" type="text/html" title="Thinking in SwiftUI - 2장 State and Binding" /><published>2024-05-27T04:47:00+09:00</published><updated>2024-05-27T04:47:00+09:00</updated><id>https://leejigun.github.io/Thinking-in-SwiftUI---2%EC%9E%A5-State-and-Binding</id><content type="html" xml:base="https://leejigun.github.io/Thinking-in-SwiftUI-2%EC%9E%A5-State-and-Binding"><![CDATA[<h1 id="thinking-in-swiftui---2장-state-and-binding">Thinking in SwiftUI - 2장 State and Binding</h1>

<p>Created: 2024년 5월 26일 오후 7:47
Tags: SwiftUI, iOS</p>

<p>이전 장에서 SwiftUI code가 <strong>View tree</strong>라는 청사진(블루프린트) 로 구성되는 방법과 영구 <strong>Render tree</strong>로 변환되는 방법에 대해서 알아보았습니다. 이번 장에서는 상태 기반으로 View tree를 구성하고 Render tree를 업데이트 하는 방법을 살펴봅니다.</p>

<p>일반적으로 뷰의 업데이트 주기는 다음과 같습니다.</p>

<ol>
  <li>상태를 기반으로 View Tree가 구성됩니다.</li>
  <li>현재 View Tree를 기반으로 Render Tree가 노드를 생성, 제거, 업데이트 합니다.</li>
  <li>이벤트가 발생해 상태가 변경됩니다.</li>
  <li>1번부터 3번까지 반복합니다.</li>
</ol>

<p>SwiftUI가 상태를 지속적으로 관찰하고 있기 때문에 언제 View tree가 다시 생성되는지, Render tree가 업데이트 되는지, 뷰의 무엇을 업데이트 해야 하는지 걱정할 필요가 없습니다. 다만, 너무 지나치게 광범위한 View 업데이트는 성능 이슈가 발생할 수 있고, 이번 장의 뒷 부분에서 다시 알아보겠습니다.</p>

<p>SwiftUI의 핵심이라고 할 수 있는 <strong>Property Wrapper</strong>에 대한 내용입니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>프로퍼티 래퍼는 속성에 적용되는 래퍼(Wrapper)로, 속성의 값에 추가적인 로직을 적용하거나, 값이 변경될 때 다른 동작을 수행할 수 있도록 해준다.
</code></pre></div></div>

<ul>
  <li><strong>@State, @Binding, @StateObject, @ObservedObject, @EnvironmentObject</strong> 등</li>
</ul>

<h2 id="data-flow-through-swiftui"><strong>Data Flow Through SwiftUI</strong></h2>

<hr />

<ul>
  <li><a href="https://wlaxhrl.tistory.com/91">https://wlaxhrl.tistory.com/91</a></li>
</ul>

<p>(Data Flow Through SwiftUI)</p>

<p><strong>(여기서 중요한건 SSOT !!)</strong></p>

<h3 id="state"><strong>@State</strong></h3>

<hr />

<p><strong>뷰의 상태를 관리하기 위한 프로퍼티 래퍼.</strong></p>

<ul>
  <li>Value Type</li>
  <li>뷰의 로컬 데이터 (내부 프로퍼티)</li>
  <li>뷰에서 소유되고 관리되어야 하는 데이터 (ex. 텍스트필드, 토글버튼 등)</li>
</ul>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/2/Untitled.png" alt="Untitled" /></p>

<p>Counter 예시를 살펴보면, 버튼을 누를 때마다 상태값이 변경되고 화면이 다시 그려집니다. 만약 버튼의 라벨에 상태값을 바인딩하지 않았다면, SwiftUI는 업데이트할 필요가 없다는 것을 인지하고 화면을 다시 그리지 않습니다.</p>

<h2 id="view의-생성-4단계">View의 생성 4단계</h2>

<hr />

<ol>
  <li>Counter 구조체가 처음 생성되면, View tree는 만들어지지만 아직 Render tree에 노드가 존재하지 않습니다. State라는 PropertyWrapper 역시 초기값을 할당하고 있지만, 아직 아무것도 바인딩하지 않았기 떄문에 View는 비어있습니다.</li>
</ol>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/2/Untitled 1.png" alt="Untitled" /></p>

<ol>
  <li>SwiftUI는 Render tree에 노드를 생성하면서 State를 할당합니다. 이제 PropertyWrapper 의 메모리는 랜더 노드를 가리키게 됩니다.</li>
</ol>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/2/Untitled 2.png" alt="Untitled" /></p>

<ol>
  <li>View의 body 부분이 실행되고, <code class="language-plaintext highlighter-rouge">Button</code>이 생성됩니다. 이제 state 값은 랜더 노드를 가리키고 있기 때문에 <code class="language-plaintext highlighter-rouge">Button</code> 의 label 값은 랜더 노드에 저장된 값을 사용합니다.</li>
</ol>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/2/Untitled 3.png" alt="Untitled" /></p>

<ol>
  <li>마지막으로 노드의 값을 읽어 값이 설정된 view body 부분을 랜더링해 실제 UI를 만듭니다.</li>
</ol>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/2/Untitled 4.png" alt="Untitled" /></p>

<h2 id="이벤트-발생-3단계">이벤트 발생 3단계</h2>

<hr />

<ol>
  <li>View에 이벤트가 발생하면 뷰와 연결된 랜더 트리에 전달되고, 랜더 트리를 지켜보고 있던 PropertyWrapper 쪽에 메모리가 증가합니다.</li>
  <li>State가 변경되었기 때문에 body가 다시 실행되고, View tree 가 구성됩니다.</li>
  <li>다시 구성된 View tree를 기반으로 랜더트리의 값이 변경되고, UI가 다시 랜더링됩니다.</li>
</ol>

<p>(ex) <strong>SwiftUI 프레임워크의 Button의 highlight 상태는 Button 내부에서 @State로 관리된다.</strong> 이는 터치 중일 때는 highlighted 상태로, 터치가 끝났을 때는 highlighted가 아닌 상태로 관리될 수 있기 때문에, <strong>외부에서 관리할 필요 없이 Button 내부에서만 관리</strong>하면 된다.</p>

<blockquote>
  <p>원래 @State property wrapper는 value type에만 사용했지만, iOS 17에서 Observable 매크로가 도입되면서 변경되었다. 하지만, 17 이전 OS에서는 value 타입에만 사용해야 합니다.</p>

</blockquote>

<h2 id="state-and-observable"><strong>State and Observable</strong></h2>

<hr />

<p>@State를 사용할 때 2가지 실수를 저지를 수 있습니다.</p>

<ol>
  <li>외부에서 전달받은 객체를 사용하는 경우</li>
  <li>View 전용 객체인데, @State를 사용하지 않는 경우</li>
</ol>

<p>둘 다 객체의 수명과 관련이 있습니다. 외부에서 수명이 관리되는 객체의 경우 @State를 사용하지 않는다는 것 입니다.</p>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/2/Untitled 5.png" alt="Untitled" /></p>

<p>만약, 위와 같이 모델을 외부에서 전달받는 경우 초기값은 Button에 잘 셋팅되겠지만, 이미 View가 만들어진 상태에서 외부에서 Model의 값을 변경해도 상태 변화에 영향을 주지 못합니다.</p>

<h2 id="observableobject-protocol"><strong>ObservableObject Protocol</strong></h2>

<hr />

<p>iOS 17 이후에는 @Obserable 매크로를 사용해 편하게 사용할 수 있지만, 17 이전에는 다양안 <strong>ObservableObject Protocol</strong> 의 속성 래퍼는 사용할 수 있습니다.</p>

<ol>
  <li>@StateObject
    <ol>
      <li>@State와 거의 동일한 방식으로 동작</li>
      <li>랜더 트리에 노드가 생성될 때 초기값을 지정합니다.</li>
      <li>@State와 동일하게 private하게 사용해야 합니다. (외부에서  전답하거나, 조작하지 말것)</li>
    </ol>
  </li>
  <li>@ObservableObject
    <ol>
      <li>@StateObject 보다 간단한 구조로 초기값을 할당하지 않고 구독한 하는 관계</li>
    </ol>
  </li>
</ol>

<h2 id="observableobject"><strong>@ObservableObject</strong></h2>

<hr />

<ul>
  <li>Reference Type</li>
  <li>이미 관리(소유)하고 있는 데이터에 적용하면 좋음</li>
  <li>외부로부터의 데이터를 표현할 때</li>
</ul>

<p>case 1 : State 로 int 값을 표현할 때</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">ContentView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@State</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">rootCount</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">CountView</span><span class="p">(</span><span class="nv">rootCount</span><span class="p">:</span> <span class="n">rootCount</span><span class="p">)</span>
        <span class="kt">Button</span><span class="p">(</span><span class="nv">action</span><span class="p">:</span> <span class="p">{</span><span class="n">rootCount</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">},</span> <span class="nv">label</span><span class="p">:</span> <span class="p">{</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"Root Add"</span><span class="p">)</span>
        <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>case 2 : ObservedObject 로 모델을 표현할 때</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">CountView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@ObservedObject</span> <span class="k">var</span> <span class="nv">viewModel</span> <span class="o">=</span> <span class="kt">CountViewModel</span><span class="p">()</span>
    <span class="k">let</span> <span class="nv">rootCount</span><span class="p">:</span> <span class="kt">Int</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">VStack</span> <span class="p">{</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"Root: </span><span class="se">\(</span><span class="n">rootCount</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"Count: </span><span class="se">\(</span><span class="n">viewModel</span><span class="o">.</span><span class="n">count</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
            <span class="kt">Button</span><span class="p">(</span><span class="nv">action</span><span class="p">:</span> <span class="p">{</span><span class="n">viewModel</span><span class="o">.</span><span class="nf">addCount</span><span class="p">()},</span> <span class="nv">label</span><span class="p">:</span> <span class="p">{</span>
                <span class="kt">Text</span><span class="p">(</span><span class="s">"Counter Add"</span><span class="p">)</span>
            <span class="p">})</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="https://miro.medium.com/v2/resize:fit:302/1*6QE-DMrqDVycvuFBx0sp4g.gif" alt="" /></p>

<p>Root Add 버튼을 누를 때마다 ViewModel이 초기화되고 있었다. 그러니까 Count가 0부터 새롭게 시작하게 된다.</p>

<blockquote>
  <p>ViewModel이 View에 붙어있기 때문에 root add 버튼을 누르면 뷰가 새로 만들어지면서 ViewModel 도 교체된다.</p>

</blockquote>

<h3 id="stateobject"><strong>@StateObject</strong></h3>

<blockquote>
  <p>A state object behaves like an observed object, except that SwiftUI knows to create and manage a single object instance for a given view instance, regardless of how many times it recreates the view.</p>

</blockquote>

<p>StateObject는 ObservedObject와 거의 똑같으나, 이 StateObject는 하나의 객체로 만들어지고, View가 얼마나 초기화되든지 상관없이 별개의 객체로 관리된다.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">CountView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@StateObject</span> <span class="k">var</span> <span class="nv">viewModel</span> <span class="o">=</span> <span class="kt">CountViewModel</span><span class="p">()</span>
    <span class="k">let</span> <span class="nv">rootCount</span><span class="p">:</span> <span class="kt">Int</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">VStack</span> <span class="p">{</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"Root: </span><span class="se">\(</span><span class="n">rootCount</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"Count: </span><span class="se">\(</span><span class="n">viewModel</span><span class="o">.</span><span class="n">count</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
            <span class="kt">Button</span><span class="p">(</span><span class="nv">action</span><span class="p">:</span> <span class="p">{</span><span class="n">viewModel</span><span class="o">.</span><span class="nf">addCount</span><span class="p">()},</span> <span class="nv">label</span><span class="p">:</span> <span class="p">{</span>
                <span class="kt">Text</span><span class="p">(</span><span class="s">"Counter Add"</span><span class="p">)</span>
            <span class="p">})</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="https://miro.medium.com/v2/resize:fit:302/1*8Kw64zPUp4mu4KmVMzo6fg.gif" alt="" /></p>

<p>Root Add를 눌러도 Count가 초기화되지 않는다! 기존의 데이터가 보존되는 것을 확인할 수 있다.</p>

<h3 id="stateobject-vs-observedobject">StateObject vs ObservedObject</h3>

<p>애플이 추천하는 StateObject와 ObservedObject의 사용법은 Observable Object를 처음 초기화할 때는 StateObject를 사용하고, 이미 객체화된 것을 넘겨 받을 때 ObservedObject의 사용을 추천하고 있다. </p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 직접 View에서 만들 때</span>
<span class="kd">struct</span> <span class="kt">UpperView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
  <span class="kd">@StateObject</span> <span class="k">var</span> <span class="nv">viewModel</span><span class="p">:</span> <span class="kt">ViewModel</span> <span class="o">=</span> <span class="kt">ViewModel</span><span class="p">()</span>
  <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kt">LowerView</span><span class="p">(</span><span class="nv">viewModel</span><span class="p">:</span> <span class="n">viewModel</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 외부에서 넘겨받을 때</span>
<span class="kd">struct</span> <span class="kt">LowerView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
  <span class="kd">@ObservedObject</span> <span class="k">var</span> <span class="nv">viewModel</span><span class="p">:</span> <span class="kt">ViewModel</span>
  <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kt">Text</span><span class="p">(</span><span class="s">"Hello"</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>@StateObject</strong>와 <strong>@ObservedObject</strong>는 각각의 생명주기와 사용법을 살펴보자.</p>

<ol>
  <li><strong>@StateObject</strong>:
    <ul>
      <li><strong>생명주기</strong>: <strong>@StateObject</strong>는 뷰가 생성될 때 인스턴스를 만들고, 뷰가 소멸될 때 인스턴스를 해제합니다. 뷰의 생명주기와 일치하며, 뷰가 인스턴스를 소유하고 관리합니다.</li>
      <li><strong>사용법</strong>: 주로 뷰 내에서 상태를 유지해야 하는 경우에 사용됩니다. 예를 들어, 뷰 내에서 데이터를 수정하고 해당 변경 사항을 추적해야 할 때 유용합니다.</li>
    </ul>
  </li>
  <li><strong>@ObservedObject</strong>:
    <ul>
      <li><strong>생명주기</strong>: <strong>@ObservedObject</strong>는 뷰가 생성될 때마다 새로운 인스턴스를 만듭니다. 뷰의 생명주기와는 독립적으로 동작하며, 뷰가 인스턴스를 소유하지 않습니다. 따라서 뷰가 인스턴스를 생성하고 해제하지 않습니다.</li>
      <li><strong>사용법</strong>: 다른 뷰에서 관찰하고 싶은 객체의 변경 사항을 감지할 때 사용됩니다. 주로 다른 뷰에서 생성한 인스턴스를 참조하고 싶을 때 유용합니다.</li>
    </ul>
  </li>
</ol>

<p>간단히 말하면, <strong>@StateObject</strong>는 뷰가 인스턴스를 소유하고 관리하며, <strong>@ObservedObject</strong>는 뷰가 인스턴스를 생성하지 않고 변경 사항을 감지할 때 사용됩니다. 이를 이해하면 SwiftUI에서 상태 관리를 더 효율적으로 할 수 있습니다!</p>

<h2 id="update-view-performance">Update, View Performance</h2>

<hr />

<p>앞서 본 것과 같이 State와 UI가 연결되어 자동으로 업데이트 된다. 상태가 변경된다고 전체 UI를 다시 그리는게 아니라, 특정 State와 View 사이에 종속성을 설정해 그 부분만 업데이트 되게 된다.</p>

<p>SwiftUI는 일부 State가 변경 될 때 View Tree에서 꼭 필요한 부분만 다시 랜더링되도록 많은 노력을 기울인다. 그러니 이런 노력을 방해하지 않는 방식으로 코드를 작성하는 것도 중요하다.</p>

<ol>
  <li>예를 들어 모든 State를 하나의 큰 객체 안에 넣는다면, 특정 변경으로 모든 하위의 작은 뷰를 업데이트 할 수 있다. 따라서 State를 작은 단위로 나눠서 뷰를 업데이트 하는게 성능적으로 더 도움이됩니다.</li>
  <li>실제로 필요한 값만 하위 View로 전달하는게 중요합니다. 많은 데이터를 가진 큰 객체가 있고, 이 객체를 통으로 넘겨주게 되면, 객체가 업데이트 될 때 마다 객체가 업데이트 될 수 있습니다.</li>
</ol>

<p>성능 이슈가 발생할 때 어떤 뷰의 body가 실행되는지 판단하는 몇가지 방법이 있습니다.</p>

<h3 id="1-print-삽입">1. print 삽입</h3>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/2/Untitled 6.png" alt="Untitled" /></p>

<h3 id="2-selfprintcahnges">2. Self.printCahnges()</h3>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/2/Untitled 7.png" alt="Untitled" /></p>

<p>print문과 다르게 재실행된 이유를 같이 호출해줍니다.</p>

<ul>
  <li>상태 변경으로 다시 호출되는 경우 ⇒ 상태 이름, 속성 표시</li>
  <li>뷰 값 자체가 변경된 경우 ⇒ 속성이 변경된 경우 @self가 기록됩니다.</li>
  <li>View의 ID 값이 변경된 경우 ⇒ @identity가 기록됩니다. (일반적으로 새로 삽입된 경우)</li>
</ul>

<h3 id="3-instruments">3. instruments</h3>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/2/Untitled 8.png" alt="Untitled" /></p>

<h3 id="observable-매크로"><strong>Observable 매크로</strong></h3>

<hr />

<p><a href="https://developer.apple.com/documentation/Observation">Observation</a>을 통해 SwiftUI는 observable data model 에 의존성을 형성하고 data 가 변할때마다 UI 를 업데이트 합니다.</p>

<h3 id="기존-observableobject-와-달라지는-것들"><strong>기존 ObservableObject 와 달라지는 것들</strong></h3>

<p><strong>첫번째: 코드가 간결해짐</strong></p>

<p>| <strong>AS-IS</strong> | <strong>TO-BE</strong> |
| — | — |
| final class Book: ObservableObject {
    @Published var title = “Sample Book Title”
    var isAvailable = true
}</p>

<p>struct BookView: View {
    @ObservedObject var book: Book
    
    var body: some View {
        Text(book.title)
    }
} | @Observable final class Book {
    var title = “Sample Book Title”
    var isAvailable = true
}</p>

<p>struct BookView: View {
    var book: Book
    
    var body: some View {
        Text(book.title)
    }
} |</p>

<p><strong>두번째: 뷰 업데이트 매커니즘이 좀 더 효율적으로 바뀜</strong></p>

<p>@Observable 매크로를 쓰면</p>

<p>뷰의 body 에서 프로퍼티를 직접 읽어야지만 뷰 업데이트가 된다.</p>

<p>ObservableObject에서는 published 프로퍼티가 변하면 뷰가 해당 프로퍼티를 읽고 있지 않아도 다시 그려진다.</p>

<p><strong>세번째: data model object 를 optional로 들고 있을 수 있다.</strong></p>

<p><strong>네번째: data model objects를 collection으로도 가능하다.</strong></p>

<p><a href="https://eunjin3786.tistory.com/580"><strong>https://eunjin3786.tistory.com/580</strong></a></p>

<p><img src="/assets/images/swiftui/thinking-in-swiftui/2/Untitled 9.png" alt="Untitled" /></p>

<ul>
  <li>매크로 기능은 iOS 17 이상</li>
</ul>

<p>새로운 매크로 기반 객체 관찰 모델은 <strong>편리한 구문</strong>을 도입하고, 뷰와 관찰 가능한 객체 간의 종속성이 형성되는 방식을 변경합니다. 이전 속성 래퍼를 사용할 때, SwiftUI는 <code class="language-plaintext highlighter-rouge">@StateObject</code>의 <code class="language-plaintext highlighter-rouge">objectWillChange</code> 게시자를 맹목적으로 구독하거나, <code class="language-plaintext highlighter-rouge">@ObservedObject</code>를 뷰에서 선언했습니다.</p>

<p>새로운 <code class="language-plaintext highlighter-rouge">Observable</code> 매크로를 사용하면, <code class="language-plaintext highlighter-rouge">Observable</code>의 모든 속성이 뷰 본문에서 접근하는 객체는 객체가 어디에서 왔는지에 관계없이 이 뷰에 대한 종속성을 형성합니다.</p>

<p><strong>이 새로운 모델은 훨씬 더 간결하고 효율적입니다.</strong> 예를 들어, 뷰 본문에서 전역 <strong>싱글톤(관찰 가능)</strong>에 액세스할 경우, <code class="language-plaintext highlighter-rouge">@ObservedObject</code>를 사용하여 싱글톤을 뷰에 전달할 필요 없이, 액세스된 속성과 뷰 사이에 자동으로 종속성이 형성됩니다. 관찰 가능한 객체는 옵션, 배열 또는 다른 컬렉션에 중첩될 수 있으며, 속성 수준 추적으로 인해 관찰 및 뷰 업데이트가 예상대로 계속 작동합니다.</p>

<p>또한, 뷰 본문에서 객체의 속성 하나만 사용하는 경우, 다른 속성이 변경되어도 이 뷰는 다시 그려지지 않습니다. 모델 객체를 사용하지 않는 경우(예: 코드의 한 분기에만 존재하는 경우), 모델은 전혀 관찰되지 않습니다. 이를 통해 불필요한 뷰 업데이트를 줄여 성능을 향상시킬 수 있습니다. 이전에는 모델 객체를 수동으로 분할하여 더 세분화된 뷰 업데이트를 얻었습니다.</p>]]></content><author><name>jglee</name></author><category term="swiftui" /><category term="ios" /><summary type="html"><![CDATA[Thinking in SwiftUI - 2장 State and Binding]]></summary></entry></feed>